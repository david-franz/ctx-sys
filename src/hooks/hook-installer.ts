/**
 * Git hook installer for ctx-sys.
 */

import * as fs from 'fs';
import * as path from 'path';
import { HookConfig, InstallResult, DEFAULT_HOOK_CONFIG } from './types';

/**
 * Installs and manages ctx-sys git hooks.
 */
export class HookInstaller {
  /**
   * Install ctx-sys hooks into a git repository.
   */
  async install(
    repoPath: string,
    config: Partial<HookConfig> = {}
  ): Promise<InstallResult> {
    const hooksDir = path.join(repoPath, '.git', 'hooks');

    // Verify this is a git repository
    if (!fs.existsSync(hooksDir)) {
      throw new Error('Not a git repository or .git/hooks directory not found');
    }

    const hookConfig: HookConfig = { ...DEFAULT_HOOK_CONFIG, ...config };
    const installed: string[] = [];

    // Install enabled hooks
    if (hookConfig.enablePreCommit) {
      await this.installHook(hooksDir, 'pre-commit', hookConfig);
      installed.push('pre-commit');
    }

    if (hookConfig.enablePostMerge) {
      await this.installHook(hooksDir, 'post-merge', hookConfig);
      installed.push('post-merge');
    }

    if (hookConfig.enablePrePush) {
      await this.installHook(hooksDir, 'pre-push', hookConfig);
      installed.push('pre-push');
    }

    if (hookConfig.enablePostCheckout) {
      await this.installHook(hooksDir, 'post-checkout', hookConfig);
      installed.push('post-checkout');
    }

    // Save config
    const configDir = path.join(repoPath, '.ctx-sys');
    if (!fs.existsSync(configDir)) {
      fs.mkdirSync(configDir, { recursive: true });
    }
    const configPath = path.join(configDir, 'hooks.json');
    fs.writeFileSync(configPath, JSON.stringify(hookConfig, null, 2));

    return {
      success: true,
      installed,
      configPath
    };
  }

  /**
   * Uninstall ctx-sys hooks from a repository.
   */
  async uninstall(repoPath: string): Promise<void> {
    const hooksDir = path.join(repoPath, '.git', 'hooks');
    const hookNames = ['pre-commit', 'post-merge', 'pre-push', 'post-checkout'];

    for (const hookName of hookNames) {
      const hookPath = path.join(hooksDir, hookName);

      try {
        if (fs.existsSync(hookPath)) {
          const content = fs.readFileSync(hookPath, 'utf-8');

          // Only remove if it's our hook
          if (content.includes('ctx-sys-hook')) {
            fs.unlinkSync(hookPath);

            // Restore backup if it exists
            const backupPath = `${hookPath}.pre-ctx-sys`;
            if (fs.existsSync(backupPath)) {
              fs.renameSync(backupPath, hookPath);
            }
          }
        }
      } catch {
        // Hook doesn't exist or can't be removed, continue
      }
    }

    // Remove config file
    const configPath = path.join(repoPath, '.ctx-sys', 'hooks.json');
    if (fs.existsSync(configPath)) {
      fs.unlinkSync(configPath);
    }
  }

  /**
   * Check if hooks are installed in a repository.
   */
  isInstalled(repoPath: string): boolean {
    const hookPath = path.join(repoPath, '.git', 'hooks', 'pre-commit');
    if (!fs.existsSync(hookPath)) {
      return false;
    }

    const content = fs.readFileSync(hookPath, 'utf-8');
    return content.includes('ctx-sys-hook');
  }

  /**
   * Get the hook configuration from a repository.
   */
  getConfig(repoPath: string): HookConfig | null {
    const configPath = path.join(repoPath, '.ctx-sys', 'hooks.json');
    if (!fs.existsSync(configPath)) {
      return null;
    }

    const content = fs.readFileSync(configPath, 'utf-8');
    return JSON.parse(content);
  }

  /**
   * Install a single hook.
   */
  private async installHook(
    hooksDir: string,
    hookName: string,
    config: HookConfig
  ): Promise<void> {
    const hookPath = path.join(hooksDir, hookName);

    // Check if hook already exists and back it up
    if (fs.existsSync(hookPath)) {
      const content = fs.readFileSync(hookPath, 'utf-8');
      // Don't backup if it's already our hook
      if (!content.includes('ctx-sys-hook')) {
        const backupPath = `${hookPath}.pre-ctx-sys`;
        fs.copyFileSync(hookPath, backupPath);
      }
    }

    // Write our hook
    const hookContent = this.generateHookScript(hookName, config);
    fs.writeFileSync(hookPath, hookContent);
    fs.chmodSync(hookPath, 0o755);
  }

  /**
   * Generate the shell script for a hook.
   */
  private generateHookScript(hookName: string, config: HookConfig): string {
    const asyncMode = config.asyncMode ? 'true' : 'false';
    const timeout = Math.floor(config.timeoutMs / 1000);

    return `#!/bin/bash
# ctx-sys-hook: ${hookName}
# Auto-generated by ctx-sys. Do not edit manually.

# Configuration
CTX_SYS_SERVER="${config.serverUrl}"
CTX_SYS_PROJECT="${config.projectId}"
CTX_SYS_TIMEOUT="${config.timeoutMs}"
CTX_SYS_VERBOSE="${config.verbosity}"

# Find ctx-sys hook handler
find_handler() {
  if command -v ctx-sys-hook &> /dev/null; then
    echo "ctx-sys-hook"
  elif [ -f "./node_modules/.bin/ctx-sys-hook" ]; then
    echo "./node_modules/.bin/ctx-sys-hook"
  elif command -v npx &> /dev/null; then
    echo "npx ctx-sys-hook"
  else
    return 1
  fi
}

HOOK_HANDLER=$(find_handler)
if [ -z "$HOOK_HANDLER" ]; then
  # ctx-sys not available, skip silently
  exit 0
fi

# Execute hook
if [ "${asyncMode}" = "true" ]; then
  # Run in background, don't block git operation
  $HOOK_HANDLER ${hookName} "$@" &>/dev/null &
  exit 0
else
  # Run synchronously with timeout
  if command -v timeout &> /dev/null; then
    timeout ${timeout}s $HOOK_HANDLER ${hookName} "$@"
    exit_code=$?

    if [ $exit_code -eq 124 ]; then
      echo "Warning: ctx-sys hook timed out" >&2
      exit 0  # Don't block git operation on timeout
    fi

    exit $exit_code
  else
    # No timeout command available, run directly
    $HOOK_HANDLER ${hookName} "$@"
    exit $?
  fi
fi
`;
  }
}
