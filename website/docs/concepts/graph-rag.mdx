---
title: Graph RAG
sidebar_position: 1
description: Understanding how ctx-sys uses knowledge graphs for intelligent retrieval
---

# Graph RAG

ctx-sys uses **Graph-based Retrieval Augmented Generation (Graph RAG)** combined with hybrid search to provide intelligent context retrieval. This page explains how it works.

## What is Graph RAG?

Traditional RAG (Retrieval Augmented Generation) uses vector similarity to find relevant documents. Graph RAG enhances this by:

1. **Building a knowledge graph** of entities and relationships
2. **Traversing the graph** to find connected context
3. **Combining multiple strategies** for comprehensive retrieval

## The ctx-sys Knowledge Graph

### Entities (Nodes)

ctx-sys extracts and indexes various entity types:

| Entity Type | Description | Examples |
|-------------|-------------|----------|
| `function` | Standalone functions | `authenticate()`, `parseConfig()` |
| `class` | Class definitions | `UserService`, `AuthMiddleware` |
| `interface` | Type interfaces | `User`, `Config` |
| `method` | Class methods | `UserService.findById()` |
| `file` | Source files | `src/auth/service.ts` |
| `document` | Documentation | `README.md`, `ARCHITECTURE.md` |
| `section` | Document sections | Extracted headings from markdown |
| `requirement` | Requirements | Extracted from requirements docs |
| `decision` | Recorded decisions | "Use JWT for stateless auth" |

### Relationships (Edges)

Relationships are automatically extracted from AST analysis:

| Relationship | Description | Source |
|--------------|-------------|--------|
| `CONTAINS` | File contains symbol | AST parsing |
| `IMPORTS` | File imports another file | AST import analysis |
| `CALLS` | Function/method calls another | AST call analysis |
| `EXTENDS` | Class inherits from another | AST class analysis |
| `IMPLEMENTS` | Class implements interface | AST class analysis |
| `USES` | Entity references a type | AST type analysis |
| `DOCUMENTS` | Doc references code | Document linking |
| `RELATES_TO` | Semantic relationship | LLM extraction |

## How Retrieval Works

```
┌─────────────────────────────────────────────────────────────┐
│               Query: "How does auth work?"                  │
└─────────────────────────────────────────────────────────────┘
                              │
              ┌───────────────┼───────────────┐
              ▼               ▼               ▼
      ┌──────────────┐ ┌──────────────┐ ┌──────────────┐
      │   FTS5       │ │   Semantic   │ │    Graph     │
      │   Keyword    │ │   Vector     │ │  Traversal   │
      │   Search     │ │   Search     │ │              │
      │              │ │              │ │ Connected    │
      │ BM25 ranking │ │ Cosine sim.  │ │ entities     │
      └──────┬───────┘ └──────┬───────┘ └──────┬───────┘
             │                │                │
             └────────────────┼────────────────┘
                              ▼
                     ┌──────────────┐
                     │   RRF Merge  │
                     │   + Re-rank  │
                     └──────┬───────┘
                            │
                     ┌──────┴───────┐
                     │   Context    │
                     │  Expansion   │
                     │ (parents,    │
                     │  imports,    │
                     │  types)      │
                     └──────┬───────┘
                            │
                            ▼
              ┌─────────────────────────┐
              │   Assembled Context     │
              │   - AuthService class   │
              │   - authenticate()      │
              │   - AuthMiddleware      │
              │   - Decision: "Use JWT" │
              │   - Parent class source │
              └─────────────────────────┘
```

### 1. Query Processing

The query pipeline includes:

- **Query parsing** - Extract intent, entities, and scope
- **Query decomposition** - Split multi-part queries (e.g., "How does auth work and where is the config?" becomes two sub-queries)
- **HyDE expansion** - Generate hypothetical answer for better semantic matching

### 2. Multi-Strategy Search

ctx-sys combines multiple search strategies:

- **FTS5 Keyword Search** - SQLite FTS5 with BM25 ranking for exact and prefix matches
- **Semantic Vector Search** - Cosine similarity using embeddings (Ollama nomic-embed-text)
- **Graph Traversal** - Following relationships to find connected entities

### 3. Result Merging & Re-ranking

Results from each strategy are merged using **Reciprocal Rank Fusion (RRF)** with configurable weights:

```yaml
retrieval:
  strategies:
    - vector
    - graph
    - fts
```

Optionally, an **LLM re-ranker** (Ollama qwen3:0.6b) scores the top-K candidates for relevance, blending LLM judgement (70%) with the original search score (30%).

### 4. Smart Context Expansion

After finding relevant entities, ctx-sys automatically expands context:

- **Parent expansion** - Methods include their parent class source
- **Import expansion** - Files include their imported dependencies
- **Type expansion** - Entities include referenced types and interfaces

This expansion is controlled by a token budget to prevent context bloat.

## Benefits Over Traditional RAG

### 1. Discovers Hidden Connections

```
Query: "How is the User class used?"

Traditional RAG might miss:
  - Controllers that use UserService (which uses User)
  - Test files that mock User
  - Documentation about user data model

Graph RAG finds all of these by traversing relationships.
```

### 2. Preserves Structural Context

Instead of isolated chunks, Graph RAG returns:
- The entity itself with full source code
- Its parent class/module
- Its immediate relationships (imports, calls)
- Relevant decisions about it
- Connected documentation

### 3. Handles Long Entities

ctx-sys uses **overlapping chunking** for entities that exceed embedding model limits:
- Splits at smart boundaries (paragraph > line > sentence > word)
- Each chunk overlaps with its neighbors to prevent information loss at boundaries
- Tiny final chunks are absorbed into the previous chunk

### 4. Reduces Token Waste

By understanding relationships, ctx-sys can:
- Skip redundant content
- Include only relevant parts of large files
- Prioritize directly connected entities
- Respect token budgets while maximizing relevance

## Practical Example

Consider asking: "How does the payment system work?"

### Traditional RAG Result

Might return random chunks containing "payment":
- A comment mentioning payment in an unrelated file
- Part of the PaymentService class
- A test file with payment in the name

### ctx-sys Graph RAG Result

Returns a coherent picture:

1. **PaymentService** class (full source code)
2. **processPayment()** method
3. **PaymentController** (calls PaymentService)
4. **StripeClient** (dependency of PaymentService)
5. **Decision**: "Use Stripe for payment processing"
6. **Related docs**: payment-flow.md
7. **Parent class**: BaseService (inherited methods)

## Tuning Graph RAG

### Adjust Traversal Depth

```yaml
retrieval:
  graphDepth: 2       # How many hops to traverse
  maxGraphNodes: 20   # Max entities from graph
```

### Configure Token Budget

```yaml
retrieval:
  default_max_tokens: 4000  # Total context budget
```

### Filter by Entity Type

```yaml
retrieval:
  entityTypes:
    - function
    - class
    - decision
  excludeTypes:
    - test
```

## Next Steps

- [Decision Extraction](/docs/concepts/decision-extraction)
- [Configuration guide](/docs/guides/configuration)
