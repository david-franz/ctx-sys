# F10e.5 Conversation Intelligence

**Phase**: 10e - Knowledge Bases & Long-Term Context
**Priority**: High
**Dependencies**: None

## Problem

The conversation system stores messages but doesn't make them searchable in any meaningful way:

1. **No message embeddings**: Can't do "find conversations similar to X". Message search is LIKE-based substring matching only — no ranking, no semantic similarity.

2. **No FTS5 on messages**: The entities table has an FTS5 virtual table, but messages don't. Can't do ranked text search, stemming, or boolean queries on conversation history.

3. **Decisions are never persisted**: Every `search_decisions` call re-scans messages with LIKE queries and keyword matching. There is no decisions table. Decisions are the most valuable artifact of a conversation for long-term context.

4. **Messages not linked to entities**: No relationship between "we discussed EntityStore" and the EntityStore entity. Context about *why* code was written is disconnected from *what* was written.

## Implementation

### 5a: Message FTS5

#### File: `src/db/schema.ts`

Add FTS5 virtual table for messages (in `createProjectTables`):

```sql
CREATE VIRTUAL TABLE IF NOT EXISTS ${prefix}_messages_fts USING fts5(
  content,
  content=${prefix}_messages,
  content_rowid=rowid,
  tokenize='porter unicode61'
);

-- Triggers to keep FTS in sync
CREATE TRIGGER IF NOT EXISTS ${prefix}_messages_fts_insert
  AFTER INSERT ON ${prefix}_messages BEGIN
    INSERT INTO ${prefix}_messages_fts(rowid, content) VALUES (NEW.rowid, NEW.content);
  END;

CREATE TRIGGER IF NOT EXISTS ${prefix}_messages_fts_delete
  AFTER DELETE ON ${prefix}_messages BEGIN
    INSERT INTO ${prefix}_messages_fts(${prefix}_messages_fts, rowid, content)
      VALUES('delete', OLD.rowid, OLD.content);
  END;
```

#### File: `src/conversation/message-store.ts`

Add `searchFTS()` method:

```typescript
async searchFTS(query: string, options?: { limit?: number; sessionId?: string }): Promise<Message[]>
// Uses: SELECT m.* FROM messages_fts fts
//       JOIN messages m ON m.rowid = fts.rowid
//       WHERE messages_fts MATCH ?
//       ORDER BY rank
```

### 5b: Message Embeddings

#### File: `src/conversation/message-store.ts`

Add `embedMessage()` that stores a vector for the message using the existing EmbeddingManager:

```typescript
async embedMessage(messageId: string, embeddingManager: EmbeddingManager): Promise<void>
// 1. Get message content
// 2. Create a synthetic entity ID for the message (or use message ID directly)
// 3. Call embeddingManager.embed(messageId, content)
```

This reuses the existing vectors table — messages get vectors just like entities.

#### Opt-in via config

```yaml
sessions:
  embed_messages: false  # Default off — opt-in per project
```

When enabled, `store_message` triggers embedding after storage.

#### Integration with context_query

Add `include_conversations` option to `QueryOptions`:

```typescript
export interface QueryOptions {
  // ... existing fields ...
  includeConversations?: boolean;  // Search conversation history too
}
```

When enabled, `queryContext()` also searches message vectors and includes relevant conversation snippets in the assembled context.

### 5c: Persistent Decisions

#### File: `src/db/schema.ts`

New table:

```sql
CREATE TABLE IF NOT EXISTS ${prefix}_decisions (
  id TEXT PRIMARY KEY,
  session_id TEXT NOT NULL,
  message_id TEXT,
  description TEXT NOT NULL,
  context TEXT,
  alternatives TEXT,           -- JSON array of strings
  related_entity_ids TEXT,     -- JSON array of entity IDs
  status TEXT DEFAULT 'active', -- active, superseded, reversed
  superseded_by TEXT,          -- FK to another decision
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (session_id) REFERENCES ${prefix}_sessions(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_${prefix}_decisions_session
  ON ${prefix}_decisions(session_id);

-- FTS for decision search
CREATE VIRTUAL TABLE IF NOT EXISTS ${prefix}_decisions_fts USING fts5(
  description,
  context,
  content=${prefix}_decisions,
  content_rowid=rowid,
  tokenize='porter unicode61'
);
```

#### File: `src/conversation/decision-store.ts` (new)

```typescript
export class DecisionStore {
  create(input: DecisionInput): Promise<Decision>
  get(id: string): Promise<Decision | null>
  search(query: string, options?: { sessionId?: string; status?: string; limit?: number }): Promise<Decision[]>
  supersede(id: string, newDecisionId: string): Promise<void>
  listBySession(sessionId: string): Promise<Decision[]>
  listByEntity(entityId: string): Promise<Decision[]>
}
```

#### Update `CoreService.searchDecisions()`

Change from on-the-fly message scanning to querying the decisions table. Fall back to message scanning for sessions that haven't been processed.

#### Auto-extraction

When a session is summarized (`summarizeSession()`), also run decision extraction and persist results to the decisions table. This makes decisions a byproduct of summarization rather than a separate expensive operation.

### 5d: Message-Entity Linking

When `store_message` is called and the message content mentions entity names (detected via QueryParser's entity mention extraction), create relationships:

```sql
INSERT INTO ${prefix}_relationships (source_id, target_id, relationship)
VALUES (<message_entity_id>, <mentioned_entity_id>, 'MENTIONS');
```

This requires treating messages as lightweight entities (or creating a separate linking table). The simplest approach: when a message mentions entities, store MENTIONS relationships from the session entity to the mentioned entities.

### MCP Tool Changes

`context_query`:
```typescript
include_conversations: z.boolean().optional()
  .describe('Include relevant conversation history in context')
```

`store_message`:
```typescript
// No schema change — embedding happens automatically if configured
// Returns: { messageId, sessionId, embedded: boolean }
```

`search_decisions`:
```typescript
// Now searches persistent decisions table (faster, ranked)
// Falls back to message scan for un-processed sessions
status: z.string().optional().describe('Filter: active, superseded, reversed')
entity: z.string().optional().describe('Find decisions affecting this entity')
```

### CLI Changes

```
ctx-sys context <query> --conversations   # Include conversation history
ctx-sys search-decisions <query> --entity <name>  # Decisions affecting entity
ctx-sys search-decisions <query> --status active   # Filter by status
```

## Success Criteria

- `store_message` with `embed_messages: true` config embeds messages automatically
- `search_decisions "database migration"` returns persistent decisions (fast, ranked)
- `context_query({ query: "why did we choose SQLite", includeConversations: true })` returns relevant conversation snippets
- Decisions extracted during `summarize_session` are persisted to `decisions` table
- `search_decisions({ entity: "DatabaseConnection" })` returns decisions mentioning that entity
- Message FTS search returns ranked results with stemming
