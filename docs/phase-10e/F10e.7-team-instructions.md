# F10e.7 Team Instructions

**Phase**: 10e - Knowledge Bases & Long-Term Context
**Priority**: Medium
**Dependencies**: F10e.4 (KB packaging, so instructions can be distributed)

## Problem

Teams need a way to encode shared knowledge that should always surface in relevant context:

- "Always use error boundaries in React components"
- "Our REST API follows JSON:API specification"
- "Database migrations must be backward-compatible"
- "Use `Result<T, E>` pattern instead of throwing exceptions"

Currently there's no dedicated mechanism for this. You could store instructions as generic entities, but they have no special handling:
- No priority boost in search results
- No scope (global vs. per-file-type vs. per-directory)
- No way to manage them as a collection
- No distinction from auto-indexed code entities

## Design

Instructions are a new entity type (`instruction`) with scoping metadata and priority boosting in the retrieval pipeline.

### Instruction Structure

```typescript
interface Instruction {
  id: string;
  name: string;               // Short label: "Error Boundary Rule"
  content: string;            // Full instruction text
  scope: InstructionScope;    // Where this applies
  priority: 'high' | 'normal' | 'low';  // Retrieval boost
  tags: string[];             // Categorization
  createdBy?: string;         // Author attribution
  active: boolean;            // Can be disabled without deletion
}

interface InstructionScope {
  global?: boolean;           // Applies everywhere
  fileTypes?: string[];       // e.g., [".tsx", ".jsx"]
  directories?: string[];     // e.g., ["src/api/", "src/routes/"]
  entityTypes?: string[];     // e.g., ["class", "function"]
  languages?: string[];       // e.g., ["typescript", "python"]
}
```

### Storage

Instructions are stored as entities with `type: 'instruction'` and scope/priority in metadata. No new table needed â€” the existing entities + metadata system handles it.

```typescript
entityStore.upsert({
  type: 'instruction',
  name: 'Error Boundary Rule',
  qualifiedName: 'instruction::error-boundary-rule',
  content: 'Always wrap React component renders in error boundaries...',
  summary: 'React: Use error boundaries in all components',
  metadata: {
    scope: { fileTypes: ['.tsx', '.jsx'] },
    priority: 'high',
    tags: ['react', 'error-handling'],
    active: true
  }
});
```

### Retrieval Boost

#### File: `src/retrieval/multi-strategy-search.ts` or `src/retrieval/heuristic-reranker.ts`

When assembling results, apply priority-based boosting to instruction entities:

```typescript
if (entity.type === 'instruction') {
  const priority = entity.metadata?.priority || 'normal';
  const boost = priority === 'high' ? 1.5 : priority === 'low' ? 0.5 : 1.0;
  score *= boost;

  // Scope matching: if query context matches instruction scope, boost further
  if (matchesScope(entity.metadata?.scope, queryContext)) {
    score *= 1.3;
  }
}
```

Instructions with `priority: 'high'` and matching scope get up to ~2x boost, ensuring they surface near the top of results when relevant.

### CLI Commands

```
ctx-sys instruction add <name> --content <text> [--scope <scope>] [--priority high|normal|low] [--tags <tags>]
ctx-sys instruction add <name> --file <path>    # Read content from file
ctx-sys instruction list [--scope <filter>] [--tag <tag>]
ctx-sys instruction edit <id> [--content <text>] [--priority <p>] [--active true|false]
ctx-sys instruction remove <id>
```

Examples:

```bash
# Global instruction
ctx-sys instruction add "API Convention" \
  --content "All REST endpoints must return JSON:API format with proper error objects" \
  --priority high --tags api,conventions

# Scoped to React files
ctx-sys instruction add "Error Boundaries" \
  --content "Wrap all component renders in ErrorBoundary. Use the shared ErrorBoundary from src/components/ErrorBoundary.tsx" \
  --scope '{"fileTypes":[".tsx",".jsx"]}' \
  --priority high --tags react,error-handling

# Low-priority suggestion
ctx-sys instruction add "Prefer Named Exports" \
  --content "Use named exports instead of default exports for better refactoring support" \
  --priority low --tags style
```

### MCP Tools

```
instruction_add     - Create a new instruction
instruction_list    - List instructions with optional scope/tag filter
instruction_edit    - Update instruction content, priority, scope, or active status
instruction_remove  - Remove an instruction
```

### Integration with Knowledge Bases

Instructions are regular entities, so they're automatically included in KB packaging (F10e.4). A team can:

1. Create instructions via CLI or MCP
2. Package the project as a `.ctx-kb`
3. Distribute to team members
4. Recipients install and get all instructions

The `manifest.json` in `.ctx-kb` already counts entities by type, so `instruction` count will be visible.

### Integration with context_query

No special flag needed. Instructions surface naturally through entity search because:
- They're stored as entities with content and summary
- They get embedded (semantic search finds them)
- They're in FTS5 (keyword search finds them)
- The reranker applies priority boosts

However, add an option to *only* retrieve instructions:

```
ctx-sys context "error handling" --type instruction
context_query({ query: "error handling", includeTypes: ["instruction"] })
```

## Success Criteria

- `instruction add` creates an entity with type "instruction" and scope metadata
- `instruction list` shows all instructions with scope and priority
- `context_query({ query: "React component" })` naturally surfaces relevant React instructions
- High-priority instructions appear near the top of results when scope matches
- Instructions are included in `.ctx-kb` packages
- `instruction edit --active false` disables an instruction without deleting it
- `instruction list --tag react` filters by tag
