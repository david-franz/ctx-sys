# F6.4 Relevance Feedback

**Phase**: 6 - Smart Retrieval
**Priority**: Low
**Dependencies**: F6.2 Multi-Strategy Search

## Goal

Learn from which context was actually useful to improve future retrievals.

## Overview

Track signals about context usefulness:
- **Explicit**: User marks something as helpful/not helpful
- **Implicit**: Context that appears in subsequent code/responses

Use this feedback to adjust future search rankings.

## Data Model

```typescript
interface FeedbackSignal {
  id: string;
  queryId: string;            // The search that returned this
  entityId: string;           // The entity that was returned
  signal: FeedbackType;
  timestamp: Date;
}

type FeedbackType =
  | 'used'                    // Entity content appeared in response
  | 'ignored'                 // Entity was returned but not used
  | 'explicit_positive'       // User marked as helpful
  | 'explicit_negative';      // User marked as not helpful

interface FeedbackStats {
  entityId: string;
  totalReturns: number;
  usedCount: number;
  ignoredCount: number;
  positiveCount: number;
  negativeCount: number;
  useRate: number;            // usedCount / totalReturns
}
```

## Implementation

### File: `src/retrieval/feedback.ts`

```typescript
import { DatabaseConnection } from '../db/connection';
import { generateId } from '../utils/id';

export class RelevanceFeedback {
  private tableName: string;

  constructor(
    private db: DatabaseConnection,
    private projectId: string
  ) {
    this.tableName = `${projectId}_feedback`;
    this.ensureTable();
  }

  private ensureTable(): void {
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS ${this.tableName} (
        id TEXT PRIMARY KEY,
        query_id TEXT NOT NULL,
        entity_id TEXT NOT NULL,
        signal TEXT NOT NULL,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
      );
      CREATE INDEX IF NOT EXISTS idx_${this.tableName}_entity
        ON ${this.tableName}(entity_id);
    `);
  }

  async record(signal: Omit<FeedbackSignal, 'id' | 'timestamp'>): Promise<void> {
    const id = generateId();

    this.db.run(
      `INSERT INTO ${this.tableName} (id, query_id, entity_id, signal)
       VALUES (?, ?, ?, ?)`,
      [id, signal.queryId, signal.entityId, signal.signal]
    );
  }

  async recordBatch(
    queryId: string,
    signals: Array<{ entityId: string; signal: FeedbackType }>
  ): Promise<void> {
    this.db.transaction(() => {
      for (const signal of signals) {
        this.db.run(
          `INSERT INTO ${this.tableName} (id, query_id, entity_id, signal)
           VALUES (?, ?, ?, ?)`,
          [generateId(), queryId, signal.entityId, signal.signal]
        );
      }
    });
  }

  async getStats(entityId: string): Promise<FeedbackStats> {
    const stats = this.db.get<{
      total: number;
      used: number;
      ignored: number;
      positive: number;
      negative: number;
    }>(`
      SELECT
        COUNT(*) as total,
        SUM(CASE WHEN signal = 'used' THEN 1 ELSE 0 END) as used,
        SUM(CASE WHEN signal = 'ignored' THEN 1 ELSE 0 END) as ignored,
        SUM(CASE WHEN signal = 'explicit_positive' THEN 1 ELSE 0 END) as positive,
        SUM(CASE WHEN signal = 'explicit_negative' THEN 1 ELSE 0 END) as negative
      FROM ${this.tableName}
      WHERE entity_id = ?
    `, [entityId]);

    const total = stats?.total || 0;
    const used = stats?.used || 0;

    return {
      entityId,
      totalReturns: total,
      usedCount: used,
      ignoredCount: stats?.ignored || 0,
      positiveCount: stats?.positive || 0,
      negativeCount: stats?.negative || 0,
      useRate: total > 0 ? used / total : 0.5
    };
  }

  async adjustScores(
    results: Array<{ entityId: string; score: number }>
  ): Promise<Array<{ entityId: string; score: number }>> {
    const adjusted = [];

    for (const result of results) {
      const stats = await this.getStats(result.entityId);

      // Adjust score based on historical usefulness
      // - High use rate boosts score
      // - Negative feedback reduces score
      let multiplier = 1.0;

      if (stats.totalReturns >= 5) {
        // Only adjust if we have enough data
        multiplier = 0.5 + stats.useRate; // Range: 0.5 - 1.5

        // Explicit feedback has stronger effect
        if (stats.positiveCount > 0) {
          multiplier += 0.1 * Math.min(stats.positiveCount, 3);
        }
        if (stats.negativeCount > 0) {
          multiplier -= 0.15 * Math.min(stats.negativeCount, 3);
        }

        // Clamp multiplier
        multiplier = Math.max(0.3, Math.min(1.7, multiplier));
      }

      adjusted.push({
        entityId: result.entityId,
        score: result.score * multiplier
      });
    }

    // Re-sort by adjusted score
    adjusted.sort((a, b) => b.score - a.score);

    return adjusted;
  }

  async detectUsage(
    queryId: string,
    returnedEntityIds: string[],
    responseContent: string
  ): Promise<void> {
    const signals: Array<{ entityId: string; signal: FeedbackType }> = [];

    for (const entityId of returnedEntityIds) {
      // Simple heuristic: check if entity name/content appears in response
      // This is a basic implementation; could be more sophisticated
      const isUsed = await this.checkIfUsed(entityId, responseContent);

      signals.push({
        entityId,
        signal: isUsed ? 'used' : 'ignored'
      });
    }

    await this.recordBatch(queryId, signals);
  }

  private async checkIfUsed(
    entityId: string,
    content: string
  ): Promise<boolean> {
    // Would need entity store to get entity details
    // For now, return true (assume used)
    return true;
  }
}
```

## Tasks

- [ ] Implement RelevanceFeedback
- [ ] Implement feedback recording
- [ ] Implement score adjustment
- [ ] Implement usage detection
- [ ] Add explicit feedback tools
- [ ] Write unit tests

## Testing

```typescript
describe('RelevanceFeedback', () => {
  it('should record feedback signals');
  it('should compute feedback stats');
  it('should adjust scores based on history');
  it('should detect implicit usage');
});
```
