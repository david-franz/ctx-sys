# F6.6 Retrieval Gating

**Phase**: 6 - Advanced Retrieval
**Priority**: High
**Dependencies**: F6.1 Query Parsing, F7.2 Model Abstraction

## Goal

Implement a gating mechanism to determine whether a query requires context retrieval before performing expensive search operations.

## Overview

Not every question needs external information:
- "What's 2+2?" → No retrieval needed
- "What's our authentication flow?" → Retrieval needed

Blindly retrieving for every query:
- Wastes compute (unnecessary vector searches)
- Adds latency (~100-500ms per retrieval)
- Increases costs (embedding API calls, database queries)
- Can introduce noise (irrelevant context hurts response quality)

The retrieval gate acts as a smart filter that decides: **"Should I retrieve, or can I answer directly?"**

## Data Model

```typescript
interface GateDecision {
  shouldRetrieve: boolean;
  confidence: number;          // 0-1, how confident the gate is
  reason: string;              // Explanation for debugging
  suggestedStrategy?: string;  // If retrieving, which strategy to prioritize
  estimatedRelevance?: number; // Expected relevance of retrieval results
}

interface GateContext {
  query: string;
  conversationHistory?: string;  // Recent turns for context
  availableEntityTypes?: string[]; // What's indexed
  projectDescription?: string;     // Project context
}

interface GateConfig {
  enabled: boolean;
  confidenceThreshold: number;    // Below this, retrieve anyway
  maxInputTokens: number;         // Limit context sent to gate
  cacheDecisions: boolean;
  cacheTTLSeconds: number;
}
```

## Implementation

### File: `src/retrieval/gate.ts`

```typescript
import { ModelProvider } from '../models/provider';
import { QueryParser, ParsedQuery } from './query-parser';

export class RetrievalGate {
  private modelProvider: ModelProvider;
  private queryParser: QueryParser;
  private cache: Map<string, { decision: GateDecision; expires: number }> = new Map();

  constructor(
    modelProvider: ModelProvider,
    queryParser: QueryParser,
    private config: GateConfig = defaultGateConfig
  ) {
    this.modelProvider = modelProvider;
    this.queryParser = queryParser;
  }

  /**
   * Determine if retrieval is needed for this query
   */
  async shouldRetrieve(context: GateContext): Promise<GateDecision> {
    if (!this.config.enabled) {
      return { shouldRetrieve: true, confidence: 1, reason: 'Gate disabled' };
    }

    // Check cache first
    const cached = this.getCached(context.query);
    if (cached) return cached;

    // Fast path: pattern-based decisions
    const fastDecision = this.fastPathDecision(context.query);
    if (fastDecision) {
      this.cacheDecision(context.query, fastDecision);
      return fastDecision;
    }

    // Slow path: model-based decision
    const modelDecision = await this.modelBasedDecision(context);
    this.cacheDecision(context.query, modelDecision);
    return modelDecision;
  }

  /**
   * Fast pattern-based decisions (no model call needed)
   */
  private fastPathDecision(query: string): GateDecision | null {
    const parsed = this.queryParser.parse(query);
    
    // Always retrieve for code-specific queries
    if (parsed.entityMentions.length > 0) {
      return {
        shouldRetrieve: true,
        confidence: 0.95,
        reason: 'Query mentions specific code entities',
        suggestedStrategy: 'entity_lookup'
      };
    }

    // Always retrieve for project-specific intents
    const projectIntents = ['find', 'explain', 'list', 'debug'];
    if (projectIntents.includes(parsed.intent)) {
      return {
        shouldRetrieve: true,
        confidence: 0.9,
        reason: `Intent '${parsed.intent}' typically requires project context`,
        suggestedStrategy: parsed.intent === 'debug' ? 'graph_traverse' : 'vector_search'
      };
    }

    // Never retrieve for basic questions
    const basicPatterns = [
      /^what('s| is) \d+\s*[\+\-\*\/]\s*\d+/i,  // Math
      /^(hi|hello|hey|thanks|thank you)/i,       // Greetings
      /^(yes|no|okay|ok|sure)$/i,                // Confirmations
    ];
    
    for (const pattern of basicPatterns) {
      if (pattern.test(query)) {
        return {
          shouldRetrieve: false,
          confidence: 0.99,
          reason: 'Basic query pattern detected'
        };
      }
    }

    return null; // Need model decision
  }

  /**
   * Model-based gating decision
   */
  private async modelBasedDecision(context: GateContext): Promise<GateDecision> {
    const prompt = this.buildGatePrompt(context);
    
    const response = await this.modelProvider.complete({
      prompt,
      maxTokens: 100,
      temperature: 0.1  // Very low for consistent decisions
    });

    return this.parseGateResponse(response.text);
  }

  private buildGatePrompt(context: GateContext): string {
    const projectContext = context.projectDescription
      ? `Project: ${context.projectDescription}\n`
      : '';
    
    const entityContext = context.availableEntityTypes?.length
      ? `Available context types: ${context.availableEntityTypes.join(', ')}\n`
      : '';

    return `You are a retrieval gate. Decide if answering this query requires searching the codebase/documentation.

${projectContext}${entityContext}
Query: "${context.query}"

Respond in JSON format:
{
  "shouldRetrieve": true/false,
  "confidence": 0.0-1.0,
  "reason": "brief explanation",
  "suggestedStrategy": "vector_search" | "graph_traverse" | "entity_lookup" | null
}

Guidelines:
- shouldRetrieve=true for: code questions, project-specific info, debugging, finding files
- shouldRetrieve=false for: general knowledge, math, greetings, opinions, common programming concepts
- High confidence (>0.9) when clearly one or the other
- Lower confidence when ambiguous

JSON response:`;
  }

  private parseGateResponse(response: string): GateDecision {
    try {
      // Extract JSON from response
      const jsonMatch = response.match(/\{[\s\S]*\}/);
      if (!jsonMatch) throw new Error('No JSON found');
      
      const parsed = JSON.parse(jsonMatch[0]);
      
      return {
        shouldRetrieve: Boolean(parsed.shouldRetrieve),
        confidence: Math.max(0, Math.min(1, Number(parsed.confidence) || 0.5)),
        reason: String(parsed.reason || 'Model decision'),
        suggestedStrategy: parsed.suggestedStrategy || undefined
      };
    } catch (error) {
      // Default to retrieving on parse failure
      return {
        shouldRetrieve: true,
        confidence: 0.5,
        reason: 'Failed to parse gate response, defaulting to retrieve'
      };
    }
  }

  private getCached(query: string): GateDecision | null {
    if (!this.config.cacheDecisions) return null;
    
    const cached = this.cache.get(query);
    if (cached && cached.expires > Date.now()) {
      return cached.decision;
    }
    
    this.cache.delete(query);
    return null;
  }

  private cacheDecision(query: string, decision: GateDecision): void {
    if (!this.config.cacheDecisions) return;
    
    this.cache.set(query, {
      decision,
      expires: Date.now() + (this.config.cacheTTLSeconds * 1000)
    });
  }

  clearCache(): void {
    this.cache.clear();
  }
}

const defaultGateConfig: GateConfig = {
  enabled: true,
  confidenceThreshold: 0.7,
  maxInputTokens: 500,
  cacheDecisions: true,
  cacheTTLSeconds: 300  // 5 minutes
};
```

### Integration with Search Pipeline

```typescript
// In src/retrieval/search.ts

export class ContextRetriever {
  private gate: RetrievalGate;
  private search: MultiStrategySearch;

  async query(
    query: string, 
    options: QueryOptions
  ): Promise<QueryResult> {
    // Step 1: Gate decision
    const gateDecision = await this.gate.shouldRetrieve({
      query,
      conversationHistory: options.recentContext,
      availableEntityTypes: options.entityTypes,
      projectDescription: options.projectDescription
    });

    // Step 2: Act on decision
    if (!gateDecision.shouldRetrieve) {
      return {
        context: null,
        gateDecision,
        searchResults: null,
        message: 'No retrieval needed'
      };
    }

    // Step 3: Retrieve with suggested strategy
    const searchResults = await this.search.search(query, {
      ...options,
      preferredStrategy: gateDecision.suggestedStrategy
    });

    return {
      context: this.assembleContext(searchResults),
      gateDecision,
      searchResults
    };
  }
}
```

## MCP Tool

```typescript
{
  name: 'should_retrieve',
  description: 'Check if a query needs context retrieval before searching',
  inputSchema: {
    type: 'object',
    properties: {
      query: { type: 'string', description: 'The query to evaluate' },
      projectId: { type: 'string' },
      conversationHistory: { type: 'string', description: 'Recent conversation for context' }
    },
    required: ['query', 'projectId']
  }
}
```

## Examples

### Example 1: No Retrieval Needed

**Query**: "What's the difference between let and const in JavaScript?"

**Decision**:
```json
{
  "shouldRetrieve": false,
  "confidence": 0.95,
  "reason": "General JavaScript knowledge, not project-specific"
}
```

### Example 2: Retrieval Needed

**Query**: "How does our AuthService handle token refresh?"

**Decision**:
```json
{
  "shouldRetrieve": true,
  "confidence": 0.98,
  "reason": "Query asks about specific project service (AuthService)",
  "suggestedStrategy": "entity_lookup"
}
```

### Example 3: Ambiguous (Low Confidence)

**Query**: "Best practices for error handling"

**Decision**:
```json
{
  "shouldRetrieve": true,
  "confidence": 0.6,
  "reason": "Could be general or project-specific, retrieving to check for project conventions"
}
```

## Configuration

```yaml
# ctx-sys.yaml
retrieval:
  gate:
    enabled: true
    confidenceThreshold: 0.7
    maxInputTokens: 500
    cacheDecisions: true
    cacheTTLSeconds: 300
    # Patterns that always skip retrieval
    skipPatterns:
      - '^(hi|hello|hey|thanks)'
      - '^\d+\s*[\+\-\*\/]'
    # Patterns that always retrieve
    retrievePatterns:
      - '`[^`]+`'           # Backtick code mentions
      - '\.(ts|js|py|go)$'  # File extensions
```

## Testing

```typescript
describe('RetrievalGate', () => {
  it('should skip retrieval for basic math', async () => {
    const decision = await gate.shouldRetrieve({ query: "What's 2+2?" });
    expect(decision.shouldRetrieve).toBe(false);
    expect(decision.confidence).toBeGreaterThan(0.9);
  });

  it('should retrieve for code entity mentions', async () => {
    const decision = await gate.shouldRetrieve({ 
      query: 'How does `UserService` handle validation?' 
    });
    expect(decision.shouldRetrieve).toBe(true);
    expect(decision.suggestedStrategy).toBe('entity_lookup');
  });

  it('should cache decisions', async () => {
    await gate.shouldRetrieve({ query: 'test query' });
    await gate.shouldRetrieve({ query: 'test query' });
    
    expect(mockModel.complete).toHaveBeenCalledTimes(1);
  });

  it('should handle model failures gracefully', async () => {
    mockModel.complete.mockRejectedValue(new Error('Model error'));
    
    const decision = await gate.shouldRetrieve({ query: 'ambiguous query' });
    expect(decision.shouldRetrieve).toBe(true); // Default to retrieve
    expect(decision.confidence).toBeLessThan(0.7);
  });
});
```

## Performance Considerations

- **Fast path**: Pattern matching avoids model call for ~40% of queries
- **Caching**: Same query within TTL returns instantly
- **Low latency model**: Use fast model (gpt-4o-mini, qwen2.5) for gating
- **Parallel execution**: Gate decision can run in parallel with other prep work

## Metrics to Track

| Metric | Description |
|--------|-------------|
| `gate_skip_rate` | % of queries that skip retrieval |
| `gate_fast_path_rate` | % handled by pattern matching |
| `gate_latency_ms` | Time for gate decision |
| `gate_accuracy` | Compare decision vs actual usefulness |
| `tokens_saved` | Estimated tokens not retrieved |
