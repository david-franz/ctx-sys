# F6.3 Context Assembly

**Phase**: 6 - Smart Retrieval
**Priority**: Critical
**Dependencies**: F6.2 Multi-Strategy Search

## Goal

Format search results into LLM-ready context with source attribution and token management.

## Overview

After retrieving relevant entities, we need to:
- Format them for LLM consumption
- Respect token budgets
- Include source attribution
- Prioritize by relevance

## Data Model

```typescript
interface AssembledContext {
  context: string;              // Formatted context for LLM
  sources: ContextSource[];     // Attribution
  tokenCount: number;
  truncated: boolean;
  summary?: string;             // If content was summarized to fit
}

interface ContextSource {
  entityId: string;
  name: string;
  type: string;
  file?: string;
  line?: number;
  relevance: number;
}

interface AssemblyOptions {
  maxTokens: number;
  format: 'markdown' | 'xml' | 'plain';
  includeSources: boolean;
  includeCodeContent: boolean;
  groupByType: boolean;
}
```

## Implementation

### File: `src/retrieval/context-assembler.ts`

```typescript
import { SearchResult } from './search';
import { Entity } from '../entities/store';

// Simple token estimation (4 chars â‰ˆ 1 token)
function estimateTokens(text: string): number {
  return Math.ceil(text.length / 4);
}

export class ContextAssembler {
  async assemble(
    results: SearchResult[],
    options: AssemblyOptions
  ): Promise<AssembledContext> {
    const context: AssembledContext = {
      context: '',
      sources: [],
      tokenCount: 0,
      truncated: false
    };

    // Sort by relevance
    const sorted = [...results].sort((a, b) => b.score - a.score);

    // Group by type if requested
    const grouped = options.groupByType
      ? this.groupByType(sorted)
      : { all: sorted };

    // Build context
    const sections: string[] = [];

    for (const [group, groupResults] of Object.entries(grouped)) {
      const sectionLines: string[] = [];

      if (options.groupByType && group !== 'all') {
        sectionLines.push(this.formatGroupHeader(group, options.format));
      }

      for (const result of groupResults) {
        const formatted = this.formatEntity(result.entity, options);
        const tokens = estimateTokens(formatted);

        // Check if we'd exceed budget
        if (context.tokenCount + tokens > options.maxTokens) {
          context.truncated = true;
          break;
        }

        sectionLines.push(formatted);
        context.tokenCount += tokens;

        // Track source
        context.sources.push({
          entityId: result.entityId,
          name: result.entity.name,
          type: result.entity.type,
          file: result.entity.filePath,
          line: result.entity.startLine,
          relevance: result.score
        });
      }

      if (sectionLines.length > 0) {
        sections.push(sectionLines.join('\n\n'));
      }

      if (context.truncated) break;
    }

    context.context = sections.join('\n\n---\n\n');

    // Add sources footer if requested
    if (options.includeSources) {
      const sourcesFooter = this.formatSources(context.sources, options.format);
      const footerTokens = estimateTokens(sourcesFooter);

      if (context.tokenCount + footerTokens <= options.maxTokens) {
        context.context += '\n\n' + sourcesFooter;
        context.tokenCount += footerTokens;
      }
    }

    return context;
  }

  private groupByType(
    results: SearchResult[]
  ): Record<string, SearchResult[]> {
    const groups: Record<string, SearchResult[]> = {};

    for (const result of results) {
      const type = this.categorizeType(result.entity.type);
      if (!groups[type]) {
        groups[type] = [];
      }
      groups[type].push(result);
    }

    // Order: code first, then docs, then other
    const ordered: Record<string, SearchResult[]> = {};
    const order = ['code', 'documentation', 'conversation', 'other'];

    for (const category of order) {
      if (groups[category]) {
        ordered[category] = groups[category];
      }
    }

    return ordered;
  }

  private categorizeType(type: string): string {
    const codeTypes = ['function', 'method', 'class', 'interface', 'type', 'file', 'module'];
    const docTypes = ['document', 'section', 'requirement', 'feature'];
    const convTypes = ['session', 'message', 'decision'];

    if (codeTypes.includes(type)) return 'code';
    if (docTypes.includes(type)) return 'documentation';
    if (convTypes.includes(type)) return 'conversation';
    return 'other';
  }

  private formatGroupHeader(group: string, format: string): string {
    const titles: Record<string, string> = {
      code: 'Relevant Code',
      documentation: 'Related Documentation',
      conversation: 'Previous Conversations',
      other: 'Other Context'
    };

    const title = titles[group] || group;

    switch (format) {
      case 'xml':
        return `<section name="${title}">`;
      case 'markdown':
        return `## ${title}`;
      default:
        return `=== ${title} ===`;
    }
  }

  private formatEntity(entity: Entity, options: AssemblyOptions): string {
    switch (options.format) {
      case 'xml':
        return this.formatEntityXml(entity, options);
      case 'markdown':
        return this.formatEntityMarkdown(entity, options);
      default:
        return this.formatEntityPlain(entity, options);
    }
  }

  private formatEntityMarkdown(entity: Entity, options: AssemblyOptions): string {
    const lines: string[] = [];

    // Header with location
    const location = entity.filePath
      ? `${entity.filePath}${entity.startLine ? `:${entity.startLine}` : ''}`
      : entity.type;

    lines.push(`### ${entity.name}`);
    lines.push(`*${location}*`);
    lines.push('');

    // Summary or content
    if (entity.summary) {
      lines.push(entity.summary);
    }

    // Code content if requested
    if (options.includeCodeContent && entity.content) {
      const language = this.detectLanguage(entity.filePath);
      lines.push('');
      lines.push('```' + (language || ''));
      lines.push(entity.content.slice(0, 500)); // Limit content
      if (entity.content.length > 500) {
        lines.push('// ... (truncated)');
      }
      lines.push('```');
    }

    return lines.join('\n');
  }

  private formatEntityXml(entity: Entity, options: AssemblyOptions): string {
    const attrs = [
      `type="${entity.type}"`,
      entity.filePath ? `file="${entity.filePath}"` : null,
      entity.startLine ? `line="${entity.startLine}"` : null
    ].filter(Boolean).join(' ');

    const content = entity.summary || entity.content || '';

    return `<entity name="${entity.name}" ${attrs}>
${content.slice(0, 500)}
</entity>`;
  }

  private formatEntityPlain(entity: Entity, options: AssemblyOptions): string {
    const location = entity.filePath
      ? `[${entity.filePath}:${entity.startLine || 0}]`
      : `[${entity.type}]`;

    return `${entity.name} ${location}\n${entity.summary || entity.content || ''}`;
  }

  private formatSources(
    sources: ContextSource[],
    format: string
  ): string {
    if (sources.length === 0) return '';

    const lines: string[] = [];

    switch (format) {
      case 'markdown':
        lines.push('---');
        lines.push('**Sources:**');
        for (const source of sources.slice(0, 10)) {
          const loc = source.file
            ? `${source.file}${source.line ? `:${source.line}` : ''}`
            : source.type;
          lines.push(`- ${source.name} (${loc})`);
        }
        break;

      case 'xml':
        lines.push('<sources>');
        for (const source of sources.slice(0, 10)) {
          lines.push(`  <source name="${source.name}" type="${source.type}" />`);
        }
        lines.push('</sources>');
        break;

      default:
        lines.push('Sources:');
        for (const source of sources.slice(0, 10)) {
          lines.push(`  - ${source.name}`);
        }
    }

    return lines.join('\n');
  }

  private detectLanguage(filePath?: string): string | null {
    if (!filePath) return null;

    const ext = filePath.split('.').pop()?.toLowerCase();
    const map: Record<string, string> = {
      ts: 'typescript',
      tsx: 'typescript',
      js: 'javascript',
      jsx: 'javascript',
      py: 'python',
      go: 'go',
      rs: 'rust',
      java: 'java'
    };

    return map[ext || ''] || null;
  }
}
```

## Tasks

- [ ] Implement ContextAssembler
- [ ] Implement token estimation
- [ ] Implement markdown formatting
- [ ] Implement XML formatting
- [ ] Implement type grouping
- [ ] Add source attribution
- [ ] Write unit tests

## Testing

```typescript
describe('ContextAssembler', () => {
  it('should assemble context from search results');
  it('should respect token budget');
  it('should format as markdown');
  it('should format as XML');
  it('should group by type');
  it('should include sources');
});
```
