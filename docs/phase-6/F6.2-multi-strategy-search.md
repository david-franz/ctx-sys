# F6.2 Multi-Strategy Search

**Phase**: 6 - Smart Retrieval
**Priority**: Critical
**Dependencies**: F6.1 Query Parsing, F1.4 Embedding Pipeline, F5.1 Graph Storage

## Goal

Combine vector, graph, and FTS search for comprehensive context retrieval.

## Overview

Each search strategy has strengths:
- **Vector**: Semantic similarity, finds conceptually related content
- **Graph**: Relationships, finds connected entities
- **FTS**: Exact matches, finds keyword occurrences

Combining them with Reciprocal Rank Fusion provides better results than any single strategy.

## Data Model

```typescript
interface SearchResult {
  entityId: string;
  entity: Entity;
  score: number;                   // Final fused score
  source: 'vector' | 'graph' | 'fts';
  rank: number;                    // Rank within source
  highlights?: string[];           // Matching snippets
}

interface SearchOptions {
  strategies: ('vector' | 'graph' | 'fts')[];
  limit: number;
  weights?: {
    vector?: number;
    graph?: number;
    fts?: number;
  };
  filters?: {
    types?: string[];
    files?: string[];
  };
}
```

## Implementation

### File: `src/retrieval/search.ts`

```typescript
import { ParsedQuery, QueryParser } from './query-parser';
import { EmbeddingManager } from '../embeddings/manager';
import { RelationshipStore } from '../relationships/store';
import { EntityStore, Entity } from '../entities/store';

interface RawResult {
  entityId: string;
  score: number;
  source: 'vector' | 'graph' | 'fts';
}

export class MultiStrategySearch {
  constructor(
    private queryParser: QueryParser,
    private embeddingManager: EmbeddingManager,
    private relationshipStore: RelationshipStore,
    private entityStore: EntityStore
  ) {}

  async search(
    query: string,
    options: SearchOptions
  ): Promise<SearchResult[]> {
    const parsed = this.queryParser.parse(query);
    const rawResults: RawResult[] = [];

    // Vector search
    if (options.strategies.includes('vector')) {
      const vectorResults = await this.vectorSearch(parsed, options);
      rawResults.push(...vectorResults);
    }

    // Graph search (from entity mentions)
    if (options.strategies.includes('graph')) {
      const graphResults = await this.graphSearch(parsed, options);
      rawResults.push(...graphResults);
    }

    // FTS search
    if (options.strategies.includes('fts')) {
      const ftsResults = await this.ftsSearch(parsed, options);
      rawResults.push(...ftsResults);
    }

    // Fuse results using RRF
    const fused = this.reciprocalRankFusion(rawResults, options.weights);

    // Deduplicate and limit
    const deduplicated = this.deduplicate(fused);
    const limited = deduplicated.slice(0, options.limit);

    // Hydrate with full entities
    return this.hydrateResults(limited);
  }

  private async vectorSearch(
    parsed: ParsedQuery,
    options: SearchOptions
  ): Promise<RawResult[]> {
    const results: RawResult[] = [];

    // Search with original query
    const mainResults = await this.embeddingManager.findSimilar(
      parsed.originalQuery,
      {
        limit: options.limit * 2,
        entityTypes: options.filters?.types
      }
    );

    for (let i = 0; i < mainResults.length; i++) {
      results.push({
        entityId: mainResults[i].entityId,
        score: mainResults[i].score,
        source: 'vector'
      });
    }

    // Also search with expanded queries
    for (const expanded of parsed.expandedQueries) {
      const expandedResults = await this.embeddingManager.findSimilar(
        expanded,
        {
          limit: Math.floor(options.limit / 2),
          entityTypes: options.filters?.types
        }
      );

      for (let i = 0; i < expandedResults.length; i++) {
        results.push({
          entityId: expandedResults[i].entityId,
          score: expandedResults[i].score * 0.8, // Slightly lower weight
          source: 'vector'
        });
      }
    }

    return results;
  }

  private async graphSearch(
    parsed: ParsedQuery,
    options: SearchOptions
  ): Promise<RawResult[]> {
    const results: RawResult[] = [];

    // Start from mentioned entities
    for (const mention of parsed.entityMentions) {
      const entity = await this.resolveEntityMention(mention);
      if (!entity) continue;

      // Get neighbors
      const traversal = await this.relationshipStore.traverse(
        entity.id,
        2, // 2-hop neighbors
        { direction: 'both' }
      );

      // Score by distance (closer = higher)
      for (const rel of traversal.relationships) {
        const targetId = rel.sourceId === entity.id ? rel.targetId : rel.sourceId;
        const distanceScore = 1 / (rel.depth + 1);

        results.push({
          entityId: targetId,
          score: distanceScore * mention.confidence,
          source: 'graph'
        });
      }
    }

    return results;
  }

  private async ftsSearch(
    parsed: ParsedQuery,
    options: SearchOptions
  ): Promise<RawResult[]> {
    const results: RawResult[] = [];

    // Search with keywords
    const searchTerms = parsed.keywords.join(' OR ');
    const ftsResults = await this.entityStore.search(searchTerms, {
      type: options.filters?.types?.[0] as any,
      limit: options.limit * 2
    });

    for (let i = 0; i < ftsResults.length; i++) {
      // FTS doesn't give scores, use rank-based scoring
      results.push({
        entityId: ftsResults[i].id,
        score: 1 / (i + 1),
        source: 'fts'
      });
    }

    // Also search for exact entity mentions
    for (const mention of parsed.entityMentions) {
      const exactMatches = await this.entityStore.search(mention.text, {
        limit: 5
      });

      for (const match of exactMatches) {
        results.push({
          entityId: match.id,
          score: mention.confidence,
          source: 'fts'
        });
      }
    }

    return results;
  }

  private reciprocalRankFusion(
    results: RawResult[],
    weights?: { vector?: number; graph?: number; fts?: number }
  ): RawResult[] {
    const k = 60; // RRF constant
    const defaultWeights = { vector: 1.0, graph: 0.8, fts: 0.6 };
    const w = { ...defaultWeights, ...weights };

    // Group by source and rank
    const bySource = new Map<string, RawResult[]>();
    for (const r of results) {
      const key = r.source;
      if (!bySource.has(key)) {
        bySource.set(key, []);
      }
      bySource.get(key)!.push(r);
    }

    // Sort each source by score
    for (const [source, sourceResults] of bySource) {
      sourceResults.sort((a, b) => b.score - a.score);
    }

    // Calculate RRF scores
    const fusedScores = new Map<string, number>();

    for (const [source, sourceResults] of bySource) {
      const weight = w[source as keyof typeof w] || 1.0;

      for (let rank = 0; rank < sourceResults.length; rank++) {
        const result = sourceResults[rank];
        const rrfScore = weight / (k + rank + 1);

        const currentScore = fusedScores.get(result.entityId) || 0;
        fusedScores.set(result.entityId, currentScore + rrfScore);
      }
    }

    // Convert to results array
    const fused: RawResult[] = [];
    for (const [entityId, score] of fusedScores) {
      const original = results.find(r => r.entityId === entityId);
      fused.push({
        entityId,
        score,
        source: original?.source || 'vector'
      });
    }

    // Sort by fused score
    fused.sort((a, b) => b.score - a.score);

    return fused;
  }

  private deduplicate(results: RawResult[]): RawResult[] {
    const seen = new Set<string>();
    return results.filter(r => {
      if (seen.has(r.entityId)) return false;
      seen.add(r.entityId);
      return true;
    });
  }

  private async hydrateResults(results: RawResult[]): Promise<SearchResult[]> {
    const hydrated: SearchResult[] = [];

    for (let i = 0; i < results.length; i++) {
      const entity = await this.entityStore.get(results[i].entityId);
      if (entity) {
        hydrated.push({
          entityId: results[i].entityId,
          entity,
          score: results[i].score,
          source: results[i].source,
          rank: i + 1
        });
      }
    }

    return hydrated;
  }

  private async resolveEntityMention(
    mention: { text: string; type?: string }
  ): Promise<Entity | null> {
    // Try exact name match
    let entity = await this.entityStore.getByName(mention.text, mention.type as any);
    if (entity) return entity;

    // Try qualified name
    entity = await this.entityStore.getByQualifiedName(mention.text);
    if (entity) return entity;

    // Try search
    const results = await this.entityStore.search(mention.text, { limit: 1 });
    return results[0] || null;
  }
}
```

## Tasks

- [ ] Implement MultiStrategySearch
- [ ] Implement vector search with expansions
- [ ] Implement graph search from mentions
- [ ] Implement FTS search
- [ ] Implement Reciprocal Rank Fusion
- [ ] Implement result deduplication
- [ ] Write unit tests
- [ ] Tune weights for best results

## Testing

```typescript
describe('MultiStrategySearch', () => {
  it('should search using vector strategy');
  it('should search using graph strategy');
  it('should search using FTS strategy');
  it('should fuse results with RRF');
  it('should deduplicate results');
  it('should respect limits');
});
```
