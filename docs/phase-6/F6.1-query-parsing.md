# F6.1 Query Parsing

**Phase**: 6 - Smart Retrieval
**Priority**: High
**Dependencies**: F1.3 Entity Storage

## Goal

Extract intent, entities, and keywords from natural language queries for smart retrieval.

## Overview

When a user queries `#prompt 'how does authentication work?'`, we need to:
- Understand the **intent** (explanation, finding, listing)
- Extract **keywords** (authentication)
- Identify **entity mentions** (if any specific code is mentioned)
- Generate **expanded queries** for better recall

## Data Model

```typescript
interface ParsedQuery {
  originalQuery: string;
  intent: QueryIntent;
  keywords: string[];
  entityMentions: EntityMention[];
  filters: QueryFilters;
  expandedQueries: string[];
}

type QueryIntent =
  | 'find'      // Find specific code/file
  | 'explain'   // Explain how something works
  | 'list'      // List all X
  | 'compare'   // Compare X and Y
  | 'how'       // How to do something
  | 'why'       // Why is X done this way
  | 'debug'     // Help with an error
  | 'general';  // General question

interface EntityMention {
  text: string;
  type?: string;           // 'file', 'function', 'class', etc.
  confidence: number;
}

interface QueryFilters {
  types?: string[];        // Filter by entity type
  files?: string[];        // Filter by file path
  since?: Date;            // Filter by date
  language?: string;       // Filter by language
}
```

## Implementation

### File: `src/retrieval/query-parser.ts`

```typescript
export class QueryParser {
  // Intent detection patterns
  private intentPatterns: Array<{ pattern: RegExp; intent: QueryIntent }> = [
    { pattern: /^(find|search|locate|where is)\b/i, intent: 'find' },
    { pattern: /^(explain|what is|describe|tell me about)\b/i, intent: 'explain' },
    { pattern: /^(list|show|get all)\b/i, intent: 'list' },
    { pattern: /^(compare|difference|vs|versus)\b/i, intent: 'compare' },
    { pattern: /^(how (do|to|can|does))\b/i, intent: 'how' },
    { pattern: /^(why|reason)\b/i, intent: 'why' },
    { pattern: /(error|bug|fix|debug|issue|problem)/i, intent: 'debug' }
  ];

  // Entity mention patterns
  private entityPatterns = {
    file: /\b([\w/-]+\.(ts|js|py|go|rs|java))\b/g,
    backtick: /`([^`]+)`/g,
    className: /\b([A-Z][a-zA-Z0-9]+(?:Service|Controller|Manager|Handler))\b/g,
    functionCall: /\b([a-z][a-zA-Z0-9]*)\(\)/g
  };

  // Stop words to filter from keywords
  private stopWords = new Set([
    'the', 'a', 'an', 'is', 'are', 'was', 'were', 'be', 'been',
    'being', 'have', 'has', 'had', 'do', 'does', 'did', 'will',
    'would', 'could', 'should', 'may', 'might', 'must', 'shall',
    'can', 'need', 'dare', 'ought', 'used', 'to', 'of', 'in',
    'for', 'on', 'with', 'at', 'by', 'from', 'as', 'into', 'through',
    'during', 'before', 'after', 'above', 'below', 'between',
    'under', 'again', 'further', 'then', 'once', 'here', 'there',
    'when', 'where', 'why', 'how', 'all', 'each', 'few', 'more',
    'most', 'other', 'some', 'such', 'no', 'nor', 'not', 'only',
    'own', 'same', 'so', 'than', 'too', 'very', 'just', 'and',
    'but', 'if', 'or', 'because', 'until', 'while', 'this', 'that',
    'these', 'those', 'i', 'me', 'my', 'we', 'our', 'you', 'your',
    'it', 'its', 'what', 'which', 'who', 'whom'
  ]);

  parse(query: string): ParsedQuery {
    const originalQuery = query.trim();

    return {
      originalQuery,
      intent: this.detectIntent(originalQuery),
      keywords: this.extractKeywords(originalQuery),
      entityMentions: this.extractEntityMentions(originalQuery),
      filters: this.extractFilters(originalQuery),
      expandedQueries: this.generateExpansions(originalQuery)
    };
  }

  private detectIntent(query: string): QueryIntent {
    for (const { pattern, intent } of this.intentPatterns) {
      if (pattern.test(query)) {
        return intent;
      }
    }
    return 'general';
  }

  private extractKeywords(query: string): string[] {
    // Remove code references (will be handled separately)
    let cleanQuery = query.replace(/`[^`]+`/g, ' ');

    // Tokenize
    const tokens = cleanQuery
      .toLowerCase()
      .replace(/[^\w\s-]/g, ' ')
      .split(/\s+/)
      .filter(token =>
        token.length > 2 &&
        !this.stopWords.has(token) &&
        !/^\d+$/.test(token)
      );

    // Deduplicate and return
    return [...new Set(tokens)];
  }

  private extractEntityMentions(query: string): EntityMention[] {
    const mentions: EntityMention[] = [];

    // Backtick code
    for (const match of query.matchAll(this.entityPatterns.backtick)) {
      mentions.push({
        text: match[1],
        confidence: 0.9
      });
    }

    // File paths
    for (const match of query.matchAll(this.entityPatterns.file)) {
      mentions.push({
        text: match[1],
        type: 'file',
        confidence: 0.95
      });
    }

    // Class names
    for (const match of query.matchAll(this.entityPatterns.className)) {
      if (!mentions.some(m => m.text === match[1])) {
        mentions.push({
          text: match[1],
          type: 'class',
          confidence: 0.7
        });
      }
    }

    // Function calls
    for (const match of query.matchAll(this.entityPatterns.functionCall)) {
      if (!mentions.some(m => m.text === match[1])) {
        mentions.push({
          text: match[1],
          type: 'function',
          confidence: 0.6
        });
      }
    }

    return mentions;
  }

  private extractFilters(query: string): QueryFilters {
    const filters: QueryFilters = {};

    // Type filters: "all functions", "classes that..."
    if (/\b(function|method)s?\b/i.test(query)) {
      filters.types = ['function', 'method'];
    } else if (/\bclass(es)?\b/i.test(query)) {
      filters.types = ['class'];
    } else if (/\bfile(s)?\b/i.test(query)) {
      filters.types = ['file'];
    }

    // File path filter
    const fileMatch = query.match(/in\s+(\S+\.(ts|js|py))/i);
    if (fileMatch) {
      filters.files = [fileMatch[1]];
    }

    // Language filter
    const langMatch = query.match(/\b(typescript|javascript|python|go|rust)\b/i);
    if (langMatch) {
      filters.language = langMatch[1].toLowerCase();
    }

    return filters;
  }

  private generateExpansions(query: string): string[] {
    const expansions: string[] = [];
    const keywords = this.extractKeywords(query);

    // Synonym expansions for common terms
    const synonyms: Record<string, string[]> = {
      'auth': ['authentication', 'login', 'credentials'],
      'authentication': ['auth', 'login', 'credentials'],
      'db': ['database', 'storage', 'persistence'],
      'database': ['db', 'storage', 'persistence'],
      'api': ['endpoint', 'route', 'handler'],
      'error': ['exception', 'failure', 'bug'],
      'test': ['spec', 'testing', 'unittest']
    };

    for (const keyword of keywords) {
      if (synonyms[keyword]) {
        for (const syn of synonyms[keyword]) {
          expansions.push(query.replace(new RegExp(keyword, 'gi'), syn));
        }
      }
    }

    // Add shortened version (just keywords)
    if (keywords.length >= 2) {
      expansions.push(keywords.join(' '));
    }

    return expansions.slice(0, 3); // Limit expansions
  }
}
```

## Tasks

- [ ] Implement QueryParser
- [ ] Implement intent detection
- [ ] Implement keyword extraction
- [ ] Implement entity mention detection
- [ ] Implement filter extraction
- [ ] Implement query expansion
- [ ] Write unit tests

## Testing

```typescript
describe('QueryParser', () => {
  describe('intent detection', () => {
    it('should detect find intent');
    it('should detect explain intent');
    it('should detect debug intent');
  });

  describe('keyword extraction', () => {
    it('should extract meaningful keywords');
    it('should filter stop words');
  });

  describe('entity mentions', () => {
    it('should extract backtick code');
    it('should extract file paths');
    it('should extract class names');
  });

  describe('query expansion', () => {
    it('should generate synonym expansions');
  });
});
```
