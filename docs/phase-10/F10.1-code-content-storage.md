# F10.1: Code Content Storage

## Goal

Store actual source code snippets in entity content, not just metadata descriptions. This enables true RAG where queries return relevant code, not just pointers to files.

## Current Limitation

Currently, entities store descriptions like:
```
MyClass: Exported class with 19 method(s) and 5 property/ies
```

This means:
- Semantic search matches descriptions, not code
- `context_query` returns file paths, not code snippets
- Users must still read files manually to get actual code

## Solution Overview

Store actual source code (or meaningful chunks) in entity content:

```typescript
// Before (current)
{
  name: "processPayment",
  type: "function",
  content: "Async function taking 2 parameter(s) returning Promise<PaymentResult>"
}

// After (new)
{
  name: "processPayment",
  type: "function",
  content: `async function processPayment(orderId: string, amount: number): Promise<PaymentResult> {
    const order = await getOrder(orderId);
    const result = await chargeCard(order.paymentMethod, amount);
    await updateOrderStatus(orderId, result.success ? 'paid' : 'failed');
    return result;
  }`,
  summary: "Async function taking 2 parameter(s) returning Promise<PaymentResult>"
}
```

## Architecture

### Entity Schema Update

```sql
-- Add summary column for metadata (current content moves here)
ALTER TABLE {prefix}_entities ADD COLUMN summary TEXT;

-- content column now stores actual code
-- Increase size limits if needed
```

### Content Storage Strategy

Different entity types store different content:

| Entity Type | Content Storage | Max Size |
|-------------|-----------------|----------|
| **function** | Full function body | 500 lines |
| **method** | Full method body | 300 lines |
| **class** | Class signature + constructor + public methods | 1000 lines |
| **interface** | Full interface definition | 200 lines |
| **type** | Full type definition | 100 lines |
| **file** | File overview (imports + exports + top-level summary) | 500 lines |

### Chunking for Large Entities

For entities exceeding size limits, use intelligent chunking:

```typescript
interface CodeChunk {
  entityId: string;
  chunkIndex: number;
  content: string;
  startLine: number;
  endLine: number;
  overlap: number;  // Lines overlapping with adjacent chunks
}
```

## Implementation

### 1. Update Indexer to Store Code

```typescript
// src/indexer/indexer.ts

private async storeFileSummary(
  filePath: string,
  summary: FileSummary,
  sourceCode: string  // NEW: pass source code
): Promise<void> {
  if (!this.entityStore) return;

  // Store file entity with overview
  await this.entityStore.create({
    type: 'file',
    name: path.basename(filePath),
    qualifiedName: filePath,
    content: this.extractFileOverview(sourceCode, summary),
    summary: summary.description,  // Move description to summary
    metadata: {
      language: summary.language,
      exports: summary.exports,
      dependencies: summary.dependencies,
      metrics: summary.metrics
    }
  });

  // Store symbols with actual code
  for (const symbol of summary.symbols) {
    const code = this.extractSymbolCode(sourceCode, symbol);
    await this.entityStore.create({
      type: symbol.type as any,
      name: symbol.name,
      qualifiedName: symbol.qualifiedName,
      content: code,  // Actual code!
      summary: symbol.description,  // Description becomes summary
      metadata: {
        signature: symbol.signature,
        parameters: symbol.parameters,
        returnType: symbol.returnType,
        visibility: symbol.visibility,
        filePath,
        startLine: symbol.location.startLine,
        endLine: symbol.location.endLine
      }
    });
  }
}

private extractSymbolCode(source: string, symbol: SymbolSummary): string {
  const lines = source.split('\n');
  const start = symbol.location.startLine - 1;
  const end = Math.min(symbol.location.endLine, start + this.getMaxLines(symbol.type));

  let code = lines.slice(start, end).join('\n');

  // Add truncation indicator if needed
  if (symbol.location.endLine > end) {
    code += '\n  // ... (truncated)';
  }

  return code;
}

private getMaxLines(type: string): number {
  switch (type) {
    case 'function': return 500;
    case 'method': return 300;
    case 'class': return 1000;
    case 'interface': return 200;
    case 'type': return 100;
    default: return 200;
  }
}

private extractFileOverview(source: string, summary: FileSummary): string {
  const lines = source.split('\n');
  const parts: string[] = [];

  // Include imports (first ~20 lines typically)
  const importEnd = this.findImportEnd(lines);
  if (importEnd > 0) {
    parts.push(lines.slice(0, importEnd).join('\n'));
    parts.push('');
  }

  // Include exports summary
  if (summary.exports.length > 0) {
    parts.push(`// Exports: ${summary.exports.join(', ')}`);
  }

  // Include top-level signatures (not full bodies)
  for (const symbol of summary.symbols.slice(0, 10)) {
    if (symbol.signature) {
      parts.push(symbol.signature);
    }
  }

  return parts.join('\n');
}
```

### 2. Update Entity Store Schema

```typescript
// src/entities/store.ts

async create(input: CreateEntityInput): Promise<Entity> {
  const id = generateId();
  const now = new Date().toISOString();
  const hash = this.computeHash(input.content || '');

  this.db.run(
    `INSERT INTO ${this.tableName}
     (id, type, name, qualified_name, content, summary, metadata, hash, created_at, updated_at)
     VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
    [
      id,
      input.type,
      input.name,
      input.qualifiedName || input.name,
      input.content || null,
      input.summary || null,  // NEW: summary field
      JSON.stringify(input.metadata || {}),
      hash,
      now,
      now
    ]
  );

  return this.get(id)!;
}
```

### 3. Update Embedding Content

When generating embeddings, use both name and content:

```typescript
// src/cli/index-cmd.ts

const toEmbed = entities.map((e) => ({
  id: e.id,
  // Embed name + summary + first N lines of code
  content: this.buildEmbeddingContent(e)
}));

function buildEmbeddingContent(entity: Entity): string {
  const parts: string[] = [];

  // Always include name and type
  parts.push(`${entity.type}: ${entity.name}`);

  // Include summary if available
  if (entity.summary) {
    parts.push(entity.summary);
  }

  // Include first ~50 lines of code for semantic matching
  if (entity.content) {
    const codePreview = entity.content.split('\n').slice(0, 50).join('\n');
    parts.push(codePreview);
  }

  return parts.join('\n\n');
}
```

## Migration

### Database Migration

```sql
-- Migration: Add summary column
ALTER TABLE {prefix}_entities ADD COLUMN summary TEXT;

-- Move current content to summary (one-time migration)
UPDATE {prefix}_entities SET summary = content WHERE summary IS NULL;

-- Clear content for re-indexing (optional, can be gradual)
-- UPDATE {prefix}_entities SET content = NULL;
```

### CLI Migration Command

```bash
# Re-index with code content
ctx-sys index . --full --with-code

# Or just update an existing index
ctx-sys migrate --add-code-content
```

## Configuration

```yaml
# .ctx-sys/config.yaml
indexing:
  store_code_content: true  # Enable code storage (default: true)
  max_function_lines: 500
  max_class_lines: 1000
  chunk_overlap: 20  # Lines of overlap between chunks
```

## Storage Considerations

### Size Estimates

For a typical codebase (10k files, 100k symbols):
- Without code: ~50MB database
- With code: ~500MB-1GB database

### Compression

Consider optional compression for large codebases:

```typescript
// Optional: compress code content
import { gzip, gunzip } from 'zlib';

async storeCompressed(content: string): Promise<Buffer> {
  return gzip(content);
}

async loadCompressed(data: Buffer): Promise<string> {
  return gunzip(data).toString('utf-8');
}
```

## Testing

### Unit Tests

```typescript
describe('Code Content Storage', () => {
  it('stores function code in content field', async () => {
    await indexer.indexFile('test.ts');

    const entity = await entityStore.getByName('myFunction');
    expect(entity.content).toContain('function myFunction');
    expect(entity.summary).toBe('Async function taking 2 parameter(s)');
  });

  it('truncates large functions', async () => {
    await indexer.indexFile('large-function.ts');

    const entity = await entityStore.getByName('veryLongFunction');
    const lines = entity.content.split('\n');
    expect(lines.length).toBeLessThanOrEqual(502); // 500 + truncation indicator
  });

  it('chunks large classes', async () => {
    await indexer.indexFile('large-class.ts');

    const chunks = await chunkStore.getByEntity('LargeClass');
    expect(chunks.length).toBeGreaterThan(1);
  });
});
```

## Success Metrics

| Metric | Target |
|--------|--------|
| Code included in >90% of entities | Entity content populated |
| Search returns actual code | context_query shows code snippets |
| Storage increase acceptable | <10x current size |
| Indexing time increase | <2x current time |

## Dependencies

- None (uses existing infrastructure)

## Risks & Mitigations

| Risk | Mitigation |
|------|------------|
| Database size explosion | Configurable max lines, optional compression |
| Slow indexing | Stream processing, incremental updates |
| Stale code content | Re-index on file change (watch mode) |

## Next Steps

1. Update entity schema with `summary` column
2. Modify indexer to extract and store code
3. Update embedding generation to use code content
4. Add migration command to CLI
5. Test with sample codebases
