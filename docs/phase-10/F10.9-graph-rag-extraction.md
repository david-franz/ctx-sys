# F10.9: Universal Document Indexing with Graph RAG

## Goal

Transform ctx-sys from a code-only indexer into a **universal knowledge graph builder** that can ingest any document type, extract entities and relationships, and build a rich interconnected graph across all project artifacts — code, docs, configs, specs, and free text.

## Current Limitation

```typescript
// Only code files can be indexed — everything else is invisible
await indexer.indexDirectory(projectPath); // Skips .md, .yaml, .json, .toml, .txt, ...

// Existing parsers are fully implemented but NOT wired to stores:
// - MarkdownParser → extracts sections, but doesn't create entities
// - RequirementExtractor → extracts requirements, but doesn't store them
// - DocumentLinker → finds code refs, but doesn't create relationships
// - CoreService.indexDocument() → STUB, returns zeros

// Relationships are limited to within-code AST-derived:
// CONTAINS (file → symbol), IMPORTS (file → file)
// No cross-document relationships at all
```

## Solution Overview

**Three-layer extraction system:**

1. **Structural parsing** (no LLM): Markdown sections, YAML/JSON/TOML keys, file structure
2. **Pattern matching** (no LLM): Code references in docs, import paths, requirement patterns
3. **LLM extraction** (opt-in): Concepts, technologies, semantic relationships across entities

**Pipeline:**

```text
Any Document
  → Detect type (markdown, yaml, json, toml, plain text)
  → Parse structure (sections / keys / flat text)
  → Extract entities → Store via EntityStore.upsert()
  → Extract relationships:
      a) Structural (CONTAINS hierarchy)
      b) Pattern-based (DOCUMENTS, CONFIGURES)
      c) Cross-document (match new entities against full graph)
      d) LLM-powered (opt-in: semantic relationships)
  → Generate embeddings → Store vectors
```

## Architecture

### Document Type Handlers

#### Markdown (`.md`, `.mdx`)

Full structural parsing via existing `MarkdownParser`, `RequirementExtractor`, `DocumentLinker`.

1. **Document entity**: top-level `document` entity with full content
2. **Section entities**: each heading becomes a `section` entity with its body content
3. **Section hierarchy**: `CONTAINS` relationships (document → h1 → h2 → h3)
4. **Requirements**: `RequirementExtractor` finds requirements/user stories → `requirement` entities linked via `CONTAINS` to parent section
5. **Code references**: `DocumentLinker` resolves backtick code, class names, file paths against existing code entities → `DOCUMENTS` relationships
6. **Internal links**: `[see auth](./auth.md)` → `RELATES_TO` between documents
7. **Embeddings**: each section entity gets embedded for vector search

```text
README.md (document)
  ├─ CONTAINS → "Installation" (section)
  ├─ CONTAINS → "Architecture" (section)
  │    ├─ CONTAINS → "Database Layer" (section)
  │    │    ├─ DOCUMENTS → DatabaseConnection (class)
  │    │    └─ DOCUMENTS → EntityStore (class)
  │    └─ CONTAINS → "API Layer" (section)
  ├─ CONTAINS → "Requirements" (section)
  │    ├─ CONTAINS → "Must support SQLite" (requirement)
  │    └─ CONTAINS → "Must support incremental indexing" (requirement)
  └─ RELATES_TO → CONTRIBUTING.md (document)
```

#### YAML (`.yaml`, `.yml`)

Parse with `yaml` package (already in dependencies). Extract meaningful entities from config structure.

1. **Document entity**: top-level `document` entity
2. **Config entities**: top-level keys become entities (type depends on content — `component` for service definitions, `variable` for env config)
3. **Value references**: string values that match known entity names → `CONFIGURES` relationships

```text
docker-compose.yml (document)
  ├─ CONTAINS → "api" (component)
  │    └─ CONFIGURES → ApiService (class)      ← matched by name
  ├─ CONTAINS → "database" (component)
  │    └─ CONFIGURES → DatabaseConnection (class)
  └─ CONTAINS → "redis" (component)
```

#### JSON (`.json`, `package.json`, `tsconfig.json`)

Native `JSON.parse()`. Special handling for known file types:

- **package.json**: extract dependency names as `technology` entities, scripts as `task` entities
- **tsconfig.json**: extract path mappings, link to referenced directories/files
- **Generic JSON**: top-level keys as entities

```text
package.json (document)
  ├─ CONTAINS → "web-tree-sitter" (technology)
  │    └─ USES → ASTParser (class)             ← matched by import
  ├─ CONTAINS → "sql.js" (technology)
  │    └─ USES → DatabaseConnection (class)
  └─ CONTAINS → "build" (task) → "tsc"
```

#### TOML (`.toml`)

Parse with `smol-toml` (lightweight, zero-dep). Same pattern as YAML — extract top-level sections and config entities.

#### Plain Text (`.txt`, `.log`, anything else)

- Creates a `document` entity with full content
- No structural splitting
- Relies on LLM extraction (opt-in) for entity/relationship discovery

### Cross-Document Relationship Discovery

**This is the key differentiator.** When a new document is indexed, its entities are compared against the **entire existing entity graph** to find connections:

1. **Name matching**: New entity names matched against existing entity names (e.g., a section titled "DatabaseConnection" links to the `DatabaseConnection` class)
2. **Content matching**: `DocumentLinker` patterns (backtick code, PascalCase, file paths) resolved against all existing entities
3. **LLM discovery** (opt-in): Given new entities + a sample of nearby existing entities, ask LLM to identify relationships

```typescript
class CrossDocumentLinker {
  // After indexing a document, find relationships to existing entities
  async linkToExistingGraph(
    newEntities: Entity[],
    entityStore: EntityStore,
    relationshipStore: RelationshipStore
  ): Promise<number>;
}
```

### New Files

#### 1. `src/documents/document-indexer.ts` — Document Indexing Orchestrator

```typescript
interface DocumentIndexOptions {
  extractEntities?: boolean;      // LLM entity extraction (opt-in)
  extractRelationships?: boolean; // LLM cross-document relationship discovery (opt-in)
  generateEmbeddings?: boolean;   // Vector embeddings for new entities
}

interface DocumentIndexResult {
  documentId: string;
  entitiesCreated: number;
  relationshipsCreated: number;
  crossDocLinks: number;          // relationships to entities from other documents
  embeddingsGenerated: number;
}

class DocumentIndexer {
  constructor(
    entityStore: EntityStore,
    relationshipStore: RelationshipStore,
    embeddingManager?: EmbeddingManager,
    llmEntityExtractor?: LLMEntityExtractor,
    llmRelationshipExtractor?: LLMRelationshipExtractor
  );

  async indexFile(filePath: string, options?: DocumentIndexOptions): Promise<DocumentIndexResult>;
}
```

Detects file type by extension and delegates to the appropriate handler. All handlers follow the same pattern: parse → create entities → create relationships → optionally embed.

#### 2. `src/graph/llm-entity-extractor.ts` — LLM Entity Extraction

Uses Ollama (qwen3:0.6b) to extract named entities from free text.

```typescript
interface ExtractedEntity {
  name: string;
  type: string;        // concept, technology, pattern, api, etc.
  description: string;
  confidence: number;  // 0-1
}

class LLMEntityExtractor {
  constructor(options?: { baseUrl?: string; model?: string });
  async extract(text: string, context?: string): Promise<ExtractedEntity[]>;
}
```

#### 3. `src/graph/llm-relationship-extractor.ts` — LLM Relationship Discovery

Uses Ollama (qwen3:0.6b) to discover relationships between entities. Operates in two modes:

```typescript
interface ExtractedRelationship {
  source: string;
  target: string;
  relationship: string; // IMPLEMENTS, DEPENDS_ON, USES, etc.
  confidence: number;
  reasoning?: string;
}

class LLMRelationshipExtractor {
  constructor(options?: { baseUrl?: string; model?: string });

  // Within-document: discover relationships among a document's own entities
  async extractFromEntities(
    entities: Array<{ name: string; type: string; description?: string }>,
    context?: string
  ): Promise<ExtractedRelationship[]>;

  // Cross-document: given new entities + existing graph sample, find connections
  async extractCrossDocument(
    newEntities: Array<{ name: string; type: string; description?: string }>,
    existingEntities: Array<{ name: string; type: string; description?: string }>,
    context?: string
  ): Promise<ExtractedRelationship[]>;
}
```

#### 4. `src/cli/doc-index-cmd.ts` — CLI `doc-index` Command

```text
ctx-sys doc-index <path> [options]
  -p, --project <path>    Project directory
  --extract-entities      Use LLM to extract entities from text
  --extract-relationships Use LLM to discover relationships
  --embed                 Generate embeddings for new entities
  -d, --db <path>         Custom database path
```

#### 5. `src/cli/extract-rel-cmd.ts` — CLI `extract-relationships` Command

```text
ctx-sys extract-relationships [options]
  -p, --project <path>    Project directory
  --type <type>           Only process entities of this type
  --limit <n>             Max entities to process
  --dry-run               Show what would be extracted
  -d, --db <path>         Custom database path
```

### Modified Files

- `src/services/core-service.ts` — Replace `indexDocument()` stub with real `DocumentIndexer`
- `src/services/types.ts` — Expand `DocumentIndexOptions` and `DocumentIndexResult` types
- `src/mcp/tool-registry.ts` — Wire `index_document` handler, add `extract_relationships` tool
- `src/cli/index.ts` — Register `doc-index` and `extract-relationships` commands
- `src/documents/index.ts` — Export `DocumentIndexer`
- `src/graph/index.ts` — Export `LLMEntityExtractor` and `LLMRelationshipExtractor`

## Implementation Sequence

### Step 1: DocumentIndexer core + Markdown handler

- Create `src/documents/document-indexer.ts` with file type detection
- Implement markdown handler:
  - Create `document` entity with full content
  - Wire `MarkdownParser` → sections as `section` entities
  - Build section hierarchy via `CONTAINS` relationships
  - Wire `RequirementExtractor` → `requirement` entities
  - Wire `DocumentLinker` → resolve code refs → `DOCUMENTS` relationships
  - Detect internal links → `RELATES_TO` relationships
- Upsert all entities by qualified name (idempotent)

### Step 2: Structured data handlers (YAML/JSON/TOML)

- Add YAML handler: parse with `yaml` package, extract top-level keys as entities
- Add JSON handler: `JSON.parse()`, special handling for `package.json` and `tsconfig.json`
- Add TOML handler: parse with `smol-toml`, extract sections/keys
- Plain text handler: document entity with full content, no structural parsing
- All handlers create `CONTAINS` relationships for hierarchy

### Step 3: Cross-document relationship discovery

- After indexing any document, run name/pattern matching against existing entities
- `DocumentLinker.resolveReference()` already does entity lookup — extend to run on all new entities
- Create `DOCUMENTS`, `CONFIGURES`, `USES`, `RELATES_TO` relationships as appropriate
- Track `crossDocLinks` count in result

### Step 4: LLM Entity Extractor

- Create `src/graph/llm-entity-extractor.ts`
- Ollama JSON prompt for entity extraction
- Parse response, handle `<think>` tags
- Return typed `ExtractedEntity[]` with confidence scores

### Step 5: LLM Relationship Extractor

- Create `src/graph/llm-relationship-extractor.ts`
- Two modes: within-document and cross-document
- For cross-document: sample nearby entities from graph, ask LLM to identify connections
- JSON prompt with relationship type constraints
- Validate against known relationship types

### Step 6: MCP + CLI Integration

- Replace `indexDocument()` stub in `core-service.ts`
- Wire `index_document` MCP tool to real `DocumentIndexer`
- Add `extract_relationships` MCP tool
- Create CLI commands: `doc-index`, `extract-relationships`
- Register in `src/cli/index.ts`

### Step 7: Wire LLM extraction into DocumentIndexer

- Add optional LLM entity extraction pass (runs after structural parsing)
- Add optional LLM relationship extraction pass (runs after cross-doc linking)
- Controllable via `extractEntities` and `extractRelationships` flags

## Design Decisions

- **LLM is optional**: All LLM-powered features are opt-in flags. The system works without Ollama using structural parsing + pattern matching.
- **Same model (qwen3:0.6b)**: Reuse the same small local model for entity extraction, relationship discovery, and summarization.
- **Cross-document by default**: Every indexed document is automatically linked to existing entities via name/pattern matching. LLM cross-document discovery is opt-in on top.
- **JSON prompts**: Use structured JSON output format for reliable LLM response parsing. Include fallback parsing for malformed responses.
- **Confidence scores**: Entity and relationship extraction include confidence (0-1) for downstream filtering.
- **Existing relationship types**: Use the 11 types already in `RelationshipStore` (CONTAINS, IMPORTS, CALLS, IMPLEMENTS, EXTENDS, DEPENDS_ON, USES, CONFIGURES, DOCUMENTS, TESTS, RELATES_TO).
- **Idempotent**: Re-indexing a document updates existing entities via upsert rather than creating duplicates.
- **Structural parsers use npm packages**: YAML via `yaml` (already installed), JSON via native, TOML via `smol-toml`. No hand-rolled parsing.
