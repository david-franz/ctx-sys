# F10.0 Core Service Layer

**Phase**: 10 - Integration & Team
**Priority**: Critical (Prerequisite for F10.1)
**Dependencies**: All Phase 1-9 implementations

## Goal

Create a unified Core Service Layer that abstracts all ctx-sys business logic behind a clean API, then wire up all MCP tools to use this layer. This ensures both MCP (Claude Code) and VS Code extension share identical functionality.

## Problem Statement

Currently:
- **MCP tools are incomplete**: Only 7 of 16+ tools are implemented; 9 are placeholders
- **Business logic is scattered**: Rich functionality exists but isn't exposed consistently
- **AppContext is limited**: Only exposes EntityStore and EmbeddingManager
- **No unified API**: Each consumer must wire up services manually

The business logic for all features EXISTS in the codebase but isn't accessible:

| Feature | Implementation | MCP Tool Status |
|---------|---------------|-----------------|
| Context Query | `src/retrieval/` | ❌ Placeholder |
| Codebase Indexing | `src/indexer/` | ❌ Placeholder |
| Git Sync | `src/git/` | ❌ Placeholder |
| Conversation Memory | `src/conversation/` | ❌ Placeholder |
| Document Intelligence | `src/documents/` | ❌ Placeholder |
| Graph RAG | `src/graph/` | ❌ Placeholder |
| Agent Patterns | `src/agent/` | ❌ Not exposed |
| Analytics | `src/analytics/` | ❌ Not exposed |
| Git Hooks | `src/hooks/` | ❌ Not exposed |

## Architecture

### Current State

```
MCP Client → ToolRegistry → AppContext → Limited Services
                                ↓
                    Only EntityStore, EmbeddingManager
```

### Target State

```
┌─────────────────────────────────────────────────────────────┐
│                      CoreService                             │
│  Unified API for ALL ctx-sys functionality                  │
├─────────────────────────────────────────────────────────────┤
│  Projects    │ Entities    │ Retrieval   │ Conversation    │
│  Indexing    │ Documents   │ Graph       │ Analytics       │
│  Agent       │ Hooks       │ Config      │ Watch           │
└──────────────────────────┬──────────────────────────────────┘
                           │
          ┌────────────────┼────────────────┐
          ▼                ▼                ▼
    ┌──────────┐    ┌──────────┐    ┌──────────┐
    │   MCP    │    │  VS Code │    │   CLI    │
    │ Adapter  │    │ Adapter  │    │ Adapter  │
    └──────────┘    └──────────┘    └──────────┘
```

## Data Model

### CoreService Interface

```typescript
// src/services/core-service.ts

import { AppContext } from '../context';
import { Project, ProjectConfig } from '../project/types';
import { Entity, EntityType, EntitySearchOptions } from '../entities/types';
import { Session, Message, Decision } from '../conversation/types';
import { IndexResult, IndexOptions } from '../indexer/types';
import { ContextResult, QueryOptions } from '../retrieval/types';
import { Relationship, GraphQueryResult } from '../graph/types';
import { AnalyticsStats, QueryLog } from '../analytics/types';
import { Checkpoint, MemoryTier, Reflection } from '../agent/types';
import { HookConfig, ImpactReport } from '../hooks/types';

/**
 * Unified service layer for all ctx-sys operations.
 * Single source of truth for business logic.
 */
export class CoreService {
  constructor(private context: AppContext) {}

  // ─────────────────────────────────────────────────────────
  // PROJECT MANAGEMENT
  // ─────────────────────────────────────────────────────────

  async createProject(name: string, path: string, config?: Partial<ProjectConfig>): Promise<Project>;
  async getProject(nameOrId: string): Promise<Project | null>;
  async listProjects(): Promise<Project[]>;
  async setActiveProject(nameOrId: string): Promise<void>;
  async deleteProject(nameOrId: string, keepData?: boolean): Promise<void>;
  async getActiveProject(): Promise<Project | null>;

  // ─────────────────────────────────────────────────────────
  // ENTITY MANAGEMENT
  // ─────────────────────────────────────────────────────────

  async addEntity(projectId: string, entity: CreateEntityInput): Promise<Entity>;
  async getEntity(projectId: string, id: string): Promise<Entity | null>;
  async getEntityByName(projectId: string, qualifiedName: string): Promise<Entity | null>;
  async searchEntities(projectId: string, query: string, options?: EntitySearchOptions): Promise<Entity[]>;
  async updateEntity(projectId: string, id: string, updates: Partial<Entity>): Promise<Entity>;
  async deleteEntity(projectId: string, id: string): Promise<void>;

  // ─────────────────────────────────────────────────────────
  // CODEBASE INDEXING (Phase 2)
  // ─────────────────────────────────────────────────────────

  async indexCodebase(projectId: string, path: string, options?: IndexOptions): Promise<IndexResult>;
  async indexFile(projectId: string, filePath: string): Promise<IndexResult>;
  async syncFromGit(projectId: string, options?: GitSyncOptions): Promise<SyncResult>;
  async getIndexStatus(projectId: string): Promise<IndexStatus>;

  // ─────────────────────────────────────────────────────────
  // CONVERSATION MEMORY (Phase 3)
  // ─────────────────────────────────────────────────────────

  async createSession(projectId: string, metadata?: Record<string, unknown>): Promise<Session>;
  async getSession(projectId: string, sessionId: string): Promise<Session | null>;
  async listSessions(projectId: string, options?: SessionListOptions): Promise<Session[]>;
  async archiveSession(projectId: string, sessionId: string): Promise<void>;

  async storeMessage(projectId: string, sessionId: string, message: CreateMessageInput): Promise<Message>;
  async getMessages(projectId: string, sessionId: string, options?: MessageQueryOptions): Promise<Message[]>;
  async getHistory(projectId: string, options?: HistoryOptions): Promise<Message[]>;

  async summarizeSession(projectId: string, sessionId: string): Promise<string>;
  async extractDecisions(projectId: string, sessionId: string): Promise<Decision[]>;
  async searchDecisions(projectId: string, query: string, options?: DecisionSearchOptions): Promise<Decision[]>;

  // ─────────────────────────────────────────────────────────
  // DOCUMENT INTELLIGENCE (Phase 4)
  // ─────────────────────────────────────────────────────────

  async indexDocument(projectId: string, path: string, options?: DocumentIndexOptions): Promise<DocumentResult>;
  async parseMarkdown(content: string): Promise<ParsedDocument>;
  async extractRequirements(projectId: string, documentId: string): Promise<Requirement[]>;
  async linkDocumentToCode(projectId: string, documentId: string): Promise<CodeLink[]>;

  // ─────────────────────────────────────────────────────────
  // GRAPH RAG (Phase 5)
  // ─────────────────────────────────────────────────────────

  async addRelationship(projectId: string, relationship: CreateRelationshipInput): Promise<Relationship>;
  async getRelationships(projectId: string, entityId: string, options?: RelationshipQueryOptions): Promise<Relationship[]>;
  async queryGraph(projectId: string, startEntity: string, options?: GraphQueryOptions): Promise<GraphQueryResult>;
  async findPath(projectId: string, fromEntity: string, toEntity: string): Promise<EntityPath | null>;
  async getGraphStats(projectId: string): Promise<GraphStats>;

  // ─────────────────────────────────────────────────────────
  // CONTEXT RETRIEVAL (Phase 6)
  // ─────────────────────────────────────────────────────────

  async queryContext(projectId: string, query: string, options?: QueryOptions): Promise<ContextResult>;
  async searchSemantic(projectId: string, query: string, options?: SemanticSearchOptions): Promise<SearchResult[]>;
  async searchKeyword(projectId: string, query: string, options?: KeywordSearchOptions): Promise<SearchResult[]>;
  async assembleContext(projectId: string, items: ContextItem[], options?: AssemblyOptions): Promise<AssembledContext>;

  // ─────────────────────────────────────────────────────────
  // AGENT PATTERNS (Phase 8)
  // ─────────────────────────────────────────────────────────

  async saveCheckpoint(projectId: string, sessionId: string, state: unknown, metadata?: Record<string, unknown>): Promise<Checkpoint>;
  async loadCheckpoint(projectId: string, sessionId: string, checkpointId?: string): Promise<Checkpoint | null>;
  async listCheckpoints(projectId: string, sessionId: string): Promise<Checkpoint[]>;
  async deleteCheckpoint(projectId: string, checkpointId: string): Promise<void>;

  async spillMemory(projectId: string, sessionId: string, options?: SpillOptions): Promise<SpillResult>;
  async recallMemory(projectId: string, sessionId: string, query: string): Promise<RecallResult>;
  async getMemoryStatus(projectId: string, sessionId: string): Promise<MemoryStatus>;

  async storeReflection(projectId: string, sessionId: string, reflection: CreateReflectionInput): Promise<Reflection>;
  async getReflections(projectId: string, sessionId: string, options?: ReflectionQueryOptions): Promise<Reflection[]>;
  async searchReflections(projectId: string, query: string): Promise<Reflection[]>;

  async subscribeContext(projectId: string, patterns: string[], callback: ContextCallback): Promise<Subscription>;
  async getProactiveSuggestions(projectId: string, filePath: string, position?: Position): Promise<Suggestion[]>;

  // ─────────────────────────────────────────────────────────
  // ANALYTICS (Phase 9)
  // ─────────────────────────────────────────────────────────

  async logQuery(projectId: string, query: QueryLogInput): Promise<QueryLog>;
  async getAnalytics(projectId: string, period: AnalyticsPeriod): Promise<AnalyticsStats>;
  async getTokenSavings(projectId: string, period: AnalyticsPeriod): Promise<TokenSavings>;
  async getDashboardData(projectId: string): Promise<DashboardData>;
  async recordFeedback(projectId: string, queryLogId: string, wasUseful: boolean): Promise<void>;

  // ─────────────────────────────────────────────────────────
  // GIT HOOKS (Phase 9)
  // ─────────────────────────────────────────────────────────

  async installHooks(projectId: string, repoPath: string, config?: HookConfig): Promise<void>;
  async uninstallHooks(projectId: string, repoPath: string): Promise<void>;
  async getImpactReport(projectId: string, baseBranch: string, targetBranch: string): Promise<ImpactReport>;
  async handleHookEvent(projectId: string, event: HookEvent): Promise<HookResult>;

  // ─────────────────────────────────────────────────────────
  // FILE WATCHING (Phase 7)
  // ─────────────────────────────────────────────────────────

  async startWatching(projectId: string, patterns?: string[]): Promise<void>;
  async stopWatching(projectId: string): Promise<void>;
  async getWatchStatus(projectId: string): Promise<WatchStatus>;

  // ─────────────────────────────────────────────────────────
  // CONFIGURATION (Phase 7)
  // ─────────────────────────────────────────────────────────

  async getConfig(projectId?: string): Promise<Config>;
  async setConfig(key: string, value: unknown, projectId?: string): Promise<void>;
  async resetConfig(projectId?: string): Promise<void>;
}
```

### Supporting Types

```typescript
// src/services/types.ts

export interface CreateEntityInput {
  type: EntityType;
  name: string;
  qualifiedName?: string;
  content?: string;
  summary?: string;
  filePath?: string;
  startLine?: number;
  endLine?: number;
  metadata?: Record<string, unknown>;
}

export interface CreateMessageInput {
  role: 'user' | 'assistant' | 'system';
  content: string;
  metadata?: Record<string, unknown>;
}

export interface CreateRelationshipInput {
  sourceId: string;
  targetId: string;
  type: RelationshipType;
  weight?: number;
  metadata?: Record<string, unknown>;
}

export interface CreateReflectionInput {
  type: 'lesson' | 'observation' | 'decision';
  content: string;
  context?: string;
  outcome?: 'success' | 'failure' | 'partial';
  tags?: string[];
}

export interface QueryLogInput {
  query: string;
  tokensUsed: number;
  tokensWithoutCtxSys: number;
  resultCount: number;
  latencyMs: number;
}

export interface GitSyncOptions {
  since?: string;  // Commit SHA or 'last_sync'
  branch?: string;
  summarize?: boolean;
}

export interface SyncResult {
  filesChanged: number;
  entitiesUpdated: number;
  entitiesCreated: number;
  entitiesDeleted: number;
}

export interface IndexStatus {
  lastIndexed: Date | null;
  filesIndexed: number;
  entitiesCount: number;
  isStale: boolean;
}

export type AnalyticsPeriod = 'day' | 'week' | 'month' | 'all';

export interface TokenSavings {
  tokensSaved: number;
  costSaved: number;
  savingsPercent: number;
  queriesAnalyzed: number;
}

export interface DashboardData {
  stats: AnalyticsStats;
  recentQueries: QueryLog[];
  topEntities: EntityUsage[];
  savingsTrend: TrendPoint[];
}
```

## Implementation Plan

### Part 1: Core Service Foundation

**File**: `src/services/core-service.ts`

```typescript
import { AppContext } from '../context';
import { CodebaseIndexer } from '../indexer';
import { SessionManager, MessageStore, ConversationSummarizer, DecisionExtractor } from '../conversation';
import { MarkdownParser, RequirementExtractor, DocumentLinker } from '../documents';
import { RelationshipStore, GraphTraversal, EntityResolver } from '../graph';
import { MultiStrategySearch, ContextAssembler, QueryParser } from '../retrieval';
import { CheckpointManager, MemoryTierManager, ReflectionStore, ProactiveContext } from '../agent';
import { QueryLogger, FullContextEstimator, DashboardService } from '../analytics';
import { HookInstaller, ImpactAnalyzer, HookHandler } from '../hooks';
import { FileWatcher } from '../watch';
import { ConfigManager } from '../config';

export class CoreService {
  // Lazy-initialized service instances per project
  private indexers: Map<string, CodebaseIndexer> = new Map();
  private sessionManagers: Map<string, SessionManager> = new Map();
  private messageStores: Map<string, MessageStore> = new Map();
  private relationshipStores: Map<string, RelationshipStore> = new Map();
  private searchServices: Map<string, MultiStrategySearch> = new Map();
  private checkpointManagers: Map<string, CheckpointManager> = new Map();
  private queryLoggers: Map<string, QueryLogger> = new Map();
  // ... etc

  constructor(private context: AppContext) {}

  // ─────────────────────────────────────────────────────────
  // SERVICE ACCESSORS (Lazy initialization)
  // ─────────────────────────────────────────────────────────

  private getIndexer(projectId: string): CodebaseIndexer {
    if (!this.indexers.has(projectId)) {
      const entityStore = this.context.getEntityStore(projectId);
      const embeddingManager = this.context.getEmbeddingManager(projectId);
      this.indexers.set(projectId, new CodebaseIndexer(
        this.context.db,
        projectId,
        entityStore,
        embeddingManager
      ));
    }
    return this.indexers.get(projectId)!;
  }

  private getSessionManager(projectId: string): SessionManager {
    if (!this.sessionManagers.has(projectId)) {
      this.sessionManagers.set(projectId, new SessionManager(this.context.db, projectId));
    }
    return this.sessionManagers.get(projectId)!;
  }

  private getMessageStore(projectId: string): MessageStore {
    if (!this.messageStores.has(projectId)) {
      this.messageStores.set(projectId, new MessageStore(this.context.db, projectId));
    }
    return this.messageStores.get(projectId)!;
  }

  private getRelationshipStore(projectId: string): RelationshipStore {
    if (!this.relationshipStores.has(projectId)) {
      this.relationshipStores.set(projectId, new RelationshipStore(this.context.db, projectId));
    }
    return this.relationshipStores.get(projectId)!;
  }

  private getSearchService(projectId: string): MultiStrategySearch {
    if (!this.searchServices.has(projectId)) {
      const entityStore = this.context.getEntityStore(projectId);
      const embeddingManager = this.context.getEmbeddingManager(projectId);
      const relationshipStore = this.getRelationshipStore(projectId);
      this.searchServices.set(projectId, new MultiStrategySearch(
        entityStore,
        embeddingManager,
        relationshipStore
      ));
    }
    return this.searchServices.get(projectId)!;
  }

  // ... more accessors

  // ─────────────────────────────────────────────────────────
  // IMPLEMENTATION EXAMPLES
  // ─────────────────────────────────────────────────────────

  async indexCodebase(projectId: string, path: string, options?: IndexOptions): Promise<IndexResult> {
    const indexer = this.getIndexer(projectId);
    return indexer.indexDirectory(path, options);
  }

  async queryContext(projectId: string, query: string, options?: QueryOptions): Promise<ContextResult> {
    const search = this.getSearchService(projectId);
    const results = await search.search(query, options);

    const assembler = new ContextAssembler(this.context.getEntityStore(projectId));
    return assembler.assemble(results, options?.maxTokens);
  }

  async storeMessage(projectId: string, sessionId: string, message: CreateMessageInput): Promise<Message> {
    const store = this.getMessageStore(projectId);
    return store.create(sessionId, message);
  }

  // ... full implementation
}
```

### Part 2: Wire Up MCP Tools

**File**: `src/mcp/tool-registry.ts` (updated)

```typescript
import { CoreService } from '../services/core-service';

export class ToolRegistry {
  private coreService: CoreService;

  constructor(private context: AppContext) {
    this.coreService = new CoreService(context);
    this.registerAllTools();
  }

  private registerAllTools(): void {
    this.registerProjectTools();
    this.registerEntityTools();
    this.registerIndexingTools();      // NEW
    this.registerConversationTools();  // NEW
    this.registerDocumentTools();      // NEW
    this.registerGraphTools();         // NEW
    this.registerRetrievalTools();     // NEW
    this.registerAgentTools();         // NEW
    this.registerAnalyticsTools();     // NEW
    this.registerHookTools();          // NEW
  }

  // ─────────────────────────────────────────────────────────
  // INDEXING TOOLS (Phase 2)
  // ─────────────────────────────────────────────────────────

  private registerIndexingTools(): void {
    this.register({
      name: 'index_codebase',
      description: 'Index a codebase directory, extracting entities and relationships',
      inputSchema: {
        type: 'object',
        properties: {
          path: { type: 'string', description: 'Directory path to index' },
          project: { type: 'string', description: 'Target project (default: active)' },
          depth: {
            type: 'string',
            enum: ['full', 'signatures', 'selective'],
            description: 'Indexing depth (default: full)'
          },
          ignore: {
            type: 'array',
            items: { type: 'string' },
            description: 'Glob patterns to ignore'
          },
          languages: {
            type: 'array',
            items: { type: 'string' },
            description: 'Limit to specific languages'
          },
          summarize: { type: 'boolean', description: 'Generate AI summaries' }
        },
        required: ['path']
      }
    }, async (args) => {
      const { path, project, ...options } = args as any;
      const projectId = await this.resolveProjectId(project);
      const result = await this.coreService.indexCodebase(projectId, path, options);
      return {
        success: true,
        filesIndexed: result.filesProcessed,
        entitiesCreated: result.entitiesCreated,
        relationshipsCreated: result.relationshipsCreated,
        errors: result.errors
      };
    });

    this.register({
      name: 'sync_from_git',
      description: 'Incrementally sync changes from git commits',
      inputSchema: {
        type: 'object',
        properties: {
          project: { type: 'string', description: 'Target project (default: active)' },
          since: { type: 'string', description: 'Commit SHA or "last_sync"' },
          branch: { type: 'string', description: 'Branch to sync from' },
          summarize: { type: 'boolean', description: 'Generate summaries for changes' }
        }
      }
    }, async (args) => {
      const { project, ...options } = args as any;
      const projectId = await this.resolveProjectId(project);
      const result = await this.coreService.syncFromGit(projectId, options);
      return { success: true, ...result };
    });
  }

  // ─────────────────────────────────────────────────────────
  // CONVERSATION TOOLS (Phase 3)
  // ─────────────────────────────────────────────────────────

  private registerConversationTools(): void {
    this.register({
      name: 'store_message',
      description: 'Store a message in conversation history',
      inputSchema: {
        type: 'object',
        properties: {
          content: { type: 'string', description: 'Message content' },
          role: {
            type: 'string',
            enum: ['user', 'assistant', 'system'],
            description: 'Message role'
          },
          session: { type: 'string', description: 'Session ID (auto-creates if not exists)' },
          project: { type: 'string', description: 'Target project (default: active)' },
          metadata: { type: 'object', description: 'Additional metadata' }
        },
        required: ['content', 'role']
      }
    }, async (args) => {
      const { content, role, session, project, metadata } = args as any;
      const projectId = await this.resolveProjectId(project);

      // Auto-create session if needed
      let sessionId = session;
      if (!sessionId) {
        const newSession = await this.coreService.createSession(projectId);
        sessionId = newSession.id;
      }

      const message = await this.coreService.storeMessage(projectId, sessionId, {
        role, content, metadata
      });
      return { success: true, messageId: message.id, sessionId };
    });

    this.register({
      name: 'get_history',
      description: 'Get conversation history',
      inputSchema: {
        type: 'object',
        properties: {
          session: { type: 'string', description: 'Session ID' },
          project: { type: 'string', description: 'Target project (default: active)' },
          limit: { type: 'number', description: 'Max messages (default: 10)' },
          before: { type: 'string', description: 'Cursor for pagination' }
        }
      }
    }, async (args) => {
      const { session, project, limit, before } = args as any;
      const projectId = await this.resolveProjectId(project);
      const messages = await this.coreService.getHistory(projectId, { sessionId: session, limit, before });
      return {
        success: true,
        count: messages.length,
        messages: messages.map(m => ({
          id: m.id,
          role: m.role,
          content: m.content,
          createdAt: m.createdAt
        }))
      };
    });

    this.register({
      name: 'summarize_session',
      description: 'Generate a summary of a conversation session',
      inputSchema: {
        type: 'object',
        properties: {
          session: { type: 'string', description: 'Session ID to summarize' },
          project: { type: 'string', description: 'Target project (default: active)' },
          archive: { type: 'boolean', description: 'Archive session after summarizing' }
        },
        required: ['session']
      }
    }, async (args) => {
      const { session, project, archive } = args as any;
      const projectId = await this.resolveProjectId(project);
      const summary = await this.coreService.summarizeSession(projectId, session);
      if (archive) {
        await this.coreService.archiveSession(projectId, session);
      }
      return { success: true, summary, archived: archive ?? false };
    });

    this.register({
      name: 'search_decisions',
      description: 'Search for architectural decisions in conversation history',
      inputSchema: {
        type: 'object',
        properties: {
          query: { type: 'string', description: 'Search query' },
          project: { type: 'string', description: 'Target project (default: active)' },
          limit: { type: 'number', description: 'Max results (default: 10)' }
        },
        required: ['query']
      }
    }, async (args) => {
      const { query, project, limit } = args as any;
      const projectId = await this.resolveProjectId(project);
      const decisions = await this.coreService.searchDecisions(projectId, query, { limit });
      return {
        success: true,
        count: decisions.length,
        decisions: decisions.map(d => ({
          id: d.id,
          decision: d.content,
          context: d.context,
          sessionId: d.sessionId,
          createdAt: d.createdAt,
          tags: d.tags
        }))
      };
    });
  }

  // ─────────────────────────────────────────────────────────
  // DOCUMENT TOOLS (Phase 4)
  // ─────────────────────────────────────────────────────────

  private registerDocumentTools(): void {
    this.register({
      name: 'index_document',
      description: 'Index a markdown or text document',
      inputSchema: {
        type: 'object',
        properties: {
          path: { type: 'string', description: 'Document path' },
          project: { type: 'string', description: 'Target project (default: active)' },
          type: {
            type: 'string',
            enum: ['markdown', 'text', 'requirements'],
            description: 'Document type'
          },
          extractRequirements: { type: 'boolean', description: 'Extract requirements from doc' },
          linkToCode: { type: 'boolean', description: 'Link document sections to code' }
        },
        required: ['path']
      }
    }, async (args) => {
      const { path, project, type, extractRequirements, linkToCode } = args as any;
      const projectId = await this.resolveProjectId(project);
      const result = await this.coreService.indexDocument(projectId, path, {
        type, extractRequirements, linkToCode
      });
      return { success: true, ...result };
    });
  }

  // ─────────────────────────────────────────────────────────
  // GRAPH TOOLS (Phase 5)
  // ─────────────────────────────────────────────────────────

  private registerGraphTools(): void {
    this.register({
      name: 'link_entities',
      description: 'Create a relationship between two entities',
      inputSchema: {
        type: 'object',
        properties: {
          source: { type: 'string', description: 'Source entity ID or name' },
          target: { type: 'string', description: 'Target entity ID or name' },
          relationship: {
            type: 'string',
            description: 'Relationship type (CALLS, IMPORTS, IMPLEMENTS, etc.)'
          },
          project: { type: 'string', description: 'Target project (default: active)' },
          weight: { type: 'number', description: 'Relationship weight (0-1)' },
          metadata: { type: 'object', description: 'Additional metadata' }
        },
        required: ['source', 'target', 'relationship']
      }
    }, async (args) => {
      const { source, target, relationship, project, weight, metadata } = args as any;
      const projectId = await this.resolveProjectId(project);

      // Resolve entity IDs from names if needed
      const sourceId = await this.resolveEntityId(projectId, source);
      const targetId = await this.resolveEntityId(projectId, target);

      const rel = await this.coreService.addRelationship(projectId, {
        sourceId, targetId, type: relationship, weight, metadata
      });
      return { success: true, relationshipId: rel.id };
    });

    this.register({
      name: 'query_graph',
      description: 'Query the knowledge graph starting from an entity',
      inputSchema: {
        type: 'object',
        properties: {
          entity: { type: 'string', description: 'Starting entity ID or name' },
          project: { type: 'string', description: 'Target project (default: active)' },
          depth: { type: 'number', description: 'Traversal depth (default: 2)' },
          relationships: {
            type: 'array',
            items: { type: 'string' },
            description: 'Filter by relationship types'
          },
          direction: {
            type: 'string',
            enum: ['in', 'out', 'both'],
            description: 'Traversal direction'
          }
        },
        required: ['entity']
      }
    }, async (args) => {
      const { entity, project, depth, relationships, direction } = args as any;
      const projectId = await this.resolveProjectId(project);
      const entityId = await this.resolveEntityId(projectId, entity);

      const result = await this.coreService.queryGraph(projectId, entityId, {
        depth, relationships, direction
      });
      return { success: true, ...result };
    });
  }

  // ─────────────────────────────────────────────────────────
  // RETRIEVAL TOOLS (Phase 6)
  // ─────────────────────────────────────────────────────────

  private registerRetrievalTools(): void {
    this.register({
      name: 'context_query',
      description: 'Query for relevant context using hybrid search (vector + graph + keyword)',
      inputSchema: {
        type: 'object',
        properties: {
          query: { type: 'string', description: 'The search query' },
          project: { type: 'string', description: 'Target project (default: active)' },
          max_tokens: { type: 'number', description: 'Token budget for response (default: 4000)' },
          include_types: {
            type: 'array',
            items: { type: 'string' },
            description: 'Entity types to include (code, doc, decision, etc.)'
          },
          include_sources: { type: 'boolean', description: 'Include source attribution' },
          strategies: {
            type: 'array',
            items: { type: 'string', enum: ['vector', 'graph', 'keyword'] },
            description: 'Search strategies to use (default: all)'
          }
        },
        required: ['query']
      }
    }, async (args) => {
      const { query, project, max_tokens, include_types, include_sources, strategies } = args as any;
      const projectId = await this.resolveProjectId(project);

      const result = await this.coreService.queryContext(projectId, query, {
        maxTokens: max_tokens,
        includeTypes: include_types,
        includeSources: include_sources,
        strategies
      });

      return {
        success: true,
        context: result.context,
        sources: include_sources ? result.sources : undefined,
        confidence: result.confidence,
        tokensUsed: result.tokensUsed
      };
    });
  }

  // ─────────────────────────────────────────────────────────
  // AGENT TOOLS (Phase 8)
  // ─────────────────────────────────────────────────────────

  private registerAgentTools(): void {
    this.register({
      name: 'checkpoint_save',
      description: 'Save agent state checkpoint for later resumption',
      inputSchema: {
        type: 'object',
        properties: {
          session: { type: 'string', description: 'Session ID' },
          project: { type: 'string', description: 'Target project (default: active)' },
          state: { type: 'object', description: 'State object to save' },
          metadata: { type: 'object', description: 'Additional metadata' }
        },
        required: ['session', 'state']
      }
    }, async (args) => {
      const { session, project, state, metadata } = args as any;
      const projectId = await this.resolveProjectId(project);
      const checkpoint = await this.coreService.saveCheckpoint(projectId, session, state, metadata);
      return { success: true, checkpointId: checkpoint.id, createdAt: checkpoint.createdAt };
    });

    this.register({
      name: 'checkpoint_load',
      description: 'Load agent state from checkpoint',
      inputSchema: {
        type: 'object',
        properties: {
          session: { type: 'string', description: 'Session ID' },
          project: { type: 'string', description: 'Target project (default: active)' },
          checkpoint_id: { type: 'string', description: 'Specific checkpoint (default: latest)' }
        },
        required: ['session']
      }
    }, async (args) => {
      const { session, project, checkpoint_id } = args as any;
      const projectId = await this.resolveProjectId(project);
      const checkpoint = await this.coreService.loadCheckpoint(projectId, session, checkpoint_id);
      if (!checkpoint) {
        return { success: false, error: 'No checkpoint found' };
      }
      return { success: true, state: checkpoint.state, createdAt: checkpoint.createdAt };
    });

    this.register({
      name: 'memory_spill',
      description: 'Spill hot memory to cold storage',
      inputSchema: {
        type: 'object',
        properties: {
          session: { type: 'string', description: 'Session ID' },
          project: { type: 'string', description: 'Target project (default: active)' },
          threshold: { type: 'number', description: 'Token threshold for spill' }
        },
        required: ['session']
      }
    }, async (args) => {
      const { session, project, threshold } = args as any;
      const projectId = await this.resolveProjectId(project);
      const result = await this.coreService.spillMemory(projectId, session, { threshold });
      return { success: true, ...result };
    });

    this.register({
      name: 'memory_recall',
      description: 'Recall relevant information from cold storage',
      inputSchema: {
        type: 'object',
        properties: {
          session: { type: 'string', description: 'Session ID' },
          project: { type: 'string', description: 'Target project (default: active)' },
          query: { type: 'string', description: 'What to recall' }
        },
        required: ['session', 'query']
      }
    }, async (args) => {
      const { session, project, query } = args as any;
      const projectId = await this.resolveProjectId(project);
      const result = await this.coreService.recallMemory(projectId, session, query);
      return { success: true, ...result };
    });

    this.register({
      name: 'reflection_store',
      description: 'Store a reflection or lesson learned',
      inputSchema: {
        type: 'object',
        properties: {
          session: { type: 'string', description: 'Session ID' },
          project: { type: 'string', description: 'Target project (default: active)' },
          type: {
            type: 'string',
            enum: ['lesson', 'observation', 'decision'],
            description: 'Reflection type'
          },
          content: { type: 'string', description: 'Reflection content' },
          context: { type: 'string', description: 'Context where this applies' },
          outcome: {
            type: 'string',
            enum: ['success', 'failure', 'partial'],
            description: 'Outcome of the approach'
          },
          tags: { type: 'array', items: { type: 'string' }, description: 'Tags for categorization' }
        },
        required: ['session', 'content']
      }
    }, async (args) => {
      const { session, project, ...reflectionData } = args as any;
      const projectId = await this.resolveProjectId(project);
      const reflection = await this.coreService.storeReflection(projectId, session, reflectionData);
      return { success: true, reflectionId: reflection.id };
    });
  }

  // ─────────────────────────────────────────────────────────
  // ANALYTICS TOOLS (Phase 9)
  // ─────────────────────────────────────────────────────────

  private registerAnalyticsTools(): void {
    this.register({
      name: 'analytics_get_stats',
      description: 'Get token usage and savings statistics',
      inputSchema: {
        type: 'object',
        properties: {
          project: { type: 'string', description: 'Target project (default: active)' },
          period: {
            type: 'string',
            enum: ['day', 'week', 'month', 'all'],
            description: 'Time period for stats'
          }
        }
      }
    }, async (args) => {
      const { project, period } = args as any;
      const projectId = await this.resolveProjectId(project);
      const stats = await this.coreService.getAnalytics(projectId, period || 'week');
      return { success: true, ...stats };
    });

    this.register({
      name: 'analytics_record_feedback',
      description: 'Record feedback on query usefulness',
      inputSchema: {
        type: 'object',
        properties: {
          query_log_id: { type: 'string', description: 'Query log ID' },
          project: { type: 'string', description: 'Target project (default: active)' },
          was_useful: { type: 'boolean', description: 'Whether the result was useful' }
        },
        required: ['query_log_id', 'was_useful']
      }
    }, async (args) => {
      const { query_log_id, project, was_useful } = args as any;
      const projectId = await this.resolveProjectId(project);
      await this.coreService.recordFeedback(projectId, query_log_id, was_useful);
      return { success: true };
    });

    this.register({
      name: 'analytics_dashboard',
      description: 'Get dashboard data with stats, trends, and recent activity',
      inputSchema: {
        type: 'object',
        properties: {
          project: { type: 'string', description: 'Target project (default: active)' }
        }
      }
    }, async (args) => {
      const { project } = args as any;
      const projectId = await this.resolveProjectId(project);
      const data = await this.coreService.getDashboardData(projectId);
      return { success: true, ...data };
    });
  }

  // ─────────────────────────────────────────────────────────
  // HOOK TOOLS (Phase 9)
  // ─────────────────────────────────────────────────────────

  private registerHookTools(): void {
    this.register({
      name: 'hooks_install',
      description: 'Install git hooks for automatic indexing',
      inputSchema: {
        type: 'object',
        properties: {
          project: { type: 'string', description: 'Target project (default: active)' },
          repository_path: { type: 'string', description: 'Git repository path' },
          hooks: {
            type: 'array',
            items: { type: 'string', enum: ['post-commit', 'post-merge', 'pre-push'] },
            description: 'Hooks to install'
          }
        },
        required: ['repository_path']
      }
    }, async (args) => {
      const { project, repository_path, hooks } = args as any;
      const projectId = await this.resolveProjectId(project);
      await this.coreService.installHooks(projectId, repository_path, { hooks });
      return { success: true, installed: hooks || ['post-commit', 'post-merge'] };
    });

    this.register({
      name: 'hooks_impact_report',
      description: 'Generate impact report for code changes',
      inputSchema: {
        type: 'object',
        properties: {
          project: { type: 'string', description: 'Target project (default: active)' },
          base_branch: { type: 'string', description: 'Base branch (e.g., main)' },
          target_branch: { type: 'string', description: 'Target branch with changes' }
        },
        required: ['base_branch', 'target_branch']
      }
    }, async (args) => {
      const { project, base_branch, target_branch } = args as any;
      const projectId = await this.resolveProjectId(project);
      const report = await this.coreService.getImpactReport(projectId, base_branch, target_branch);
      return { success: true, ...report };
    });
  }

  // ─────────────────────────────────────────────────────────
  // HELPER METHODS
  // ─────────────────────────────────────────────────────────

  private async resolveEntityId(projectId: string, nameOrId: string): Promise<string> {
    // Check if it's already an ID
    const entityStore = this.context.getEntityStore(projectId);
    const byId = await entityStore.get(nameOrId);
    if (byId) return byId.id;

    // Try as qualified name
    const byName = await entityStore.getByQualifiedName(nameOrId);
    if (byName) return byName.id;

    throw new Error(`Entity not found: ${nameOrId}`);
  }
}
```

## File Structure

```
src/
├── services/
│   ├── index.ts              # Export CoreService
│   ├── core-service.ts       # Main implementation
│   └── types.ts              # Service-level types
├── mcp/
│   ├── tool-registry.ts      # UPDATED: Uses CoreService
│   ├── server.ts             # Unchanged
│   └── index.ts              # Unchanged
└── ... (existing code unchanged)
```

## Testing Strategy

### Unit Tests

```typescript
describe('CoreService', () => {
  let service: CoreService;
  let mockContext: AppContext;

  beforeEach(async () => {
    mockContext = await createTestContext();
    service = new CoreService(mockContext);
  });

  describe('indexCodebase', () => {
    it('should index files and create entities', async () => {
      const result = await service.indexCodebase('project-1', '/test/src');
      expect(result.filesProcessed).toBeGreaterThan(0);
      expect(result.entitiesCreated).toBeGreaterThan(0);
    });

    it('should respect ignore patterns', async () => {
      const result = await service.indexCodebase('project-1', '/test/src', {
        ignore: ['*.test.ts']
      });
      // Verify no test files indexed
    });
  });

  describe('queryContext', () => {
    it('should return relevant context for query', async () => {
      // Setup: index some code first
      await service.indexCodebase('project-1', '/test/src');

      const result = await service.queryContext('project-1', 'authentication');
      expect(result.context).toBeTruthy();
      expect(result.confidence).toBeGreaterThan(0);
    });

    it('should respect token budget', async () => {
      const result = await service.queryContext('project-1', 'test', {
        maxTokens: 100
      });
      expect(result.tokensUsed).toBeLessThanOrEqual(100);
    });
  });

  describe('conversation', () => {
    it('should store and retrieve messages', async () => {
      const session = await service.createSession('project-1');
      await service.storeMessage('project-1', session.id, {
        role: 'user',
        content: 'How does auth work?'
      });

      const messages = await service.getHistory('project-1', { sessionId: session.id });
      expect(messages).toHaveLength(1);
      expect(messages[0].content).toBe('How does auth work?');
    });
  });
});
```

### Integration Tests

```typescript
describe('MCP Tool Integration', () => {
  let server: CtxSysMcpServer;

  beforeEach(async () => {
    server = new CtxSysMcpServer({ dbPath: ':memory:' });
    await server.initialize();
  });

  it('should execute context_query tool', async () => {
    const result = await server.executeTool('context_query', {
      query: 'authentication',
      max_tokens: 1000
    });
    expect(result.success).toBe(true);
    expect(result.context).toBeTruthy();
  });

  it('should execute full indexing workflow', async () => {
    // Create project
    await server.executeTool('create_project', {
      name: 'test-project',
      path: '/test'
    });

    // Index codebase
    const indexResult = await server.executeTool('index_codebase', {
      path: '/test/src'
    });
    expect(indexResult.success).toBe(true);

    // Query context
    const queryResult = await server.executeTool('context_query', {
      query: 'main function'
    });
    expect(queryResult.success).toBe(true);
  });
});
```

## Success Criteria

| Metric | Target |
|--------|--------|
| All MCP tools functional | 100% (no placeholders) |
| CoreService test coverage | > 80% |
| Tool response time | < 2s for queries, < 30s for indexing |
| API consistency | Same results from MCP and direct CoreService calls |

## Dependencies

- All Phase 1-9 implementations (already complete)
- No new external dependencies required

## Risks & Mitigations

| Risk | Mitigation |
|------|------------|
| Breaking existing MCP clients | Keep same tool names and response shapes |
| Performance regression | Lazy service initialization, caching |
| Type safety gaps | Full TypeScript interfaces for all operations |

## Timeline

| Task | Estimate |
|------|----------|
| Create CoreService interface | 1 day |
| Implement CoreService methods | 2-3 days |
| Wire up MCP tools | 1-2 days |
| Testing & fixes | 1-2 days |
| **Total** | **5-8 days** |

## Next Steps (After F10.0)

Once F10.0 is complete:
1. **F10.1**: VS Code Extension - will use CoreService directly
2. **F10.2**: Team Knowledge Base - will extend CoreService with team features
3. **F10.3**: Auth/SSO - will wrap CoreService with auth middleware
