# F10.7: CLI Completeness

## Goal

Provide full CLI access to all ctx-sys functionality. Users should never need to look inside the database to understand what's stored or to manage their data. Every MCP tool should have a corresponding CLI command.

## Current Limitation

The CLI currently only supports basic operations:

```bash
ctx-sys init          # Create project
ctx-sys index         # Index codebase
ctx-sys search        # Basic entity search
ctx-sys status        # Show project status
ctx-sys config        # View/set config
ctx-sys serve         # Start MCP server
```

Missing capabilities:
- View/manage conversations and sessions
- Inspect entities and their content
- Query and visualize relationships/graph
- Manage embeddings
- View analytics
- Debug and inspect database state

## Solution Overview

Add comprehensive CLI commands organized by domain:

| Domain | Commands |
|--------|----------|
| **Conversations** | `sessions`, `messages`, `session-delete`, `session-export` |
| **Entities** | `entities`, `entity`, `entity-delete` |
| **Graph** | `graph`, `graph-stats`, `relationships` |
| **Embeddings** | `embed`, `embed-status`, `embed-cleanup` |
| **Analytics** | `analytics`, `dashboard` |
| **Debug** | `inspect`, `query`, `export`, `import` |

## Implementation

### 1. Conversation Commands

```typescript
// src/cli/commands/conversations.ts

import { Command } from 'commander';
import { CoreService } from '../../core/service';
import { formatTable, formatDate, truncate } from '../formatters';

export function registerConversationCommands(program: Command, getService: () => Promise<CoreService>) {

  /**
   * List all sessions
   */
  program
    .command('sessions')
    .description('List conversation sessions')
    .option('-p, --project <name>', 'Project name (default: active)')
    .option('-s, --status <status>', 'Filter by status (active/archived/summarized)')
    .option('-l, --limit <n>', 'Max sessions to show', '20')
    .option('--json', 'Output as JSON')
    .action(async (options) => {
      const service = await getService();
      const sessions = await service.listSessions({
        project: options.project,
        status: options.status,
        limit: parseInt(options.limit)
      });

      if (options.json) {
        console.log(JSON.stringify(sessions, null, 2));
        return;
      }

      if (sessions.length === 0) {
        console.log('No sessions found.');
        return;
      }

      console.log(formatTable(sessions, [
        { header: 'ID', key: 'id', width: 12 },
        { header: 'Status', key: 'status', width: 10 },
        { header: 'Messages', key: 'messageCount', width: 10 },
        { header: 'Created', key: 'createdAt', format: formatDate, width: 20 },
        { header: 'Updated', key: 'updatedAt', format: formatDate, width: 20 },
        { header: 'Summary', key: 'summary', format: (s) => truncate(s, 40), width: 42 }
      ]));

      console.log(`\nTotal: ${sessions.length} session(s)`);
    });

  /**
   * View messages in a session
   */
  program
    .command('messages [sessionId]')
    .description('View messages in a session')
    .option('-p, --project <name>', 'Project name (default: active)')
    .option('-l, --limit <n>', 'Max messages to show', '50')
    .option('-b, --before <messageId>', 'Get messages before this ID')
    .option('--json', 'Output as JSON')
    .option('--raw', 'Show full message content without truncation')
    .action(async (sessionId, options) => {
      const service = await getService();

      const messages = await service.getHistory({
        project: options.project,
        session: sessionId,
        limit: parseInt(options.limit),
        before: options.before
      });

      if (options.json) {
        console.log(JSON.stringify(messages, null, 2));
        return;
      }

      if (messages.length === 0) {
        console.log('No messages found.');
        return;
      }

      for (const msg of messages) {
        const time = formatDate(msg.createdAt);
        const role = msg.role.toUpperCase().padEnd(10);
        const roleColor = msg.role === 'user' ? '\x1b[36m' : '\x1b[33m';

        console.log(`\x1b[90m${time}\x1b[0m ${roleColor}${role}\x1b[0m`);

        const content = options.raw ? msg.content : truncate(msg.content, 500);
        console.log(content);
        console.log('');
      }

      console.log(`\x1b[90mShowing ${messages.length} message(s)\x1b[0m`);
    });

  /**
   * Store a message (for testing/manual input)
   */
  program
    .command('message-add')
    .description('Add a message to a session')
    .requiredOption('-c, --content <text>', 'Message content')
    .requiredOption('-r, --role <role>', 'Role (user/assistant/system)')
    .option('-p, --project <name>', 'Project name (default: active)')
    .option('-s, --session <id>', 'Session ID (creates new if not specified)')
    .action(async (options) => {
      const service = await getService();

      const result = await service.storeMessage({
        project: options.project,
        content: options.content,
        role: options.role,
        session: options.session
      });

      console.log(`Message stored in session: ${result.sessionId}`);
      console.log(`Message ID: ${result.messageId}`);
    });

  /**
   * Delete a session
   */
  program
    .command('session-delete <sessionId>')
    .description('Delete a session and all its messages')
    .option('-p, --project <name>', 'Project name (default: active)')
    .option('-f, --force', 'Skip confirmation')
    .action(async (sessionId, options) => {
      const service = await getService();

      if (!options.force) {
        const session = await service.getSession(sessionId, options.project);
        if (!session) {
          console.error(`Session not found: ${sessionId}`);
          process.exit(1);
        }

        console.log(`Session: ${session.id}`);
        console.log(`Messages: ${session.messageCount}`);
        console.log(`Created: ${formatDate(session.createdAt)}`);

        const readline = require('readline');
        const rl = readline.createInterface({
          input: process.stdin,
          output: process.stdout
        });

        const answer = await new Promise<string>(resolve => {
          rl.question('Delete this session? (y/N) ', resolve);
        });
        rl.close();

        if (answer.toLowerCase() !== 'y') {
          console.log('Cancelled.');
          return;
        }
      }

      await service.deleteSession(sessionId, options.project);
      console.log(`Deleted session: ${sessionId}`);
    });

  /**
   * Export a session
   */
  program
    .command('session-export <sessionId>')
    .description('Export a session to JSON or markdown')
    .option('-p, --project <name>', 'Project name (default: active)')
    .option('-f, --format <format>', 'Output format (json/markdown)', 'markdown')
    .option('-o, --output <file>', 'Output file (default: stdout)')
    .action(async (sessionId, options) => {
      const service = await getService();

      const messages = await service.getHistory({
        project: options.project,
        session: sessionId,
        limit: 10000 // Get all
      });

      let output: string;

      if (options.format === 'json') {
        output = JSON.stringify({ sessionId, messages }, null, 2);
      } else {
        // Markdown format
        const lines: string[] = [`# Session: ${sessionId}\n`];

        for (const msg of messages) {
          lines.push(`## ${msg.role} (${formatDate(msg.createdAt)})\n`);
          lines.push(msg.content);
          lines.push('\n---\n');
        }

        output = lines.join('\n');
      }

      if (options.output) {
        const fs = require('fs');
        fs.writeFileSync(options.output, output);
        console.log(`Exported to: ${options.output}`);
      } else {
        console.log(output);
      }
    });

  /**
   * Summarize a session
   */
  program
    .command('session-summarize <sessionId>')
    .description('Generate a summary of a session')
    .option('-p, --project <name>', 'Project name (default: active)')
    .action(async (sessionId, options) => {
      const service = await getService();

      console.log('Generating summary...');
      const summary = await service.summarizeSession({
        project: options.project,
        session: sessionId
      });

      console.log('\nSummary:');
      console.log(summary.summary);

      if (summary.decisions?.length > 0) {
        console.log('\nDecisions identified:');
        for (const decision of summary.decisions) {
          console.log(`  - ${decision}`);
        }
      }
    });
}
```

### 2. Entity Commands

```typescript
// src/cli/commands/entities.ts

import { Command } from 'commander';
import { CoreService } from '../../core/service';
import { formatTable, truncate } from '../formatters';

export function registerEntityCommands(program: Command, getService: () => Promise<CoreService>) {

  /**
   * List entities
   */
  program
    .command('entities')
    .description('List entities in the project')
    .option('-p, --project <name>', 'Project name (default: active)')
    .option('-t, --type <type>', 'Filter by type (function/class/method/file/...)')
    .option('-q, --query <text>', 'Search by name or content')
    .option('-l, --limit <n>', 'Max entities to show', '50')
    .option('--json', 'Output as JSON')
    .action(async (options) => {
      const service = await getService();

      const entities = await service.listEntities({
        project: options.project,
        type: options.type,
        query: options.query,
        limit: parseInt(options.limit)
      });

      if (options.json) {
        console.log(JSON.stringify(entities, null, 2));
        return;
      }

      if (entities.length === 0) {
        console.log('No entities found.');
        return;
      }

      console.log(formatTable(entities, [
        { header: 'ID', key: 'id', width: 12 },
        { header: 'Type', key: 'type', width: 12 },
        { header: 'Name', key: 'name', width: 30 },
        { header: 'File', key: 'metadata.filePath', format: (p) => p?.split('/').pop() || '-', width: 25 },
        { header: 'Line', key: 'metadata.startLine', width: 6 },
        { header: 'Content', key: 'content', format: (c) => truncate(c, 30), width: 32 }
      ]));

      console.log(`\nTotal: ${entities.length} entity/ies`);
    });

  /**
   * View a single entity with full details
   */
  program
    .command('entity <idOrName>')
    .description('View entity details')
    .option('-p, --project <name>', 'Project name (default: active)')
    .option('--json', 'Output as JSON')
    .option('--with-relationships', 'Include relationships')
    .action(async (idOrName, options) => {
      const service = await getService();

      const entity = await service.getEntity({
        project: options.project,
        id: idOrName
      });

      if (!entity) {
        console.error(`Entity not found: ${idOrName}`);
        process.exit(1);
      }

      if (options.json) {
        console.log(JSON.stringify(entity, null, 2));
        return;
      }

      console.log(`\x1b[1m${entity.type}: ${entity.name}\x1b[0m`);
      console.log(`ID: ${entity.id}`);
      console.log(`Qualified Name: ${entity.qualifiedName}`);

      if (entity.metadata?.filePath) {
        console.log(`Location: ${entity.metadata.filePath}:${entity.metadata.startLine || '?'}`);
      }

      if (entity.summary) {
        console.log(`\nSummary: ${entity.summary}`);
      }

      if (entity.content) {
        console.log(`\n\x1b[90m--- Content ---\x1b[0m`);
        console.log(entity.content);
        console.log(`\x1b[90m--- End ---\x1b[0m`);
      }

      if (options.withRelationships) {
        const graph = await service.queryGraph({
          project: options.project,
          entity: entity.id,
          depth: 1
        });

        if (graph.relationships.length > 0) {
          console.log(`\n\x1b[1mRelationships:\x1b[0m`);
          for (const rel of graph.relationships) {
            const direction = rel.source === entity.id ? '→' : '←';
            const other = rel.source === entity.id ? rel.target : rel.source;
            console.log(`  ${direction} ${rel.type}: ${other}`);
          }
        }
      }
    });

  /**
   * Delete an entity
   */
  program
    .command('entity-delete <idOrName>')
    .description('Delete an entity')
    .option('-p, --project <name>', 'Project name (default: active)')
    .option('-f, --force', 'Skip confirmation')
    .action(async (idOrName, options) => {
      const service = await getService();

      const entity = await service.getEntity({
        project: options.project,
        id: idOrName
      });

      if (!entity) {
        console.error(`Entity not found: ${idOrName}`);
        process.exit(1);
      }

      if (!options.force) {
        console.log(`Entity: ${entity.type} ${entity.name}`);
        console.log(`ID: ${entity.id}`);

        const readline = require('readline');
        const rl = readline.createInterface({
          input: process.stdin,
          output: process.stdout
        });

        const answer = await new Promise<string>(resolve => {
          rl.question('Delete this entity? (y/N) ', resolve);
        });
        rl.close();

        if (answer.toLowerCase() !== 'y') {
          console.log('Cancelled.');
          return;
        }
      }

      await service.deleteEntity(entity.id, options.project);
      console.log(`Deleted entity: ${entity.id}`);
    });

  /**
   * Entity statistics by type
   */
  program
    .command('entity-stats')
    .description('Show entity statistics')
    .option('-p, --project <name>', 'Project name (default: active)')
    .action(async (options) => {
      const service = await getService();

      const stats = await service.getEntityStats(options.project);

      console.log('\x1b[1mEntity Statistics\x1b[0m\n');

      console.log(formatTable(stats.byType, [
        { header: 'Type', key: 'type', width: 15 },
        { header: 'Count', key: 'count', width: 10 },
        { header: 'With Embeddings', key: 'withEmbeddings', width: 18 }
      ]));

      console.log(`\nTotal entities: ${stats.total}`);
      console.log(`With embeddings: ${stats.withEmbeddings} (${Math.round(stats.withEmbeddings / stats.total * 100)}%)`);
    });
}
```

### 3. Graph Commands

```typescript
// src/cli/commands/graph.ts

import { Command } from 'commander';
import { CoreService } from '../../core/service';

export function registerGraphCommands(program: Command, getService: () => Promise<CoreService>) {

  /**
   * Query the graph from an entity
   */
  program
    .command('graph <entity>')
    .description('Query relationships from an entity')
    .option('-p, --project <name>', 'Project name (default: active)')
    .option('-d, --depth <n>', 'Traversal depth', '2')
    .option('-t, --types <types>', 'Filter relationship types (comma-separated)')
    .option('--direction <dir>', 'Direction: in, out, or both', 'both')
    .option('--json', 'Output as JSON')
    .option('--dot', 'Output as GraphViz DOT format')
    .action(async (entity, options) => {
      const service = await getService();

      const result = await service.queryGraph({
        project: options.project,
        entity,
        depth: parseInt(options.depth),
        relationships: options.types?.split(','),
        direction: options.direction
      });

      if (options.json) {
        console.log(JSON.stringify(result, null, 2));
        return;
      }

      if (options.dot) {
        console.log(generateDot(entity, result));
        return;
      }

      // Default: tree-like output
      console.log(`\x1b[1mGraph from: ${entity}\x1b[0m\n`);

      if (result.entities.length === 0) {
        console.log('No connected entities found.');
        return;
      }

      // Group by relationship type
      const byType = new Map<string, typeof result.relationships>();
      for (const rel of result.relationships) {
        const list = byType.get(rel.type) || [];
        list.push(rel);
        byType.set(rel.type, list);
      }

      for (const [type, rels] of byType) {
        console.log(`\x1b[36m${type}\x1b[0m (${rels.length})`);
        for (const rel of rels.slice(0, 20)) {
          const direction = rel.source === entity ? '→' : '←';
          const other = rel.source === entity ? rel.target : rel.source;
          const weight = rel.weight ? ` (${rel.weight.toFixed(2)})` : '';
          console.log(`  ${direction} ${other}${weight}`);
        }
        if (rels.length > 20) {
          console.log(`  ... and ${rels.length - 20} more`);
        }
      }

      console.log(`\nTotal: ${result.entities.length} entities, ${result.relationships.length} relationships`);
    });

  /**
   * Graph statistics
   */
  program
    .command('graph-stats')
    .description('Show graph statistics')
    .option('-p, --project <name>', 'Project name (default: active)')
    .action(async (options) => {
      const service = await getService();

      const stats = await service.getGraphStats(options.project);

      console.log('\x1b[1mGraph Statistics\x1b[0m\n');
      console.log(`Total nodes: ${stats.nodeCount}`);
      console.log(`Total edges: ${stats.edgeCount}`);
      console.log(`Avg connections per node: ${stats.avgDegree.toFixed(2)}`);

      if (stats.byRelationType) {
        console.log('\nRelationships by type:');
        for (const [type, count] of Object.entries(stats.byRelationType)) {
          console.log(`  ${type}: ${count}`);
        }
      }

      if (stats.mostConnected) {
        console.log('\nMost connected entities:');
        for (const entity of stats.mostConnected.slice(0, 10)) {
          console.log(`  ${entity.name} (${entity.type}): ${entity.connections} connections`);
        }
      }
    });

  /**
   * List relationships
   */
  program
    .command('relationships')
    .description('List relationships')
    .option('-p, --project <name>', 'Project name (default: active)')
    .option('-t, --type <type>', 'Filter by relationship type')
    .option('-s, --source <entity>', 'Filter by source entity')
    .option('-l, --limit <n>', 'Max relationships to show', '50')
    .option('--json', 'Output as JSON')
    .action(async (options) => {
      const service = await getService();

      const relationships = await service.listRelationships({
        project: options.project,
        type: options.type,
        source: options.source,
        limit: parseInt(options.limit)
      });

      if (options.json) {
        console.log(JSON.stringify(relationships, null, 2));
        return;
      }

      if (relationships.length === 0) {
        console.log('No relationships found.');
        return;
      }

      for (const rel of relationships) {
        console.log(`${rel.source} \x1b[36m--${rel.type}-->\x1b[0m ${rel.target}`);
      }

      console.log(`\nTotal: ${relationships.length} relationship(s)`);
    });

  /**
   * Add a relationship manually
   */
  program
    .command('link')
    .description('Create a relationship between entities')
    .requiredOption('-s, --source <entity>', 'Source entity ID or name')
    .requiredOption('-t, --target <entity>', 'Target entity ID or name')
    .requiredOption('--type <type>', 'Relationship type (calls/imports/extends/...)')
    .option('-p, --project <name>', 'Project name (default: active)')
    .option('-w, --weight <n>', 'Relationship weight 0-1', '1.0')
    .action(async (options) => {
      const service = await getService();

      await service.linkEntities({
        project: options.project,
        source: options.source,
        target: options.target,
        type: options.type,
        weight: parseFloat(options.weight)
      });

      console.log(`Created relationship: ${options.source} --${options.type}--> ${options.target}`);
    });
}

function generateDot(root: string, result: GraphResult): string {
  const lines = ['digraph G {', '  rankdir=LR;', '  node [shape=box];'];

  // Add nodes
  for (const entity of result.entities) {
    const label = entity.name.replace(/"/g, '\\"');
    const color = entity.id === root ? 'lightblue' : 'white';
    lines.push(`  "${entity.id}" [label="${label}" fillcolor="${color}" style="filled"];`);
  }

  // Add edges
  for (const rel of result.relationships) {
    lines.push(`  "${rel.source}" -> "${rel.target}" [label="${rel.type}"];`);
  }

  lines.push('}');
  return lines.join('\n');
}
```

### 4. Embedding Commands

```typescript
// src/cli/commands/embeddings.ts

import { Command } from 'commander';
import { CoreService } from '../../core/service';

export function registerEmbeddingCommands(program: Command, getService: () => Promise<CoreService>) {

  /**
   * Generate embeddings
   */
  program
    .command('embed')
    .description('Generate embeddings for entities')
    .option('-p, --project <name>', 'Project name (default: active)')
    .option('--force', 'Re-embed all entities (ignore cache)')
    .option('--batch-size <n>', 'Batch size for embedding', '50')
    .option('--type <type>', 'Only embed entities of this type')
    .action(async (options) => {
      const service = await getService();

      console.log('Generating embeddings...');

      const result = await service.generateEmbeddings({
        project: options.project,
        force: options.force,
        batchSize: parseInt(options.batchSize),
        type: options.type,
        onProgress: (completed, total, skipped) => {
          process.stdout.write(`\rProgress: ${completed}/${total} (${skipped} skipped)  `);
        }
      });

      console.log('\n');
      console.log(`Embedded: ${result.embedded}`);
      console.log(`Skipped (unchanged): ${result.skipped}`);
      console.log(`Total: ${result.total}`);
    });

  /**
   * Embedding status
   */
  program
    .command('embed-status')
    .description('Show embedding statistics')
    .option('-p, --project <name>', 'Project name (default: active)')
    .action(async (options) => {
      const service = await getService();

      const stats = await service.getEmbeddingStats(options.project);

      console.log('\x1b[1mEmbedding Statistics\x1b[0m\n');
      console.log(`Model: ${stats.modelId}`);
      console.log(`Dimensions: ${stats.dimensions}`);
      console.log(`Total embeddings: ${stats.count}`);
      console.log(`Entities without embeddings: ${stats.missing}`);
      console.log(`Coverage: ${((stats.count / (stats.count + stats.missing)) * 100).toFixed(1)}%`);
    });

  /**
   * Clean up orphaned embeddings
   */
  program
    .command('embed-cleanup')
    .description('Remove embeddings for deleted entities')
    .option('-p, --project <name>', 'Project name (default: active)')
    .option('--dry-run', 'Show what would be deleted without deleting')
    .action(async (options) => {
      const service = await getService();

      const result = await service.cleanupEmbeddings({
        project: options.project,
        dryRun: options.dryRun
      });

      if (options.dryRun) {
        console.log(`Would remove ${result.orphaned} orphaned embedding(s)`);
      } else {
        console.log(`Removed ${result.removed} orphaned embedding(s)`);
      }
    });
}
```

### 5. Analytics Commands

```typescript
// src/cli/commands/analytics.ts

import { Command } from 'commander';
import { CoreService } from '../../core/service';

export function registerAnalyticsCommands(program: Command, getService: () => Promise<CoreService>) {

  /**
   * Show analytics
   */
  program
    .command('analytics')
    .description('Show usage analytics')
    .option('-p, --project <name>', 'Project name (default: active)')
    .option('--period <period>', 'Time period: day/week/month/all', 'week')
    .option('--json', 'Output as JSON')
    .action(async (options) => {
      const service = await getService();

      const stats = await service.getAnalytics({
        project: options.project,
        period: options.period
      });

      if (options.json) {
        console.log(JSON.stringify(stats, null, 2));
        return;
      }

      console.log('\x1b[1mUsage Analytics\x1b[0m\n');
      console.log(`Period: ${options.period}`);
      console.log(`Total queries: ${stats.totalQueries}`);
      console.log(`Tokens retrieved: ${stats.tokensRetrieved.toLocaleString()}`);
      console.log(`Tokens saved (vs full context): ${stats.tokensSaved.toLocaleString()}`);
      console.log(`Cost savings: $${stats.costSaved.toFixed(2)}`);
      console.log(`Average relevance score: ${(stats.averageRelevance * 100).toFixed(1)}%`);

      if (stats.topQueries?.length > 0) {
        console.log('\nTop queries:');
        for (const q of stats.topQueries.slice(0, 5)) {
          console.log(`  "${q.query}" (${q.count} times)`);
        }
      }
    });

  /**
   * Dashboard view
   */
  program
    .command('dashboard')
    .description('Show project dashboard')
    .option('-p, --project <name>', 'Project name (default: active)')
    .action(async (options) => {
      const service = await getService();

      const dashboard = await service.getDashboard(options.project);

      console.log('\x1b[1m=== ctx-sys Dashboard ===\x1b[0m\n');

      // Project info
      console.log(`\x1b[36mProject:\x1b[0m ${dashboard.project.name}`);
      console.log(`Path: ${dashboard.project.path}`);
      console.log(`Last indexed: ${dashboard.project.lastIndexedAt || 'Never'}`);
      console.log('');

      // Entity stats
      console.log(`\x1b[36mEntities:\x1b[0m ${dashboard.stats.entities} total`);
      for (const [type, count] of Object.entries(dashboard.stats.byType)) {
        console.log(`  ${type}: ${count}`);
      }
      console.log('');

      // Embedding stats
      console.log(`\x1b[36mEmbeddings:\x1b[0m ${dashboard.stats.embeddings} / ${dashboard.stats.entities}`);
      console.log('');

      // Session stats
      console.log(`\x1b[36mSessions:\x1b[0m ${dashboard.stats.sessions}`);
      console.log(`Messages: ${dashboard.stats.messages}`);
      console.log('');

      // Recent activity
      if (dashboard.recentQueries?.length > 0) {
        console.log(`\x1b[36mRecent Queries:\x1b[0m`);
        for (const q of dashboard.recentQueries.slice(0, 5)) {
          console.log(`  ${q.query} (${q.resultCount} results)`);
        }
      }
    });
}
```

### 6. Debug/Inspect Commands

```typescript
// src/cli/commands/debug.ts

import { Command } from 'commander';
import { CoreService } from '../../core/service';

export function registerDebugCommands(program: Command, getService: () => Promise<CoreService>) {

  /**
   * Inspect database tables
   */
  program
    .command('inspect')
    .description('Inspect database tables')
    .option('-p, --project <name>', 'Project name (default: active)')
    .option('-t, --table <name>', 'Table name to inspect')
    .option('-l, --limit <n>', 'Row limit', '10')
    .action(async (options) => {
      const service = await getService();

      if (options.table) {
        const rows = await service.inspectTable({
          project: options.project,
          table: options.table,
          limit: parseInt(options.limit)
        });

        console.log(JSON.stringify(rows, null, 2));
      } else {
        const tables = await service.listTables(options.project);

        console.log('\x1b[1mDatabase Tables\x1b[0m\n');
        for (const table of tables) {
          console.log(`  ${table.name} (${table.rowCount} rows)`);
        }
      }
    });

  /**
   * Run raw SQL query (read-only)
   */
  program
    .command('query <sql>')
    .description('Run a read-only SQL query')
    .option('-p, --project <name>', 'Project name (default: active)')
    .option('--json', 'Output as JSON')
    .action(async (sql, options) => {
      const service = await getService();

      // Safety check: only allow SELECT
      if (!sql.trim().toLowerCase().startsWith('select')) {
        console.error('Only SELECT queries are allowed');
        process.exit(1);
      }

      const results = await service.query(sql, options.project);

      if (options.json) {
        console.log(JSON.stringify(results, null, 2));
      } else {
        console.table(results);
      }
    });

  /**
   * Export project data
   */
  program
    .command('export')
    .description('Export project data to JSON')
    .option('-p, --project <name>', 'Project name (default: active)')
    .option('-o, --output <file>', 'Output file', 'ctx-sys-export.json')
    .option('--include <types>', 'Include: entities,sessions,graph,all', 'all')
    .action(async (options) => {
      const service = await getService();

      console.log('Exporting project data...');

      const data = await service.exportProject({
        project: options.project,
        include: options.include.split(',')
      });

      const fs = require('fs');
      fs.writeFileSync(options.output, JSON.stringify(data, null, 2));

      console.log(`Exported to: ${options.output}`);
      console.log(`  Entities: ${data.entities?.length || 0}`);
      console.log(`  Sessions: ${data.sessions?.length || 0}`);
      console.log(`  Relationships: ${data.relationships?.length || 0}`);
    });

  /**
   * Import project data
   */
  program
    .command('import <file>')
    .description('Import project data from JSON')
    .option('-p, --project <name>', 'Project name (default: active)')
    .option('--merge', 'Merge with existing data (default: replace)')
    .action(async (file, options) => {
      const service = await getService();

      const fs = require('fs');
      const data = JSON.parse(fs.readFileSync(file, 'utf-8'));

      console.log('Importing project data...');

      const result = await service.importProject({
        project: options.project,
        data,
        merge: options.merge
      });

      console.log(`Imported from: ${file}`);
      console.log(`  Entities: ${result.entities}`);
      console.log(`  Sessions: ${result.sessions}`);
      console.log(`  Relationships: ${result.relationships}`);
    });

  /**
   * Health check
   */
  program
    .command('health')
    .description('Check system health')
    .action(async () => {
      const service = await getService();

      const health = await service.healthCheck();

      console.log('\x1b[1mSystem Health\x1b[0m\n');

      const status = (ok: boolean) => ok ? '\x1b[32m✓\x1b[0m' : '\x1b[31m✗\x1b[0m';

      console.log(`${status(health.database)} Database: ${health.database ? 'Connected' : 'Error'}`);
      console.log(`${status(health.ollama)} Ollama: ${health.ollama ? 'Available' : 'Not available'}`);
      console.log(`${status(health.project)} Active project: ${health.project || 'None'}`);

      if (health.errors?.length > 0) {
        console.log('\nErrors:');
        for (const err of health.errors) {
          console.log(`  - ${err}`);
        }
      }
    });
}
```

### 7. Main CLI Registration

```typescript
// src/cli/index.ts (updated)

import { Command } from 'commander';
import { registerConversationCommands } from './commands/conversations';
import { registerEntityCommands } from './commands/entities';
import { registerGraphCommands } from './commands/graph';
import { registerEmbeddingCommands } from './commands/embeddings';
import { registerAnalyticsCommands } from './commands/analytics';
import { registerDebugCommands } from './commands/debug';

const program = new Command();

program
  .name('ctx-sys')
  .version('0.1.0')
  .description('Context management system for AI coding assistants');

// Existing commands
program.command('init').description('Initialize a new project');
program.command('index').description('Index the codebase');
program.command('search').description('Search entities');
program.command('status').description('Show project status');
program.command('config').description('View/set configuration');
program.command('serve').description('Start MCP server');
program.command('watch').description('Watch for file changes');

// New command groups
registerConversationCommands(program, getService);
registerEntityCommands(program, getService);
registerGraphCommands(program, getService);
registerEmbeddingCommands(program, getService);
registerAnalyticsCommands(program, getService);
registerDebugCommands(program, getService);

program.parse();
```

## Command Reference

### Conversations

| Command | Description |
|---------|-------------|
| `ctx-sys sessions` | List all conversation sessions |
| `ctx-sys messages [sessionId]` | View messages in a session |
| `ctx-sys message-add -c "text" -r user` | Add a message manually |
| `ctx-sys session-delete <id>` | Delete a session |
| `ctx-sys session-export <id>` | Export session to JSON/markdown |
| `ctx-sys session-summarize <id>` | Generate session summary |

### Entities

| Command | Description |
|---------|-------------|
| `ctx-sys entities` | List all entities |
| `ctx-sys entities -t function` | List functions only |
| `ctx-sys entity <id>` | View entity details |
| `ctx-sys entity-delete <id>` | Delete an entity |
| `ctx-sys entity-stats` | Show entity statistics |

### Graph

| Command | Description |
|---------|-------------|
| `ctx-sys graph <entity>` | Query graph from entity |
| `ctx-sys graph <entity> --dot` | Export as GraphViz DOT |
| `ctx-sys graph-stats` | Show graph statistics |
| `ctx-sys relationships` | List all relationships |
| `ctx-sys link -s A -t B --type calls` | Create relationship |

### Embeddings

| Command | Description |
|---------|-------------|
| `ctx-sys embed` | Generate embeddings |
| `ctx-sys embed --force` | Re-embed all entities |
| `ctx-sys embed-status` | Show embedding stats |
| `ctx-sys embed-cleanup` | Remove orphaned embeddings |

### Analytics

| Command | Description |
|---------|-------------|
| `ctx-sys analytics` | Show usage analytics |
| `ctx-sys dashboard` | Show project dashboard |

### Debug

| Command | Description |
|---------|-------------|
| `ctx-sys inspect` | List database tables |
| `ctx-sys inspect -t entities` | Inspect specific table |
| `ctx-sys query "SELECT ..."` | Run read-only SQL |
| `ctx-sys export` | Export project to JSON |
| `ctx-sys import <file>` | Import from JSON |
| `ctx-sys health` | Check system health |

## Output Formats

All commands support multiple output formats:

```bash
# Default: Human-readable tables/text
ctx-sys entities

# JSON for scripting
ctx-sys entities --json

# GraphViz DOT for visualization
ctx-sys graph myFunction --dot > graph.dot
dot -Tpng graph.dot -o graph.png
```

## Testing

```typescript
describe('CLI Completeness', () => {
  it('lists sessions', async () => {
    const result = execSync('ctx-sys sessions --json');
    const sessions = JSON.parse(result.toString());
    expect(Array.isArray(sessions)).toBe(true);
  });

  it('shows entity details', async () => {
    // First create an entity
    execSync('ctx-sys index .');

    const result = execSync('ctx-sys entity processPayment --json');
    const entity = JSON.parse(result.toString());

    expect(entity.name).toBe('processPayment');
    expect(entity.type).toBe('function');
  });

  it('exports and imports project', async () => {
    execSync('ctx-sys export -o /tmp/test-export.json');
    execSync('ctx-sys import /tmp/test-export.json --merge');
    // Verify data is intact
  });

  it('queries graph', async () => {
    const result = execSync('ctx-sys graph MyClass --depth 2 --json');
    const graph = JSON.parse(result.toString());

    expect(graph.entities).toBeDefined();
    expect(graph.relationships).toBeDefined();
  });
});
```

## Success Metrics

| Metric | Target |
|--------|--------|
| CLI command coverage | 100% of MCP tools have CLI equivalent |
| Help documentation | All commands have --help with examples |
| JSON output | All commands support --json |
| Error messages | Clear, actionable error messages |

## Dependencies

- F10.0: CoreService (unified API layer)

## Next Steps

1. Create CLI command files for each domain
2. Add formatters for table/tree output
3. Add --json flag to all commands
4. Add bash/zsh completion support
5. Create man pages / comprehensive --help
