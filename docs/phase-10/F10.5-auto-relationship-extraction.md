# F10.5: Automatic Relationship Extraction

## Goal

Automatically extract code relationships (function calls, imports, inheritance, type usage) during indexing to populate the graph database. Currently, relationships must be manually added via `link_entities`.

## Current Limitation

```typescript
// Current: Manual relationship creation
await linkEntities({
  source: 'processPayment',
  target: 'chargeCard',
  type: 'calls'
});

// Problem: Nobody does this manually for 100k+ entities
// Result: Graph is empty, graph-based search returns nothing
```

## Solution Overview

Extract relationships automatically from AST during parsing for **all languages supported by the AST parser** (TypeScript, JavaScript, Python, and any future languages):

1. **Import/Export relationships** - file → file dependencies
2. **Function calls** - function → function calls
3. **Type references** - function → type usage (where applicable)
4. **Class inheritance** - class → class extends/implements
5. **Method invocations** - method → method within class

### Multi-Language Support

The extractor uses a **language-agnostic interface** with language-specific implementations that leverage tree-sitter's consistent AST structure:

| Language | Imports | Calls | Inheritance | Type Refs |
|----------|---------|-------|-------------|-----------|
| TypeScript | ✅ import/export | ✅ | ✅ extends/implements | ✅ |
| JavaScript | ✅ import/require | ✅ | ✅ extends | N/A |
| Python | ✅ import/from | ✅ | ✅ class inheritance | ✅ type hints |

## Architecture

### Relationship Types

```typescript
type RelationshipType =
  | 'imports'      // File imports from another file
  | 'exports'      // File exports a symbol
  | 'calls'        // Function/method calls another
  | 'extends'      // Class extends another class
  | 'implements'   // Class implements interface
  | 'uses_type'    // Function uses a type
  | 'contains'     // Class contains method/property
  | 'instantiates' // Code creates instance of class
  | 'references'   // General reference to symbol
```

### Extraction Pipeline

```
AST Parse Result
    │
    ├── Import Analysis
    │   └── imports relationships
    │
    ├── Symbol Analysis
    │   ├── extends/implements relationships
    │   └── contains relationships
    │
    ├── Call Graph Analysis
    │   └── calls relationships
    │
    └── Type Reference Analysis
        └── uses_type relationships
```

## Implementation

### 1. Relationship Extractor Interface

```typescript
// src/ast/relationships/types.ts

export interface ExtractedRelationship {
  /** Source symbol name or qualified name */
  source: string;
  sourceType: EntityType;

  /** Target symbol name or qualified name */
  target: string;
  targetType?: EntityType;

  /** Relationship type */
  type: RelationshipType;

  /** Relationship weight (0-1) */
  weight?: number;

  /** Additional metadata */
  metadata?: {
    line?: number;
    isOptional?: boolean;
    isDynamic?: boolean;
  };
}

export interface RelationshipExtractor {
  /**
   * Extract relationships from a parse result.
   */
  extract(parseResult: ParseResult): ExtractedRelationship[];
}
```

### 2. Language Extractor Registry

```typescript
// src/ast/relationships/registry.ts

import { RelationshipExtractor } from './types';
import { TypeScriptRelationshipExtractor } from './typescript-extractor';
import { PythonRelationshipExtractor } from './python-extractor';
import { JavaScriptRelationshipExtractor } from './javascript-extractor';

/**
 * Registry of language-specific relationship extractors.
 * Automatically selects the right extractor based on file extension/language.
 */
export class RelationshipExtractorRegistry {
  private extractors: Map<string, RelationshipExtractor> = new Map();

  constructor() {
    // Register all language extractors
    const tsExtractor = new TypeScriptRelationshipExtractor();
    const jsExtractor = new JavaScriptRelationshipExtractor();
    const pyExtractor = new PythonRelationshipExtractor();

    // TypeScript
    this.extractors.set('typescript', tsExtractor);
    this.extractors.set('tsx', tsExtractor);
    this.extractors.set('.ts', tsExtractor);
    this.extractors.set('.tsx', tsExtractor);

    // JavaScript
    this.extractors.set('javascript', jsExtractor);
    this.extractors.set('jsx', jsExtractor);
    this.extractors.set('.js', jsExtractor);
    this.extractors.set('.jsx', jsExtractor);
    this.extractors.set('.mjs', jsExtractor);
    this.extractors.set('.cjs', jsExtractor);

    // Python
    this.extractors.set('python', pyExtractor);
    this.extractors.set('.py', pyExtractor);
  }

  /**
   * Get extractor for a given language or file extension.
   */
  getExtractor(languageOrExt: string): RelationshipExtractor | null {
    return this.extractors.get(languageOrExt.toLowerCase()) || null;
  }

  /**
   * Check if we support relationship extraction for this language.
   */
  supportsLanguage(languageOrExt: string): boolean {
    return this.extractors.has(languageOrExt.toLowerCase());
  }

  /**
   * Get all supported languages.
   */
  getSupportedLanguages(): string[] {
    return ['typescript', 'javascript', 'python'];
  }
}
```

### 3. TypeScript Relationship Extractor

```typescript
// src/ast/relationships/typescript-extractor.ts

import { SyntaxNode } from 'tree-sitter';
import { ParseResult, Symbol } from '../types';
import { ExtractedRelationship, RelationshipExtractor } from './types';

export class TypeScriptRelationshipExtractor implements RelationshipExtractor {
  extract(parseResult: ParseResult): ExtractedRelationship[] {
    const relationships: ExtractedRelationship[] = [];

    // 1. Extract import relationships
    relationships.push(...this.extractImports(parseResult));

    // 2. Extract class relationships (extends, implements)
    relationships.push(...this.extractClassRelationships(parseResult));

    // 3. Extract call relationships
    relationships.push(...this.extractCallGraph(parseResult));

    // 4. Extract type usage
    relationships.push(...this.extractTypeReferences(parseResult));

    return relationships;
  }

  /**
   * Extract import relationships from file.
   */
  private extractImports(parseResult: ParseResult): ExtractedRelationship[] {
    const relationships: ExtractedRelationship[] = [];

    for (const imp of parseResult.imports) {
      // File-level import
      relationships.push({
        source: parseResult.filePath,
        sourceType: 'file',
        target: imp.source,
        targetType: 'file',
        type: 'imports',
        weight: 1.0,
        metadata: { line: imp.line }
      });

      // Named imports create references
      for (const name of imp.names) {
        relationships.push({
          source: parseResult.filePath,
          sourceType: 'file',
          target: name,
          type: 'references',
          weight: 0.8
        });
      }
    }

    return relationships;
  }

  /**
   * Extract class inheritance and interface implementation.
   */
  private extractClassRelationships(parseResult: ParseResult): ExtractedRelationship[] {
    const relationships: ExtractedRelationship[] = [];

    const processSymbol = (symbol: Symbol): void => {
      if (symbol.type === 'class') {
        // Check for extends clause
        if (symbol.extends) {
          relationships.push({
            source: symbol.qualifiedName,
            sourceType: 'class',
            target: symbol.extends,
            targetType: 'class',
            type: 'extends',
            weight: 1.0
          });
        }

        // Check for implements clause
        if (symbol.implements) {
          for (const iface of symbol.implements) {
            relationships.push({
              source: symbol.qualifiedName,
              sourceType: 'class',
              target: iface,
              targetType: 'interface',
              type: 'implements',
              weight: 1.0
            });
          }
        }

        // Methods/properties are contained by class
        for (const child of symbol.children || []) {
          relationships.push({
            source: symbol.qualifiedName,
            sourceType: 'class',
            target: child.qualifiedName,
            targetType: child.type as EntityType,
            type: 'contains',
            weight: 1.0
          });
        }
      }

      // Recurse into children
      for (const child of symbol.children || []) {
        processSymbol(child);
      }
    };

    for (const symbol of parseResult.symbols) {
      processSymbol(symbol);
    }

    return relationships;
  }

  /**
   * Extract function call relationships by analyzing AST.
   */
  private extractCallGraph(parseResult: ParseResult): ExtractedRelationship[] {
    const relationships: ExtractedRelationship[] = [];
    const tree = parseResult.tree;

    if (!tree) return relationships;

    // Find all function/method definitions and their call sites
    const functionBodies = new Map<string, SyntaxNode>();

    const collectFunctions = (symbol: Symbol): void => {
      if (symbol.type === 'function' || symbol.type === 'method') {
        // Get the AST node for this function
        const node = this.findNodeAtPosition(tree.rootNode, symbol.startLine);
        if (node) {
          functionBodies.set(symbol.qualifiedName, node);
        }
      }

      for (const child of symbol.children || []) {
        collectFunctions(child);
      }
    };

    for (const symbol of parseResult.symbols) {
      collectFunctions(symbol);
    }

    // For each function, find call expressions
    for (const [funcName, node] of functionBodies) {
      const calls = this.findCallExpressions(node);

      for (const call of calls) {
        relationships.push({
          source: funcName,
          sourceType: 'function',
          target: call.name,
          type: 'calls',
          weight: 0.9,
          metadata: {
            line: call.line,
            isDynamic: call.isDynamic
          }
        });
      }
    }

    return relationships;
  }

  /**
   * Find all call expressions within a node.
   */
  private findCallExpressions(node: SyntaxNode): CallInfo[] {
    const calls: CallInfo[] = [];

    const visit = (n: SyntaxNode): void => {
      if (n.type === 'call_expression') {
        const callee = n.childForFieldName('function');
        if (callee) {
          const name = this.extractCalleeName(callee);
          if (name) {
            calls.push({
              name,
              line: n.startPosition.row + 1,
              isDynamic: callee.type === 'member_expression'
            });
          }
        }
      }

      for (const child of n.children) {
        visit(child);
      }
    };

    visit(node);
    return calls;
  }

  /**
   * Extract the name from a callee node.
   */
  private extractCalleeName(node: SyntaxNode): string | null {
    if (node.type === 'identifier') {
      return node.text;
    }

    if (node.type === 'member_expression') {
      const property = node.childForFieldName('property');
      const object = node.childForFieldName('object');

      if (property?.type === 'property_identifier') {
        // For this.method() or obj.method()
        if (object?.type === 'this') {
          return `this.${property.text}`;
        }
        if (object?.type === 'identifier') {
          return `${object.text}.${property.text}`;
        }
        return property.text;
      }
    }

    return null;
  }

  /**
   * Extract type references from function signatures.
   */
  private extractTypeReferences(parseResult: ParseResult): ExtractedRelationship[] {
    const relationships: ExtractedRelationship[] = [];

    const processSymbol = (symbol: Symbol): void => {
      // Parameter types
      for (const param of symbol.parameters || []) {
        if (param.type && !this.isPrimitiveType(param.type)) {
          relationships.push({
            source: symbol.qualifiedName,
            sourceType: symbol.type as EntityType,
            target: this.normalizeTypeName(param.type),
            targetType: 'type',
            type: 'uses_type',
            weight: 0.7
          });
        }
      }

      // Return type
      if (symbol.returnType && !this.isPrimitiveType(symbol.returnType)) {
        relationships.push({
          source: symbol.qualifiedName,
          sourceType: symbol.type as EntityType,
          target: this.normalizeTypeName(symbol.returnType),
          targetType: 'type',
          type: 'uses_type',
          weight: 0.7
        });
      }

      // Recurse
      for (const child of symbol.children || []) {
        processSymbol(child);
      }
    };

    for (const symbol of parseResult.symbols) {
      processSymbol(symbol);
    }

    return relationships;
  }

  private isPrimitiveType(type: string): boolean {
    const primitives = [
      'string', 'number', 'boolean', 'void', 'null', 'undefined',
      'any', 'never', 'unknown', 'object', 'symbol', 'bigint'
    ];
    return primitives.includes(type.toLowerCase());
  }

  private normalizeTypeName(type: string): string {
    // Remove generics: Promise<User> → Promise
    // Remove arrays: User[] → User
    // Remove unions: User | null → User
    return type
      .replace(/<[^>]+>/g, '')
      .replace(/\[\]/g, '')
      .split('|')[0]
      .trim();
  }

  private findNodeAtPosition(root: SyntaxNode, line: number): SyntaxNode | null {
    // Find the node that starts at the given line
    const visit = (node: SyntaxNode): SyntaxNode | null => {
      if (node.startPosition.row + 1 === line) {
        return node;
      }
      for (const child of node.children) {
        const result = visit(child);
        if (result) return result;
      }
      return null;
    };
    return visit(root);
  }
}

interface CallInfo {
  name: string;
  line: number;
  isDynamic: boolean;
}
```

### 4. Python Relationship Extractor

```typescript
// src/ast/relationships/python-extractor.ts

import { SyntaxNode } from 'tree-sitter';
import { ParseResult, Symbol } from '../types';
import { ExtractedRelationship, RelationshipExtractor } from './types';

export class PythonRelationshipExtractor implements RelationshipExtractor {
  extract(parseResult: ParseResult): ExtractedRelationship[] {
    const relationships: ExtractedRelationship[] = [];

    relationships.push(...this.extractImports(parseResult));
    relationships.push(...this.extractClassRelationships(parseResult));
    relationships.push(...this.extractCallGraph(parseResult));
    relationships.push(...this.extractTypeHints(parseResult));

    return relationships;
  }

  /**
   * Extract Python import statements.
   * Handles: import x, from x import y, from x import *
   */
  private extractImports(parseResult: ParseResult): ExtractedRelationship[] {
    const relationships: ExtractedRelationship[] = [];
    const tree = parseResult.tree;
    if (!tree) return relationships;

    const visit = (node: SyntaxNode): void => {
      // import module
      if (node.type === 'import_statement') {
        const names = node.descendantsOfType('dotted_name');
        for (const name of names) {
          relationships.push({
            source: parseResult.filePath,
            sourceType: 'file',
            target: name.text,
            targetType: 'module',
            type: 'imports',
            weight: 1.0,
            metadata: { line: node.startPosition.row + 1 }
          });
        }
      }

      // from module import name
      if (node.type === 'import_from_statement') {
        const module = node.childForFieldName('module_name');
        if (module) {
          relationships.push({
            source: parseResult.filePath,
            sourceType: 'file',
            target: module.text,
            targetType: 'module',
            type: 'imports',
            weight: 1.0,
            metadata: { line: node.startPosition.row + 1 }
          });
        }
      }

      for (const child of node.children) {
        visit(child);
      }
    };

    visit(tree.rootNode);
    return relationships;
  }

  /**
   * Extract class inheritance relationships.
   */
  private extractClassRelationships(parseResult: ParseResult): ExtractedRelationship[] {
    const relationships: ExtractedRelationship[] = [];

    const processSymbol = (symbol: Symbol): void => {
      if (symbol.type === 'class' && symbol.extends) {
        // Python supports multiple inheritance
        const bases = Array.isArray(symbol.extends) ? symbol.extends : [symbol.extends];
        for (const base of bases) {
          relationships.push({
            source: symbol.qualifiedName,
            sourceType: 'class',
            target: base,
            targetType: 'class',
            type: 'extends',
            weight: 1.0
          });
        }
      }

      for (const child of symbol.children || []) {
        processSymbol(child);
      }
    };

    for (const symbol of parseResult.symbols) {
      processSymbol(symbol);
    }

    return relationships;
  }

  /**
   * Extract function call relationships.
   */
  private extractCallGraph(parseResult: ParseResult): ExtractedRelationship[] {
    // Similar to TypeScript but with Python-specific node types:
    // - call: function calls
    // - attribute: method calls (obj.method())
    const relationships: ExtractedRelationship[] = [];
    // Implementation follows same pattern as TypeScript...
    return relationships;
  }

  /**
   * Extract type hint relationships (Python 3.5+).
   */
  private extractTypeHints(parseResult: ParseResult): ExtractedRelationship[] {
    const relationships: ExtractedRelationship[] = [];

    const processSymbol = (symbol: Symbol): void => {
      // Check parameter type hints
      for (const param of symbol.parameters || []) {
        if (param.type && !this.isPrimitiveType(param.type)) {
          relationships.push({
            source: symbol.qualifiedName,
            sourceType: symbol.type as EntityType,
            target: param.type,
            targetType: 'type',
            type: 'uses_type',
            weight: 0.7
          });
        }
      }

      // Check return type hint
      if (symbol.returnType && !this.isPrimitiveType(symbol.returnType)) {
        relationships.push({
          source: symbol.qualifiedName,
          sourceType: symbol.type as EntityType,
          target: symbol.returnType,
          targetType: 'type',
          type: 'uses_type',
          weight: 0.7
        });
      }

      for (const child of symbol.children || []) {
        processSymbol(child);
      }
    };

    for (const symbol of parseResult.symbols) {
      processSymbol(symbol);
    }

    return relationships;
  }

  private isPrimitiveType(type: string): boolean {
    const primitives = [
      'str', 'int', 'float', 'bool', 'None', 'bytes',
      'list', 'dict', 'set', 'tuple', 'Any', 'object'
    ];
    return primitives.includes(type);
  }
}
```

### 5. JavaScript Relationship Extractor

```typescript
// src/ast/relationships/javascript-extractor.ts

import { SyntaxNode } from 'tree-sitter';
import { ParseResult, Symbol } from '../types';
import { ExtractedRelationship, RelationshipExtractor } from './types';

export class JavaScriptRelationshipExtractor implements RelationshipExtractor {
  extract(parseResult: ParseResult): ExtractedRelationship[] {
    const relationships: ExtractedRelationship[] = [];

    relationships.push(...this.extractImports(parseResult));
    relationships.push(...this.extractClassRelationships(parseResult));
    relationships.push(...this.extractCallGraph(parseResult));

    return relationships;
  }

  /**
   * Extract JavaScript imports (ES6 and CommonJS).
   */
  private extractImports(parseResult: ParseResult): ExtractedRelationship[] {
    const relationships: ExtractedRelationship[] = [];
    const tree = parseResult.tree;
    if (!tree) return relationships;

    const visit = (node: SyntaxNode): void => {
      // ES6: import x from 'module'
      if (node.type === 'import_statement') {
        const source = node.childForFieldName('source');
        if (source) {
          const modulePath = source.text.replace(/['"]/g, '');
          relationships.push({
            source: parseResult.filePath,
            sourceType: 'file',
            target: modulePath,
            targetType: 'file',
            type: 'imports',
            weight: 1.0,
            metadata: { line: node.startPosition.row + 1 }
          });
        }
      }

      // CommonJS: require('module')
      if (node.type === 'call_expression') {
        const callee = node.childForFieldName('function');
        if (callee?.text === 'require') {
          const args = node.childForFieldName('arguments');
          const firstArg = args?.firstChild;
          if (firstArg?.type === 'string') {
            const modulePath = firstArg.text.replace(/['"]/g, '');
            relationships.push({
              source: parseResult.filePath,
              sourceType: 'file',
              target: modulePath,
              targetType: 'file',
              type: 'imports',
              weight: 1.0,
              metadata: { line: node.startPosition.row + 1 }
            });
          }
        }
      }

      for (const child of node.children) {
        visit(child);
      }
    };

    visit(tree.rootNode);
    return relationships;
  }

  /**
   * Extract ES6 class inheritance.
   */
  private extractClassRelationships(parseResult: ParseResult): ExtractedRelationship[] {
    const relationships: ExtractedRelationship[] = [];

    const processSymbol = (symbol: Symbol): void => {
      if (symbol.type === 'class' && symbol.extends) {
        relationships.push({
          source: symbol.qualifiedName,
          sourceType: 'class',
          target: symbol.extends,
          targetType: 'class',
          type: 'extends',
          weight: 1.0
        });
      }

      // Methods/properties are contained by class
      for (const child of symbol.children || []) {
        if (symbol.type === 'class') {
          relationships.push({
            source: symbol.qualifiedName,
            sourceType: 'class',
            target: child.qualifiedName,
            targetType: child.type as EntityType,
            type: 'contains',
            weight: 1.0
          });
        }
        processSymbol(child);
      }
    };

    for (const symbol of parseResult.symbols) {
      processSymbol(symbol);
    }

    return relationships;
  }

  /**
   * Extract function/method calls.
   */
  private extractCallGraph(parseResult: ParseResult): ExtractedRelationship[] {
    // Same pattern as TypeScript - JavaScript uses identical AST node types
    // for call_expression and member_expression
    const relationships: ExtractedRelationship[] = [];
    // Implementation follows TypeScript pattern...
    return relationships;
  }
}
```

### 6. Relationship Storage

```typescript
// src/graph/relationship-store.ts

import { DatabaseConnection } from '../db/connection';
import { ExtractedRelationship } from '../ast/relationships/types';

export class RelationshipStore {
  constructor(
    private db: DatabaseConnection,
    private tableName: string
  ) {}

  /**
   * Store extracted relationships, resolving entity references.
   */
  async storeRelationships(
    relationships: ExtractedRelationship[],
    entityResolver: EntityResolver
  ): Promise<StoreResult> {
    let stored = 0;
    let unresolved = 0;

    for (const rel of relationships) {
      // Try to resolve source and target to actual entity IDs
      const sourceId = await entityResolver.resolve(rel.source, rel.sourceType);
      const targetId = await entityResolver.resolve(rel.target, rel.targetType);

      if (!sourceId) {
        unresolved++;
        continue;
      }

      // Target might be external (e.g., npm package)
      // Still store with qualified name as target
      const targetValue = targetId || rel.target;

      this.db.run(
        `INSERT OR REPLACE INTO ${this.tableName}
         (id, source, target, type, weight, metadata, created_at)
         VALUES (?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)`,
        [
          generateId(),
          sourceId,
          targetValue,
          rel.type,
          rel.weight || 1.0,
          JSON.stringify(rel.metadata || {})
        ]
      );

      stored++;
    }

    return { stored, unresolved };
  }

  /**
   * Clear relationships for a file (before re-indexing).
   */
  async clearForFile(filePath: string): Promise<void> {
    // Delete relationships where source is from this file
    this.db.run(
      `DELETE FROM ${this.tableName}
       WHERE source IN (
         SELECT id FROM ${this.entitiesTable}
         WHERE json_extract(metadata, '$.filePath') = ?
       )`,
      [filePath]
    );
  }
}

interface StoreResult {
  stored: number;
  unresolved: number;
}

interface EntityResolver {
  resolve(name: string, type?: EntityType): Promise<string | null>;
}
```

### 7. Integrated Indexer

```typescript
// src/indexer/indexer.ts (updated)

import { TypeScriptRelationshipExtractor } from '../ast/relationships/typescript-extractor';

export class Indexer {
  private relationshipExtractor: TypeScriptRelationshipExtractor;

  async indexFile(filePath: string): Promise<IndexResult> {
    // Parse file
    const parseResult = await this.parser.parse(filePath);

    // Summarize symbols
    const summary = await this.summarizer.summarizeFile(parseResult);

    // Store entities (existing logic)
    await this.storeEntities(summary);

    // Extract and store relationships (NEW)
    const relationships = this.relationshipExtractor.extract(parseResult);
    const relResult = await this.relationshipStore.storeRelationships(
      relationships,
      this.entityResolver
    );

    return {
      entities: summary.symbols.length,
      relationships: relResult.stored,
      unresolvedRefs: relResult.unresolved
    };
  }
}
```

## Configuration

```yaml
# .ctx-sys/config.yaml
indexing:
  extract_relationships: true
  relationship_types:
    - imports
    - calls
    - extends
    - implements
    - contains
  max_call_depth: 3  # How deep to trace call chains
```

## CLI Commands

```bash
# Index with relationship extraction (default)
ctx-sys index .

# Show relationship statistics
ctx-sys graph-stats

# Query relationships for an entity
ctx-sys graph query "processPayment" --depth 2

# Export graph for visualization
ctx-sys graph export --format dot > graph.dot
```

## Testing

```typescript
describe('Relationship Extraction', () => {
  it('extracts import relationships', async () => {
    const source = `
      import { User } from './models/user';
      import { validateEmail } from './utils';
    `;

    const parseResult = await parser.parse('test.ts', source);
    const relationships = extractor.extract(parseResult);

    expect(relationships).toContainEqual(
      expect.objectContaining({
        source: 'test.ts',
        target: './models/user',
        type: 'imports'
      })
    );
  });

  it('extracts class inheritance', async () => {
    const source = `
      class AdminUser extends User implements Serializable {
        save() {}
      }
    `;

    const parseResult = await parser.parse('test.ts', source);
    const relationships = extractor.extract(parseResult);

    expect(relationships).toContainEqual(
      expect.objectContaining({
        source: 'test.ts::AdminUser',
        target: 'User',
        type: 'extends'
      })
    );

    expect(relationships).toContainEqual(
      expect.objectContaining({
        source: 'test.ts::AdminUser',
        target: 'Serializable',
        type: 'implements'
      })
    );
  });

  it('extracts function calls', async () => {
    const source = `
      function processOrder(order: Order) {
        validateOrder(order);
        const payment = createPayment(order.total);
        return finalizeOrder(order, payment);
      }
    `;

    const parseResult = await parser.parse('test.ts', source);
    const relationships = extractor.extract(parseResult);

    const calls = relationships.filter(r => r.type === 'calls');
    expect(calls).toHaveLength(3);
    expect(calls.map(c => c.target)).toEqual([
      'validateOrder',
      'createPayment',
      'finalizeOrder'
    ]);
  });
});
```

## Success Metrics

| Metric | Target |
|--------|--------|
| Import relationships extracted | 100% |
| Class inheritance extracted | 100% |
| Function calls extracted | >80% (some dynamic calls can't be statically analyzed) |
| Graph query latency | <50ms for 2-hop traversal |

## Dependencies

- Existing AST parsing infrastructure
- Graph traversal (already implemented)

## Risks & Mitigations

| Risk | Mitigation |
|------|------------|
| Dynamic calls not detected | Mark as "potential" relationship, lower weight |
| External dependencies unresolved | Store as qualified name, don't require entity ID |
| Too many relationships (noise) | Configurable relationship types, weight thresholds |
| Performance on large files | Limit call graph extraction depth |

## Next Steps

1. Implement RelationshipExtractorRegistry with language detection
2. Implement TypeScriptRelationshipExtractor
3. Implement PythonRelationshipExtractor
4. Implement JavaScriptRelationshipExtractor
5. Integrate with indexer (auto-detect language, use registry)
6. Add graph statistics CLI command
7. Test with real multi-language codebases
