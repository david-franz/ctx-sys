# F10.2: Incremental Embedding

## Goal

Only generate embeddings for new or changed entities, rather than re-embedding the entire codebase on each index run. This dramatically reduces indexing time and API costs.

## Current Limitation

```bash
# Every index run embeds everything
$ ctx-sys index . --embed
Indexing codebase...
Processing 2847 files...
Generating embeddings for 74123 entities...  # Even if only 10 changed!
# Takes 30+ minutes, uses 74k API calls
```

## Solution Overview

Track entity content hashes and only embed when:
1. Entity is new (no existing embedding)
2. Entity content has changed (hash mismatch)
3. Embedding model has changed

## Architecture

### Embedding State Tracking

```sql
-- Add hash tracking to vectors table
ALTER TABLE {prefix}_vectors ADD COLUMN content_hash TEXT;

-- Index for quick lookups
CREATE INDEX idx_vectors_content_hash
ON {prefix}_vectors (entity_id, model_id, content_hash);
```

### Change Detection Flow

```
Entity Store        Embedding Manager
    │                      │
    │  Get all entities    │
    ├─────────────────────>│
    │                      │
    │  For each entity:    │
    │  ┌───────────────────┤
    │  │ Hash content      │
    │  │ Check if exists   │
    │  │ with same hash    │
    │  │                   │
    │  │ If changed:       │
    │  │   Queue for embed │
    │  └───────────────────┤
    │                      │
    │  Batch embed queue   │
    │  ├──────────────────>│ Ollama
    │                      │
    │  Store with hash     │
    └──────────────────────┘
```

## Implementation

### 1. Content Hashing

```typescript
// src/embeddings/content-hasher.ts

import { createHash } from 'crypto';
import { Entity } from '../entities';

/**
 * Generate a stable hash for entity content.
 */
export function hashEntityContent(entity: Entity): string {
  const content = buildEmbeddingContent(entity);
  return createHash('sha256').update(content).digest('hex').slice(0, 16);
}

/**
 * Build the content string that will be embedded.
 * This must be deterministic and match what's passed to the embedding API.
 */
export function buildEmbeddingContent(entity: Entity): string {
  const parts: string[] = [];

  // Always include name and type
  parts.push(`${entity.type}: ${entity.name}`);

  // Include summary if available
  if (entity.summary) {
    parts.push(entity.summary);
  }

  // Include first 50 lines of code for semantic matching
  if (entity.content) {
    const codePreview = entity.content.split('\n').slice(0, 50).join('\n');
    parts.push(codePreview);
  }

  return parts.join('\n\n');
}
```

### 2. Embedding State Tracker

```typescript
// src/embeddings/state-tracker.ts

import { DatabaseConnection } from '../db/connection';
import { hashEntityContent } from './content-hasher';
import { Entity } from '../entities';

export interface EmbeddingState {
  entityId: string;
  modelId: string;
  contentHash: string;
  embeddedAt: Date;
}

export class EmbeddingStateTracker {
  constructor(
    private db: DatabaseConnection,
    private vectorTable: string,
    private modelId: string
  ) {}

  /**
   * Check if entity needs re-embedding.
   */
  needsEmbedding(entity: Entity): boolean {
    const currentHash = hashEntityContent(entity);

    const existing = this.db.get<{ content_hash: string }>(
      `SELECT content_hash FROM ${this.vectorTable}
       WHERE entity_id = ? AND model_id = ?`,
      [entity.id, this.modelId]
    );

    // No existing embedding
    if (!existing) return true;

    // Hash mismatch (content changed)
    if (existing.content_hash !== currentHash) return true;

    return false;
  }

  /**
   * Get all entities that need embedding.
   */
  getEntitiesNeedingEmbedding(entities: Entity[]): Entity[] {
    const result: Entity[] = [];

    // Get all existing hashes in one query
    const existingHashes = new Map<string, string>();
    const rows = this.db.all<{ entity_id: string; content_hash: string }>(
      `SELECT entity_id, content_hash FROM ${this.vectorTable}
       WHERE model_id = ?`,
      [this.modelId]
    );

    for (const row of rows) {
      existingHashes.set(row.entity_id, row.content_hash);
    }

    // Check each entity
    for (const entity of entities) {
      const currentHash = hashEntityContent(entity);
      const existingHash = existingHashes.get(entity.id);

      if (!existingHash || existingHash !== currentHash) {
        result.push(entity);
      }
    }

    return result;
  }

  /**
   * Get statistics on embedding state.
   */
  getStats(): EmbeddingStats {
    const total = this.db.get<{ count: number }>(
      `SELECT COUNT(*) as count FROM ${this.vectorTable} WHERE model_id = ?`,
      [this.modelId]
    );

    const stale = this.db.get<{ count: number }>(
      `SELECT COUNT(*) as count FROM ${this.vectorTable} v
       WHERE v.model_id = ? AND v.content_hash IS NULL`,
      [this.modelId]
    );

    return {
      totalEmbeddings: total?.count || 0,
      staleEmbeddings: stale?.count || 0,
      modelId: this.modelId
    };
  }
}

interface EmbeddingStats {
  totalEmbeddings: number;
  staleEmbeddings: number;
  modelId: string;
}
```

### 3. Updated Embedding Manager

```typescript
// src/embeddings/manager.ts (updated)

export class EmbeddingManager {
  private stateTracker: EmbeddingStateTracker;

  constructor(
    private db: DatabaseConnection,
    private projectId: string,
    private provider: EmbeddingProvider
  ) {
    // ... existing setup ...
    this.stateTracker = new EmbeddingStateTracker(
      db,
      this.vectorTable,
      provider.modelId
    );
  }

  /**
   * Generate and store embedding for an entity (with hash tracking).
   */
  async embed(entityId: string, content: string): Promise<void> {
    const hash = createHash('sha256').update(content).digest('hex').slice(0, 16);
    const embedding = await this.provider.embed(content);
    this.storeWithHash(entityId, embedding, hash);
  }

  /**
   * Generate and store embeddings only for changed entities.
   */
  async embedIncremental(
    entities: Entity[],
    options?: {
      batchSize?: number;
      onProgress?: (completed: number, total: number, skipped: number) => void;
    }
  ): Promise<IncrementalEmbedResult> {
    // Determine which entities need embedding
    const needsEmbedding = this.stateTracker.getEntitiesNeedingEmbedding(entities);
    const skipped = entities.length - needsEmbedding.length;

    if (needsEmbedding.length === 0) {
      return {
        embedded: 0,
        skipped,
        total: entities.length
      };
    }

    // Batch embed only changed entities
    const batchSize = options?.batchSize || 50;

    for (let i = 0; i < needsEmbedding.length; i += batchSize) {
      const batch = needsEmbedding.slice(i, i + batchSize);

      const contents = batch.map(e => ({
        id: e.id,
        content: buildEmbeddingContent(e),
        hash: hashEntityContent(e)
      }));

      const embeddings = await this.provider.embedBatch(
        contents.map(c => c.content)
      );

      // Store with hashes
      for (let j = 0; j < batch.length; j++) {
        this.storeWithHash(batch[j].id, embeddings[j], contents[j].hash);
      }

      options?.onProgress?.(i + batch.length, needsEmbedding.length, skipped);
    }

    return {
      embedded: needsEmbedding.length,
      skipped,
      total: entities.length
    };
  }

  /**
   * Store embedding with content hash for change detection.
   */
  private storeWithHash(entityId: string, embedding: number[], hash: string): void {
    const id = generateId();

    // Delete existing embedding for this entity/model
    this.db.run(
      `DELETE FROM ${this.vectorTable} WHERE entity_id = ? AND model_id = ?`,
      [entityId, this.provider.modelId]
    );

    // Insert new embedding with hash
    this.db.run(
      `INSERT INTO ${this.vectorTable} (id, entity_id, model_id, embedding, content_hash)
       VALUES (?, ?, ?, ?, ?)`,
      [id, entityId, this.provider.modelId, JSON.stringify(embedding), hash]
    );
  }

  /**
   * Remove embeddings for deleted entities.
   */
  async cleanupOrphaned(validEntityIds: Set<string>): Promise<number> {
    const allEmbeddings = this.db.all<{ entity_id: string }>(
      `SELECT entity_id FROM ${this.vectorTable} WHERE model_id = ?`,
      [this.provider.modelId]
    );

    let removed = 0;
    for (const row of allEmbeddings) {
      if (!validEntityIds.has(row.entity_id)) {
        this.db.run(
          `DELETE FROM ${this.vectorTable} WHERE entity_id = ? AND model_id = ?`,
          [row.entity_id, this.provider.modelId]
        );
        removed++;
      }
    }

    return removed;
  }
}

interface IncrementalEmbedResult {
  embedded: number;
  skipped: number;
  total: number;
}
```

### 4. Updated CLI

```typescript
// src/cli/index-cmd.ts (updated)

.option('--embed', 'Generate embeddings for RAG', false)
.option('--force-embed', 'Re-embed all entities (ignore cache)', false)
.option('--embed-batch-size <n>', 'Batch size for embedding', '50')

async function runIndex(options: IndexOptions) {
  // ... indexing logic ...

  if (options.embed) {
    const entities = await entityStore.list();

    if (options.forceEmbed) {
      console.log(`Force re-embedding ${entities.length} entities...`);
      await embeddingManager.embedBatch(
        entities.map(e => ({
          id: e.id,
          content: buildEmbeddingContent(e)
        })),
        { batchSize: options.embedBatchSize }
      );
    } else {
      console.log(`Checking ${entities.length} entities for changes...`);
      const result = await embeddingManager.embedIncremental(entities, {
        batchSize: options.embedBatchSize,
        onProgress: (completed, total, skipped) => {
          process.stdout.write(
            `\rEmbedding: ${completed}/${total} (${skipped} unchanged)  `
          );
        }
      });

      console.log(`\nEmbedding complete:`);
      console.log(`  - Embedded: ${result.embedded}`);
      console.log(`  - Skipped (unchanged): ${result.skipped}`);
      console.log(`  - Total: ${result.total}`);
    }

    // Cleanup orphaned embeddings
    const validIds = new Set(entities.map(e => e.id));
    const removed = await embeddingManager.cleanupOrphaned(validIds);
    if (removed > 0) {
      console.log(`  - Removed orphaned: ${removed}`);
    }
  }
}
```

### 5. Database Migration

```typescript
// src/db/migrations/add-content-hash.ts

export async function addContentHashColumn(db: DatabaseConnection): Promise<void> {
  // Check if column exists
  const columns = db.all<{ name: string }>(
    `PRAGMA table_info(${vectorTable})`
  );

  const hasHash = columns.some(c => c.name === 'content_hash');

  if (!hasHash) {
    db.run(`ALTER TABLE ${vectorTable} ADD COLUMN content_hash TEXT`);
    db.run(
      `CREATE INDEX IF NOT EXISTS idx_${vectorTable}_hash
       ON ${vectorTable} (entity_id, model_id, content_hash)`
    );
  }
}
```

## CLI Commands

```bash
# Index with incremental embedding (default behavior)
ctx-sys index . --embed
# Output: Embedding: 150/74123 (73973 unchanged)

# Force re-embed everything
ctx-sys index . --embed --force-embed

# Show embedding statistics
ctx-sys embed-status

# Clean up orphaned embeddings
ctx-sys embed --cleanup
```

## Testing

```typescript
describe('Incremental Embedding', () => {
  it('skips unchanged entities', async () => {
    // First embed
    await embeddingManager.embedIncremental(entities);

    // Second embed should skip all
    const result = await embeddingManager.embedIncremental(entities);

    expect(result.embedded).toBe(0);
    expect(result.skipped).toBe(entities.length);
  });

  it('re-embeds changed entities', async () => {
    await embeddingManager.embedIncremental(entities);

    // Modify one entity
    entities[0].content = 'new content';

    const result = await embeddingManager.embedIncremental(entities);

    expect(result.embedded).toBe(1);
    expect(result.skipped).toBe(entities.length - 1);
  });

  it('embeds new entities', async () => {
    await embeddingManager.embedIncremental(entities);

    // Add new entity
    entities.push(newEntity);

    const result = await embeddingManager.embedIncremental(entities);

    expect(result.embedded).toBe(1);
  });

  it('cleans up orphaned embeddings', async () => {
    await embeddingManager.embedIncremental(entities);

    // Remove entity from store but not embeddings
    const validIds = new Set(entities.slice(1).map(e => e.id));

    const removed = await embeddingManager.cleanupOrphaned(validIds);

    expect(removed).toBe(1);
  });
});
```

## Success Metrics

| Metric | Target |
|--------|--------|
| Skip rate for unchanged codebase | 100% |
| Re-embed time for 1% changes | <1% of full embed time |
| Hash computation overhead | <5ms per entity |
| Storage overhead for hashes | <1MB for 100k entities |

## Dependencies

- F10.1: Code Content Storage (entity content for hashing)

## Risks & Mitigations

| Risk | Mitigation |
|------|------------|
| Hash collisions | Use 16-char SHA256 prefix (extremely unlikely) |
| Embedding model change not detected | Track model ID alongside hash |
| Content building logic changes | Version the content builder, force re-embed on version change |

## Next Steps

1. Add content_hash column to vectors table
2. Implement content hashing
3. Update EmbeddingManager with incremental logic
4. Add --force-embed CLI flag
5. Add orphan cleanup command
