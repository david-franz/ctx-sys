# F10.4: Smart Context Assembly

## Goal

When `context_query` returns results, assemble actual usable context by reading source files and extracting the relevant code sections. Currently, the tool returns entity metadata but users must manually read files to get actual code.

## Current Limitation

```typescript
// Current context_query response
{
  "results": [
    {
      "entity": {
        "name": "processPayment",
        "type": "function",
        "content": "Async function taking 2 parameter(s) returning Promise<PaymentResult>"
      },
      "score": 0.89,
      "source": "semantic"
    }
  ]
}

// User still needs to:
// 1. Find the file path from metadata
// 2. Read the file manually
// 3. Locate the function within the file
// 4. Extract just the relevant portion
```

## Solution Overview

Add a context assembly layer that:

1. **Reads source files** when entities are retrieved
2. **Extracts exact code** using stored line numbers
3. **Includes surrounding context** (imports, related functions)
4. **Respects token budgets** with intelligent truncation
5. **Formats output** for LLM consumption

## Architecture

### Context Assembly Pipeline

```
context_query("payment processing")
    ↓
Multi-Strategy Search
    ↓
[Entity Results with file paths + line numbers]
    ↓
Context Assembler
    ├── Read source files
    ├── Extract code sections
    ├── Add surrounding context
    ├── Format for LLM
    └── Respect token budget
    ↓
Assembled Context (actual code!)
```

### Output Format

```typescript
interface AssembledContext {
  /** Total tokens in assembled context */
  totalTokens: number;

  /** Individual context blocks */
  blocks: ContextBlock[];

  /** Summary of what was included/excluded */
  summary: {
    entitiesIncluded: number;
    entitiesExcluded: number;
    filesRead: number;
    truncated: boolean;
  };
}

interface ContextBlock {
  /** Source entity */
  entity: {
    name: string;
    type: string;
    qualifiedName: string;
  };

  /** Relevance score */
  score: number;

  /** File location */
  location: {
    filePath: string;
    startLine: number;
    endLine: number;
  };

  /** Actual source code */
  code: string;

  /** Surrounding context (imports, related) */
  context?: {
    imports?: string;
    relatedEntities?: string[];
  };
}
```

## Implementation

### 1. Context Assembler

```typescript
// src/retrieval/context-assembler.ts

import * as fs from 'fs';
import * as path from 'path';
import { Entity } from '../entities';
import { SearchResult } from './types';

export interface AssemblyOptions {
  /** Maximum tokens for assembled context */
  maxTokens?: number;

  /** Include file imports as context */
  includeImports?: boolean;

  /** Lines of context before/after entity */
  contextLines?: number;

  /** Format for output */
  format?: 'markdown' | 'plain' | 'xml';

  /** Project root for resolving relative paths */
  projectRoot?: string;
}

const DEFAULT_OPTIONS: Required<AssemblyOptions> = {
  maxTokens: 4000,
  includeImports: true,
  contextLines: 3,
  format: 'markdown',
  projectRoot: process.cwd()
};

export class ContextAssembler {
  private fileCache: Map<string, string[]> = new Map();
  private options: Required<AssemblyOptions>;

  constructor(options?: AssemblyOptions) {
    this.options = { ...DEFAULT_OPTIONS, ...options };
  }

  /**
   * Assemble context from search results.
   */
  async assemble(results: SearchResult[]): Promise<AssembledContext> {
    const blocks: ContextBlock[] = [];
    let totalTokens = 0;
    let entitiesExcluded = 0;
    const filesRead = new Set<string>();

    for (const result of results) {
      const entity = result.entity;
      const metadata = entity.metadata as EntityMetadata;

      // Skip if no file location
      if (!metadata?.filePath || !metadata?.startLine) {
        entitiesExcluded++;
        continue;
      }

      // Read and cache file
      const lines = await this.getFileLines(metadata.filePath);
      if (!lines) {
        entitiesExcluded++;
        continue;
      }

      filesRead.add(metadata.filePath);

      // Extract code with context
      const code = this.extractCode(
        lines,
        metadata.startLine,
        metadata.endLine || metadata.startLine + 50,
        this.options.contextLines
      );

      // Estimate tokens (rough: 1 token ≈ 4 chars)
      const codeTokens = Math.ceil(code.length / 4);

      // Check token budget
      if (totalTokens + codeTokens > this.options.maxTokens) {
        // Try truncated version
        const truncated = this.truncateCode(code, this.options.maxTokens - totalTokens);
        if (truncated) {
          blocks.push(this.createBlock(entity, result.score, metadata, truncated));
          totalTokens += Math.ceil(truncated.length / 4);
        }
        entitiesExcluded += results.length - blocks.length;
        break;
      }

      // Get imports if requested
      let imports: string | undefined;
      if (this.options.includeImports) {
        imports = this.extractImports(lines);
      }

      blocks.push({
        entity: {
          name: entity.name,
          type: entity.type,
          qualifiedName: entity.qualifiedName
        },
        score: result.score,
        location: {
          filePath: metadata.filePath,
          startLine: metadata.startLine,
          endLine: metadata.endLine || metadata.startLine
        },
        code,
        context: imports ? { imports } : undefined
      });

      totalTokens += codeTokens;
    }

    return {
      totalTokens,
      blocks,
      summary: {
        entitiesIncluded: blocks.length,
        entitiesExcluded,
        filesRead: filesRead.size,
        truncated: entitiesExcluded > 0
      }
    };
  }

  /**
   * Format assembled context for LLM consumption.
   */
  format(context: AssembledContext): string {
    switch (this.options.format) {
      case 'markdown':
        return this.formatMarkdown(context);
      case 'xml':
        return this.formatXML(context);
      default:
        return this.formatPlain(context);
    }
  }

  private formatMarkdown(context: AssembledContext): string {
    const parts: string[] = [];

    for (const block of context.blocks) {
      parts.push(`### ${block.entity.type}: ${block.entity.name}`);
      parts.push(`*${block.location.filePath}:${block.location.startLine}-${block.location.endLine}* (score: ${block.score.toFixed(2)})`);
      parts.push('');

      if (block.context?.imports) {
        parts.push('**Imports:**');
        parts.push('```');
        parts.push(block.context.imports);
        parts.push('```');
        parts.push('');
      }

      parts.push('**Code:**');
      const lang = this.detectLanguage(block.location.filePath);
      parts.push(`\`\`\`${lang}`);
      parts.push(block.code);
      parts.push('```');
      parts.push('');
    }

    if (context.summary.truncated) {
      parts.push(`---`);
      parts.push(`*${context.summary.entitiesExcluded} additional results excluded due to token limit*`);
    }

    return parts.join('\n');
  }

  private formatXML(context: AssembledContext): string {
    const parts: string[] = ['<context>'];

    for (const block of context.blocks) {
      parts.push(`  <entity type="${block.entity.type}" name="${block.entity.name}" score="${block.score.toFixed(2)}">`);
      parts.push(`    <location file="${block.location.filePath}" start="${block.location.startLine}" end="${block.location.endLine}" />`);

      if (block.context?.imports) {
        parts.push(`    <imports><![CDATA[${block.context.imports}]]></imports>`);
      }

      parts.push(`    <code><![CDATA[${block.code}]]></code>`);
      parts.push(`  </entity>`);
    }

    parts.push('</context>');
    return parts.join('\n');
  }

  private formatPlain(context: AssembledContext): string {
    const parts: string[] = [];

    for (const block of context.blocks) {
      parts.push(`=== ${block.entity.type}: ${block.entity.name} ===`);
      parts.push(`File: ${block.location.filePath}:${block.location.startLine}`);
      parts.push(`Score: ${block.score.toFixed(2)}`);
      parts.push('');
      parts.push(block.code);
      parts.push('');
    }

    return parts.join('\n');
  }

  private async getFileLines(filePath: string): Promise<string[] | null> {
    // Resolve relative paths
    const fullPath = path.isAbsolute(filePath)
      ? filePath
      : path.join(this.options.projectRoot, filePath);

    // Check cache
    if (this.fileCache.has(fullPath)) {
      return this.fileCache.get(fullPath)!;
    }

    try {
      const content = await fs.promises.readFile(fullPath, 'utf-8');
      const lines = content.split('\n');
      this.fileCache.set(fullPath, lines);
      return lines;
    } catch {
      return null;
    }
  }

  private extractCode(
    lines: string[],
    startLine: number,
    endLine: number,
    contextLines: number
  ): string {
    const start = Math.max(0, startLine - 1 - contextLines);
    const end = Math.min(lines.length, endLine + contextLines);

    return lines.slice(start, end).join('\n');
  }

  private extractImports(lines: string[]): string {
    const imports: string[] = [];

    for (const line of lines) {
      const trimmed = line.trim();
      if (trimmed.startsWith('import ') ||
          trimmed.startsWith('from ') ||
          trimmed.startsWith('require(') ||
          trimmed.startsWith('const ') && trimmed.includes('require(')) {
        imports.push(line);
      } else if (imports.length > 0 && !trimmed) {
        // Stop at first blank line after imports
        break;
      } else if (imports.length > 0 && !trimmed.startsWith('import') && !trimmed.startsWith('from')) {
        break;
      }
    }

    return imports.join('\n');
  }

  private truncateCode(code: string, maxTokens: number): string | null {
    const maxChars = maxTokens * 4;
    if (code.length <= maxChars) return code;

    const lines = code.split('\n');
    let result = '';

    for (const line of lines) {
      if (result.length + line.length + 1 > maxChars) {
        result += '\n// ... (truncated)';
        break;
      }
      result += (result ? '\n' : '') + line;
    }

    return result || null;
  }

  private createBlock(
    entity: Entity,
    score: number,
    metadata: EntityMetadata,
    code: string
  ): ContextBlock {
    return {
      entity: {
        name: entity.name,
        type: entity.type,
        qualifiedName: entity.qualifiedName
      },
      score,
      location: {
        filePath: metadata.filePath,
        startLine: metadata.startLine,
        endLine: metadata.endLine || metadata.startLine
      },
      code
    };
  }

  private detectLanguage(filePath: string): string {
    const ext = path.extname(filePath).toLowerCase();
    const langMap: Record<string, string> = {
      '.ts': 'typescript',
      '.tsx': 'typescript',
      '.js': 'javascript',
      '.jsx': 'javascript',
      '.py': 'python',
      '.rs': 'rust',
      '.go': 'go',
      '.java': 'java',
      '.rb': 'ruby',
      '.php': 'php',
      '.c': 'c',
      '.cpp': 'cpp',
      '.h': 'c',
      '.cs': 'csharp'
    };
    return langMap[ext] || '';
  }

  /**
   * Clear the file cache.
   */
  clearCache(): void {
    this.fileCache.clear();
  }
}

interface EntityMetadata {
  filePath: string;
  startLine: number;
  endLine?: number;
}
```

### 2. Enhanced context_query Tool

```typescript
// src/mcp/tools/context-query.ts

export async function contextQuery(
  query: string,
  options: ContextQueryOptions
): Promise<ContextQueryResult> {
  // Perform multi-strategy search
  const searchResults = await multiSearch.search(query, {
    strategies: options.strategies,
    limit: options.limit || 10,
    entityTypes: options.includeTypes,
    minScore: options.minScore || 0.3
  });

  // Assemble context from source files
  const assembler = new ContextAssembler({
    maxTokens: options.maxTokens || 4000,
    includeImports: true,
    contextLines: 3,
    format: 'markdown',
    projectRoot: project.path
  });

  const assembled = await assembler.assemble(searchResults);
  const formatted = assembler.format(assembled);

  return {
    query,
    context: formatted,
    results: assembled.blocks.map(b => ({
      entity: b.entity,
      score: b.score,
      location: b.location,
      codePreview: b.code.slice(0, 200) + (b.code.length > 200 ? '...' : '')
    })),
    summary: assembled.summary,
    tokenCount: assembled.totalTokens
  };
}
```

### 3. Smart Truncation Strategies

```typescript
// src/retrieval/truncation.ts

export interface TruncationStrategy {
  name: string;
  truncate(code: string, maxTokens: number): string;
}

/**
 * Keep function signature and first N lines of body.
 */
export class SignatureFirstStrategy implements TruncationStrategy {
  name = 'signature-first';

  truncate(code: string, maxTokens: number): string {
    const maxChars = maxTokens * 4;
    const lines = code.split('\n');

    // Find signature (first line with function/class/def)
    const signatureEnd = lines.findIndex(line =>
      line.includes('{') || line.includes(':') && !line.trim().startsWith('//')
    );

    if (signatureEnd === -1) {
      return code.slice(0, maxChars) + '\n// ...';
    }

    // Include signature + first few body lines
    const signature = lines.slice(0, signatureEnd + 1).join('\n');
    const remaining = maxChars - signature.length;

    if (remaining < 50) {
      return signature + '\n  // ... (body truncated)';
    }

    const bodyLines = lines.slice(signatureEnd + 1);
    let body = '';
    for (const line of bodyLines) {
      if (body.length + line.length > remaining - 20) {
        break;
      }
      body += '\n' + line;
    }

    return signature + body + '\n  // ...';
  }
}

/**
 * Keep first and last sections of code.
 */
export class BookendStrategy implements TruncationStrategy {
  name = 'bookend';

  truncate(code: string, maxTokens: number): string {
    const maxChars = maxTokens * 4;
    const halfChars = Math.floor(maxChars / 2) - 10;

    const start = code.slice(0, halfChars);
    const end = code.slice(-halfChars);

    return start + '\n\n// ... (middle truncated) ...\n\n' + end;
  }
}
```

## Testing

```typescript
describe('Context Assembly', () => {
  it('extracts code from source files', async () => {
    const assembler = new ContextAssembler({
      projectRoot: '/test/project'
    });

    const results: SearchResult[] = [{
      entity: {
        id: '1',
        name: 'processPayment',
        type: 'function',
        qualifiedName: 'src/payments.ts::processPayment',
        metadata: {
          filePath: 'src/payments.ts',
          startLine: 10,
          endLine: 25
        }
      },
      score: 0.9,
      source: 'semantic'
    }];

    const context = await assembler.assemble(results);

    expect(context.blocks).toHaveLength(1);
    expect(context.blocks[0].code).toContain('function processPayment');
    expect(context.totalTokens).toBeGreaterThan(0);
  });

  it('respects token budget', async () => {
    const assembler = new ContextAssembler({
      maxTokens: 100 // Very small budget
    });

    const results = createManyResults(10);
    const context = await assembler.assemble(results);

    expect(context.totalTokens).toBeLessThanOrEqual(100);
    expect(context.summary.truncated).toBe(true);
  });

  it('formats output as markdown', async () => {
    const assembler = new ContextAssembler({ format: 'markdown' });
    const context = await assembler.assemble(sampleResults);

    const formatted = assembler.format(context);

    expect(formatted).toContain('###');
    expect(formatted).toContain('```typescript');
  });
});
```

## Success Metrics

| Metric | Target |
|--------|--------|
| Code retrieval success rate | >95% for entities with file metadata |
| Context assembly time | <100ms for 10 entities |
| Token budget adherence | Never exceed specified limit |
| Format correctness | Valid markdown/XML output |

## Dependencies

- F10.1: Code Content Storage (for line numbers in metadata)
- F10.2: Scalable Indexing (for file path storage)

## Risks & Mitigations

| Risk | Mitigation |
|------|------------|
| Source files moved/deleted | Graceful fallback to stored content |
| Large files slow to read | File caching, lazy loading |
| Line numbers out of sync | Detect via hash comparison, trigger re-index |

## Next Steps

1. Implement ContextAssembler class
2. Add file caching with LRU eviction
3. Integrate with context_query MCP tool
4. Add truncation strategies
5. Test with various codebases
