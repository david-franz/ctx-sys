# F5.2 Entity Resolution

**Phase**: 5 - Graph RAG
**Priority**: Medium
**Dependencies**: F1.3 Entity Storage, F1.4 Embedding Pipeline

## Goal

Deduplicate and merge entities that refer to the same thing.

## Overview

The same concept may be referenced in multiple ways:
- "AuthService" in code vs "Authentication Service" in docs
- "user validation" vs "validateUser function"

Entity resolution identifies and merges these duplicates.

## Implementation

### File: `src/graph/entity-resolver.ts`

```typescript
import { EntityStore, Entity } from '../entities/store';
import { EmbeddingManager } from '../embeddings/manager';
import { RelationshipStore } from '../relationships/store';

interface DuplicateGroup {
  primary: Entity;
  duplicates: Entity[];
  similarity: number;
}

export class EntityResolver {
  constructor(
    private entityStore: EntityStore,
    private embeddingManager: EmbeddingManager,
    private relationshipStore: RelationshipStore
  ) {}

  async findDuplicates(
    threshold: number = 0.85
  ): Promise<DuplicateGroup[]> {
    const groups: DuplicateGroup[] = [];
    const processed = new Set<string>();

    const entities = await this.entityStore.getByType([
      'concept', 'technology', 'pattern'
    ]);

    for (const entity of entities) {
      if (processed.has(entity.id)) continue;

      // Find similar entities by embedding
      const similar = await this.embeddingManager.findSimilar(
        entity.content || entity.name,
        { limit: 10, threshold }
      );

      const duplicates = similar
        .filter(s => s.entityId !== entity.id && !processed.has(s.entityId))
        .map(s => s.entityId);

      if (duplicates.length > 0) {
        const duplicateEntities = await Promise.all(
          duplicates.map(id => this.entityStore.get(id))
        );

        groups.push({
          primary: entity,
          duplicates: duplicateEntities.filter((e): e is Entity => e !== null),
          similarity: similar[0]?.score || 0
        });

        // Mark as processed
        processed.add(entity.id);
        duplicates.forEach(id => processed.add(id));
      }
    }

    return groups;
  }

  async merge(primaryId: string, duplicateIds: string[]): Promise<void> {
    const primary = await this.entityStore.get(primaryId);
    if (!primary) throw new Error('Primary entity not found');

    for (const dupId of duplicateIds) {
      const duplicate = await this.entityStore.get(dupId);
      if (!duplicate) continue;

      // Merge metadata
      const mergedMetadata = {
        ...duplicate.metadata,
        ...primary.metadata,
        aliases: [
          ...(primary.metadata.aliases || []),
          duplicate.name,
          ...(duplicate.metadata.aliases || [])
        ]
      };

      await this.entityStore.update(primaryId, {
        metadata: mergedMetadata
      });

      // Redirect relationships
      await this.redirectRelationships(dupId, primaryId);

      // Delete duplicate
      await this.embeddingManager.deleteForEntity(dupId);
      await this.entityStore.delete(dupId);
    }
  }

  private async redirectRelationships(
    fromId: string,
    toId: string
  ): Promise<void> {
    const relationships = await this.relationshipStore.getForEntity(fromId);

    for (const rel of relationships) {
      const newSource = rel.sourceId === fromId ? toId : rel.sourceId;
      const newTarget = rel.targetId === fromId ? toId : rel.targetId;

      // Skip self-loops
      if (newSource === newTarget) continue;

      await this.relationshipStore.create({
        sourceId: newSource,
        targetId: newTarget,
        relationship: rel.relationship,
        weight: rel.weight,
        metadata: rel.metadata
      });
    }

    await this.relationshipStore.deleteForEntity(fromId);
  }

  async resolve(name: string, type?: string): Promise<Entity | null> {
    // Try exact match
    let entity = await this.entityStore.getByName(name, type as any);
    if (entity) return entity;

    // Try fuzzy match via embedding similarity
    const similar = await this.embeddingManager.findSimilar(name, {
      limit: 1,
      threshold: 0.8,
      entityTypes: type ? [type] : undefined
    });

    if (similar.length > 0) {
      return this.entityStore.get(similar[0].entityId);
    }

    return null;
  }
}
```

## Tasks

- [ ] Implement EntityResolver
- [ ] Implement duplicate detection
- [ ] Implement entity merging
- [ ] Implement relationship redirection
- [ ] Add fuzzy name matching
- [ ] Write unit tests

## Testing

```typescript
describe('EntityResolver', () => {
  it('should find duplicate entities');
  it('should merge entities');
  it('should redirect relationships');
  it('should resolve fuzzy matches');
});
```
