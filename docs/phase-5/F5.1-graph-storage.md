# F5.1 Graph Storage and Traversal

**Phase**: 5 - Graph RAG
**Priority**: High
**Dependencies**: F1.1 Database Schema, F2.4 Relationship Extraction

## Goal

Efficient graph operations using SQLite with recursive CTEs.

## Overview

The relationship store (F2.4) provides basic graph operations. This feature extends it with:
- Efficient multi-hop traversal
- Path finding between entities
- Subgraph extraction
- Graph statistics

## Implementation

See F2.4 for the core RelationshipStore implementation.

### File: `src/graph/traversal.ts`

```typescript
import { RelationshipStore } from '../relationships/store';
import { EntityStore, Entity } from '../entities/store';

interface SubgraphResult {
  entities: Entity[];
  relationships: Array<{
    source: string;
    target: string;
    type: string;
    weight: number;
  }>;
}

interface PathResult {
  paths: Array<{
    nodes: string[];
    edges: string[];
    length: number;
  }>;
}

export class GraphTraversal {
  constructor(
    private relationshipStore: RelationshipStore,
    private entityStore: EntityStore
  ) {}

  async getNeighborhood(
    entityId: string,
    depth: number = 2,
    types?: string[]
  ): Promise<SubgraphResult> {
    const result = await this.relationshipStore.traverse(entityId, depth, {
      types: types as any
    });

    // Hydrate entities
    const entities = await Promise.all(
      result.entityIds.map(id => this.entityStore.get(id))
    );

    return {
      entities: entities.filter((e): e is Entity => e !== null),
      relationships: result.relationships.map(r => ({
        source: r.sourceId,
        target: r.targetId,
        type: r.relationship,
        weight: r.weight
      }))
    };
  }

  async findPaths(
    fromId: string,
    toId: string,
    maxDepth: number = 5
  ): Promise<PathResult> {
    // Use recursive CTE to find all paths
    const sql = `
      WITH RECURSIVE paths AS (
        SELECT
          source_id,
          target_id,
          source_id || ',' || target_id as path,
          1 as depth
        FROM ${this.relationshipStore['tableName']}
        WHERE source_id = ?

        UNION ALL

        SELECT
          p.source_id,
          r.target_id,
          p.path || ',' || r.target_id,
          p.depth + 1
        FROM paths p
        JOIN ${this.relationshipStore['tableName']} r
          ON r.source_id = (
            SELECT SUBSTR(p.path, -36)
          )
        WHERE p.depth < ?
          AND p.path NOT LIKE '%' || r.target_id || '%'
      )
      SELECT path, depth
      FROM paths
      WHERE path LIKE '%' || ? || '%'
      ORDER BY depth
      LIMIT 10
    `;

    const rows = this.relationshipStore['db'].all<{ path: string; depth: number }>(
      sql,
      [fromId, maxDepth, toId]
    );

    return {
      paths: rows.map(r => ({
        nodes: r.path.split(','),
        edges: [], // Would need additional query
        length: r.depth
      }))
    };
  }

  async getGraphStats(): Promise<{
    entityCount: number;
    relationshipCount: number;
    avgDegree: number;
    components: number;
  }> {
    const entityCount = await this.entityStore.count();

    const relStats = this.relationshipStore['db'].get<{
      count: number;
      avg_degree: number;
    }>(`
      SELECT
        COUNT(*) as count,
        AVG(degree) as avg_degree
      FROM (
        SELECT source_id, COUNT(*) as degree
        FROM ${this.relationshipStore['tableName']}
        GROUP BY source_id
      )
    `);

    return {
      entityCount,
      relationshipCount: relStats?.count || 0,
      avgDegree: relStats?.avg_degree || 0,
      components: 1 // Would need more complex analysis
    };
  }
}
```

## Tasks

- [ ] Extend RelationshipStore with advanced traversal
- [ ] Implement path finding
- [ ] Implement subgraph extraction
- [ ] Add graph statistics
- [ ] Write unit tests

## Testing

```typescript
describe('GraphTraversal', () => {
  it('should get entity neighborhood');
  it('should find paths between entities');
  it('should compute graph statistics');
});
```
