# F10i.7 Test Infrastructure Fix

**Phase**: 10i - Code Quality & Infrastructure
**Priority**: Medium
**Dependencies**: None

## Goal

Make `npm test` reliably pass by resolving the Jest configuration issues that cause "describe is not defined" errors in some test files, and establish a trustworthy CI-ready test suite.

## Current State

### Configuration

- **Runner**: Jest 29.7.0 with ts-jest 29.1.2
- **Config**: `jest.config.js` using `ts-jest` preset, `node` environment
- **Execution**: `NODE_OPTIONS='--experimental-vm-modules' jest`
- **Timeout**: 10 seconds per test

### The Problem

Jest provides `describe`, `it`, `test`, `expect`, `beforeAll`, `beforeEach`, `afterAll`, `afterEach` as globals automatically. All 55 test files use these without importing them, which is correct for Jest.

However, the MEMORY.md reports "describe is not defined" errors. This can happen when:

1. **ESM module resolution conflicts** — `--experimental-vm-modules` combined with ts-jest can cause issues where Jest's global injection doesn't work in some file resolution paths
2. **TypeScript compilation errors** — if ts-jest fails to compile a test file, the error message can be misleading
3. **Missing type definitions** — `@types/jest` is installed but may conflict with file-level `tsconfig` settings

### Additional Issues

- No CI pipeline exists — tests are only run locally
- Test phase scripts (`test:phase1` through `test:phase9`) exist but `test:phase10` and later are missing
- The `jest.config.js` uses CommonJS (`module.exports`) while the project uses ESM (`"type": "module"` in package.json may conflict)
- No coverage thresholds are configured

## Implementation Plan

### Step 1: Diagnose the exact failure

Run the full test suite and capture the actual error output:

```bash
NODE_OPTIONS='--experimental-vm-modules' npx jest --verbose 2>&1 | head -200
```

Identify which specific test files fail and what the exact error messages are.

### Step 2: Fix ESM/CJS resolution

The most likely root cause is ESM/CJS conflict. `ts-jest` needs explicit ESM configuration:

**File**: `jest.config.js`

```javascript
/** @type {import('ts-jest').JestConfigWithTsJest} */
export default {
  preset: 'ts-jest/presets/default-esm',
  testEnvironment: 'node',
  roots: ['<rootDir>/tests'],
  testMatch: ['**/*.test.ts'],
  moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx', 'json', 'node'],
  extensionsToTreatAsEsm: ['.ts'],
  transform: {
    '^.+\\.tsx?$': [
      'ts-jest',
      {
        useESM: true,
        tsconfig: 'tsconfig.json',
      },
    ],
  },
  moduleNameMapper: {
    '^(\\.{1,2}/.*)\\.js$': '$1',  // Handle .js extensions in imports
  },
  collectCoverageFrom: [
    'src/**/*.ts',
    '!src/**/*.d.ts',
    '!src/cli/index.ts',
  ],
  coverageDirectory: 'coverage',
  verbose: true,
  testTimeout: 30000,  // Increase for embedding/LLM tests
};
```

Key changes:
- Use `ts-jest/presets/default-esm` preset
- Add `extensionsToTreatAsEsm: ['.ts']`
- Add `useESM: true` to ts-jest options
- Add `moduleNameMapper` for `.js` extension resolution (since source uses `.js` in imports for ESM)
- Use ESM `export default` instead of CommonJS `module.exports`
- Increase timeout to 30s for tests that touch Ollama

### Step 3: Create a test tsconfig

**File**: `tsconfig.test.json`

```json
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "module": "ESNext",
    "moduleResolution": "node16",
    "types": ["jest", "node"]
  },
  "include": ["src/**/*.ts", "tests/**/*.ts"]
}
```

Update jest.config to reference it:

```javascript
transform: {
  '^.+\\.tsx?$': ['ts-jest', { useESM: true, tsconfig: 'tsconfig.test.json' }],
},
```

### Step 4: Fix individual test file issues

For any tests that fail due to import resolution:

```typescript
// If a test imports from src/ using the compiled .js extension:
import { EntityStore } from '../../src/entities/store.js';

// The moduleNameMapper will strip .js so ts-jest resolves the .ts file
```

For tests that require external services (Ollama, filesystem), add skip conditions:

```typescript
const OLLAMA_AVAILABLE = process.env.OLLAMA_URL || 'http://localhost:11434';

describe('Embedding integration', () => {
  beforeAll(async () => {
    try {
      await fetch(OLLAMA_AVAILABLE);
    } catch {
      console.log('Ollama not available, skipping integration tests');
      return;
    }
  });
  // ...
});
```

### Step 5: Add missing test phase scripts

**File**: `package.json`

Add scripts for phases 10 and 10i:

```json
{
  "scripts": {
    "test:phase10": "NODE_OPTIONS='--experimental-vm-modules' jest tests/phase-10/",
    "test:phase10i": "NODE_OPTIONS='--experimental-vm-modules' jest tests/phase-10i/"
  }
}
```

### Step 6: Add coverage thresholds

**File**: `jest.config.js`

```javascript
coverageThreshold: {
  global: {
    branches: 50,
    functions: 60,
    lines: 60,
    statements: 60,
  },
},
```

Start with achievable thresholds and ratchet up over time.

### Step 7: Tag tests for selective execution

Add a convention for tagging tests that require external services:

```typescript
// Tests requiring Ollama
(process.env.CI ? describe.skip : describe)('Ollama integration', () => { ... });
```

Or use Jest's `--testPathPattern` to exclude integration tests in CI:

```json
{
  "scripts": {
    "test:unit": "NODE_OPTIONS='--experimental-vm-modules' jest --testPathIgnorePatterns='integration'",
    "test:integration": "NODE_OPTIONS='--experimental-vm-modules' jest --testPathPattern='integration'"
  }
}
```

## File Changes

| File | Change |
|------|--------|
| `jest.config.js` | **Rewrite** — ESM-compatible config |
| `tsconfig.test.json` | **New** — test-specific TypeScript config |
| `package.json` | **Update** — add missing test scripts, coverage thresholds |
| Various test files | **Update** — fix import paths if needed |

## Testing

This feature IS the testing infrastructure, so validation is:
- `npm test` runs to completion with clear pass/fail output
- `npm run test:phase1` through `test:phase10i` all work
- `npm run test:unit` runs without external service dependencies
- Coverage report generates correctly

## Success Criteria

- `npm test` exits 0 with all tests passing (or with known-skipped integration tests)
- Zero "describe is not defined" errors
- Coverage report generates under `coverage/`
- Test execution time under 60 seconds for unit tests

## Tasks

- [ ] Diagnose exact test failures with verbose output
- [ ] Fix jest.config.js for ESM compatibility
- [ ] Create tsconfig.test.json
- [ ] Fix individual test file import issues
- [ ] Add missing test phase scripts
- [ ] Tag integration tests for conditional execution
- [ ] Verify `npm test` passes
- [ ] Add coverage thresholds
