# F10i.3 Logging Abstraction

**Phase**: 10i - Code Quality & Infrastructure
**Priority**: Medium
**Dependencies**: None

## Goal

Replace 19 bare `console.*` calls in library code with an injectable logger interface, allowing consumers (MCP server, CLI, tests) to control log output and verbosity.

## Current State

19 `console.*` calls in 7 non-CLI library files:

| File | Calls | Context |
|------|-------|---------|
| `src/retrieval/multi-strategy-search.ts` | 3 `console.error` | Search strategy failures |
| `src/models/provider-factory.ts` | 4 `console.warn` | Embedding/summarization provider fallback |
| `src/embeddings/factory.ts` | 1 `console.warn` | Embedding provider fallback |
| `src/db/connection.ts` | 2 `console.warn` | sqlite-vec load failure |
| `src/hooks/hook-handler.ts` | 8 `console.log` + 1 `console.error` | Impact report printer + internal log |
| `src/summarization/llm-manager.ts` | 1 `console.error` | Batch summarization failure |

The CLI files (`src/cli/init.ts`, `src/cli/serve.ts`) use `console.*` intentionally as they are the terminal output — these should stay.

## Implementation Plan

### Step 1: Define logger interface

**File**: `src/utils/logger.ts`

```typescript
export interface Logger {
  debug(message: string, ...args: unknown[]): void;
  info(message: string, ...args: unknown[]): void;
  warn(message: string, ...args: unknown[]): void;
  error(message: string, ...args: unknown[]): void;
}

/** Default logger that writes to console */
export const consoleLogger: Logger = {
  debug: (msg, ...args) => {},  // silent by default
  info: (msg, ...args) => console.log(msg, ...args),
  warn: (msg, ...args) => console.warn(msg, ...args),
  error: (msg, ...args) => console.error(msg, ...args),
};

/** Silent logger for tests and library consumers who want no output */
export const nullLogger: Logger = {
  debug: () => {},
  info: () => {},
  warn: () => {},
  error: () => {},
};

/** Create a logger with a minimum level filter */
export type LogLevel = 'debug' | 'info' | 'warn' | 'error' | 'silent';

const LEVEL_ORDER: Record<LogLevel, number> = {
  debug: 0, info: 1, warn: 2, error: 3, silent: 4
};

export function createLogger(minLevel: LogLevel = 'warn'): Logger {
  const min = LEVEL_ORDER[minLevel];
  return {
    debug: min <= 0 ? (msg, ...a) => console.debug(msg, ...a) : () => {},
    info:  min <= 1 ? (msg, ...a) => console.log(msg, ...a) : () => {},
    warn:  min <= 2 ? (msg, ...a) => console.warn(msg, ...a) : () => {},
    error: min <= 3 ? (msg, ...a) => console.error(msg, ...a) : () => {},
  };
}
```

### Step 2: Add logger to AppContext

**File**: `src/context.ts`

```typescript
export class AppContext {
  readonly logger: Logger;

  constructor(options?: { logger?: Logger }) {
    this.logger = options?.logger ?? consoleLogger;
    // ... existing init
  }
}
```

### Step 3: Pass logger through to library classes

Each class that currently uses `console.*` receives the logger via constructor:

**`DatabaseConnection`** — receives logger, uses it for sqlite-vec warnings:
```typescript
constructor(dbPath: string, options?: { logger?: Logger }) {
  this.logger = options?.logger ?? consoleLogger;
  // ...
  // Replace: console.warn(`sqlite-vec failed to load: ${msg}`);
  // With:    this.logger.warn(`sqlite-vec failed to load: ${msg}`);
}
```

**`MultiStrategySearch`** — receives logger for strategy failure logging:
```typescript
constructor(/* existing params */, logger?: Logger) {
  this.logger = logger ?? consoleLogger;
}
// Replace: console.error(`Search strategy failed: ${result.reason}`);
// With:    this.logger.error(`Search strategy failed: ${result.reason}`);
```

Same pattern for `ProviderFactory`, `EmbeddingFactory`, `HookHandler`, `LLMSummarizationManager`.

### Step 4: Wire logger from AppContext into service constructors

The domain services (or CoreService, depending on whether F10i.1 is done first) pass `this.context.logger` when constructing library classes:

```typescript
private getSearchService(projectId: string): MultiStrategySearch {
  return new MultiStrategySearch(
    entityStore, embeddingManager, relationshipStore,
    this.context.logger  // pass through
  );
}
```

### Step 5: Configure log level via ctx-sys config

**File**: `src/config/types.ts`

Add to the global config schema:

```yaml
# ~/.ctx-sys/config.yaml
log_level: warn  # debug | info | warn | error | silent
```

The CLI entry point and MCP server create `AppContext` with the configured log level:

```typescript
const config = loadConfig();
const logger = createLogger(config.logLevel ?? 'warn');
const context = new AppContext({ logger });
```

### Step 6: Update hook-handler impact report output

The `hook-handler.ts` impact report printer (lines 405-415) uses `console.log` for structured output. This is distinct from logging — it's a report formatter. Extract it into a return value instead of printing directly, and let the caller decide how to display it:

```typescript
// Before: console.log('\n=== Impact Analysis ===');
// After: return formatted string, let CLI/hook print it
formatImpactReport(report: ImpactReport): string {
  const lines: string[] = [];
  lines.push('\n=== Impact Analysis ===');
  lines.push(`Risk Level: ${report.riskLevel.toUpperCase()}`);
  // ...
  return lines.join('\n');
}
```

## File Changes

| File | Change |
|------|--------|
| `src/utils/logger.ts` | **New** — Logger interface, consoleLogger, nullLogger, createLogger |
| `src/context.ts` | **Update** — add `logger` property |
| `src/config/types.ts` | **Update** — add `logLevel` config option |
| `src/db/connection.ts` | **Update** — accept logger, replace 2 console.warn |
| `src/retrieval/multi-strategy-search.ts` | **Update** — accept logger, replace 3 console.error |
| `src/models/provider-factory.ts` | **Update** — accept logger, replace 4 console.warn |
| `src/embeddings/factory.ts` | **Update** — accept logger, replace 1 console.warn |
| `src/hooks/hook-handler.ts` | **Update** — accept logger, replace 9 console calls, extract report formatter |
| `src/summarization/llm-manager.ts` | **Update** — accept logger, replace 1 console.error |
| `src/services/core-service.ts` | **Update** — pass logger when constructing services |
| `src/cli/init.ts` | **Update** — create logger from config |
| `src/mcp/server.ts` | **Update** — create logger from config |

## Testing

- Tests use `nullLogger` to suppress output by default
- Add test that verifies `createLogger('error')` suppresses warn-level messages
- Verify no bare `console.*` calls remain in `src/` outside of `src/cli/`
- `tsc --noEmit` passes

## Success Criteria

- Zero bare `console.*` calls in library code (outside `src/cli/`)
- Log level is configurable via `config.yaml`
- Tests produce no console output by default
- MCP server runs silently (log level `error` or `silent` by default)
- CLI defaults to `warn` level, supports `--verbose` flag for `debug`

## Tasks

- [ ] Create `src/utils/logger.ts` with Logger interface and helpers
- [ ] Add logger to AppContext constructor
- [ ] Add `logLevel` to config schema
- [ ] Update DatabaseConnection to use logger
- [ ] Update MultiStrategySearch to use logger
- [ ] Update ProviderFactory to use logger
- [ ] Update EmbeddingFactory to use logger
- [ ] Update HookHandler to use logger + extract report formatter
- [ ] Update LLMSummarizationManager to use logger
- [ ] Wire logger through service constructors
- [ ] Add `--verbose` flag to CLI
- [ ] Verify no bare console.* in library code
- [ ] `tsc --noEmit` passes
