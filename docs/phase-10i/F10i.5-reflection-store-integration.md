# F10i.5 Reflection Store Integration

**Phase**: 10i - Code Quality & Infrastructure
**Priority**: Medium
**Dependencies**: F10i.1 (optional — easier if CoreService is already decomposed)

## Goal

Wire up the existing `ReflectionStore` (557 lines, fully implemented) to replace the simplified message-based reflection workaround in CoreService. This unlocks semantic search over reflections, auto-pruning, structured fields (`what_worked`, `what_did_not_work`, `next_strategy`), and embedding-based retrieval.

## Current State

### What exists but is unused

`src/agent/reflection.ts` — Full `ReflectionStore` class with:
- `store()` — stores structured reflections in `_reflections` table with fields: `task_description`, `attempt_number`, `outcome`, `what_worked_json`, `what_did_not_work_json`, `next_strategy`, `tags_json`, `embedding_json`, `related_entity_ids_json`
- `search()` — semantic search with cosine similarity over reflection embeddings, plus keyword fallback
- `getRecent()`, `getBySession()` — filtered retrieval
- `getSummary()` — aggregated stats (success rate, common tags, lessons learned)
- `formatForPrompt()` — formats reflections for LLM context injection
- Auto-pruning when session/project limits are reached (default: 20/session, 100/project)

The `_reflections` table is created by the schema (`src/db/schema.ts` lines 220-245) with proper indexes.

### What is currently used

`src/services/core-service.ts` lines 839-873 — Simplified workaround:
- `storeReflection()` — stores as a system message with `metadata.type: 'reflection'`
- `getReflections()` — fetches messages, filters by `metadata.type === 'reflection'`
- `searchReflections()` — uses `messageStore.search()`, filters by reflection metadata

Comment on line 839: `// Simplified reflection operations (would need full ReflectionStore in production)`

### Schema mismatch

The MCP tool `reflection_store` accepts:
```
{ session, content, type?, outcome?, tags? }
```

The `ReflectionStore.store()` accepts:
```
{ sessionId, taskDescription, outcome, whatWorked?, whatDidNotWork?, nextStrategy, tags?, relatedEntityIds? }
```

The MCP tool's flat `content` field doesn't map to the structured `ReflectionStore` input. This needs a mapping layer.

## Implementation Plan

### Step 1: Add a ReflectionStore accessor

**File**: `src/services/core-service.ts` (or `src/services/agent-service.ts` if F10i.1 is done)

Add lazy-initialized ReflectionStore alongside the other per-project caches:

```typescript
private reflectionStores = new Map<string, ReflectionStore>();

private getReflectionStore(projectId: string): ReflectionStore {
  if (!this.reflectionStores.has(projectId)) {
    const prefix = sanitizeProjectId(projectId);
    this.reflectionStores.set(projectId, new ReflectionStore(this.context.db, prefix));
  }
  return this.reflectionStores.get(projectId)!;
}
```

### Step 2: Update storeReflection method

Replace the message-based workaround with a call to `ReflectionStore.store()`:

```typescript
async storeReflection(
  projectId: string,
  sessionId: string,
  input: {
    content: string;
    type?: 'lesson' | 'observation' | 'decision';
    outcome?: 'success' | 'failure' | 'partial';
    tags?: string[];
  }
): Promise<Reflection> {
  const store = this.getReflectionStore(projectId);

  return store.store({
    sessionId,
    taskDescription: input.content,
    outcome: input.outcome ?? 'partial',
    nextStrategy: '',  // Optional — MCP tool doesn't surface this yet
    whatWorked: input.outcome === 'success' ? [input.content] : undefined,
    whatDidNotWork: input.outcome === 'failure' ? [input.content] : undefined,
    tags: [
      ...(input.tags ?? []),
      ...(input.type ? [input.type] : []),
    ],
  });
}
```

### Step 3: Update getReflections method

```typescript
async getReflections(
  projectId: string,
  sessionId: string,
  options?: { limit?: number }
): Promise<Reflection[]> {
  const store = this.getReflectionStore(projectId);
  return store.getBySession(sessionId, options?.limit ?? 20);
}
```

### Step 4: Update searchReflections method

```typescript
async searchReflections(
  projectId: string,
  query: string,
  options?: { type?: string; outcome?: string }
): Promise<Reflection[]> {
  const store = this.getReflectionStore(projectId);
  return store.search({
    query,
    outcome: options?.outcome as ReflectionOutcome | undefined,
    tags: options?.type ? [options.type] : undefined,
    limit: 10,
  });
}
```

### Step 5: Update MCP tool response format

The `reflection_store` and `reflection_query` tools in `tool-registry.ts` currently expect the simplified message-based response. Update them to handle the `Reflection` type from `ReflectionStore`:

```typescript
// reflection_store tool handler
const reflection = await this.coreService.storeReflection(projectId, session, input);
return {
  id: reflection.id,
  session_id: reflection.sessionId,
  content: reflection.taskDescription,
  outcome: reflection.outcome,
  tags: reflection.tags,
  created_at: reflection.createdAt,
};
```

### Step 6: Optionally wire up embeddings for semantic search

`ReflectionStore.search()` supports cosine similarity search over embeddings if reflections have `embedding_json` populated. To enable this:

```typescript
async storeReflection(projectId: string, sessionId: string, input: ReflectionInput): Promise<Reflection> {
  const store = this.getReflectionStore(projectId);
  const embeddingManager = await this.context.getEmbeddingManager(projectId);

  // Generate embedding for the reflection content
  const embeddings = await embeddingManager.provider.embed([input.content]);
  const embedding = embeddings[0] ?? [];

  return store.store({
    ...mappedInput,
    embedding,
  });
}
```

This enables the `search()` method's semantic branch, which computes cosine similarity between the query embedding and stored reflection embeddings.

### Step 7: Add clearProjectCache cleanup

Add `this.reflectionStores.delete(projectId)` to `clearProjectCache()`.

### Step 8: Migration for existing data

Any reflections stored as messages (via the old workaround) will still exist in the `_messages` table. These are not migrated — they remain accessible as messages but won't appear in `ReflectionStore` queries. This is acceptable since the old format was a simplified workaround and doesn't have the structured fields needed by `ReflectionStore`.

## File Changes

| File | Change |
|------|--------|
| `src/services/core-service.ts` | **Update** — replace 3 reflection methods + add accessor |
| `src/mcp/tool-registry.ts` | **Update** — update reflection_store and reflection_query response formats |
| `src/services/core-service.ts` or `src/services/agent-service.ts` | **Update** — add reflectionStores map + clearProjectCache |

## Testing

- Test `storeReflection` creates entries in `_reflections` table (not `_messages`)
- Test `getReflections` returns structured reflection objects
- Test `searchReflections` finds reflections by keyword
- Test auto-pruning triggers at session limit
- Verify `tsc --noEmit` passes

## Success Criteria

- Reflections stored in `_reflections` table with structured fields
- `ReflectionStore.search()` returns relevant results
- `ReflectionStore.getSummary()` works for session analytics
- Auto-pruning active at configured limits
- All existing MCP tools continue to work

## Tasks

- [ ] Add `getReflectionStore()` accessor
- [ ] Replace `storeReflection()` with `ReflectionStore.store()` call
- [ ] Replace `getReflections()` with `ReflectionStore.getBySession()` call
- [ ] Replace `searchReflections()` with `ReflectionStore.search()` call
- [ ] Update MCP tool response format
- [ ] Wire up embedding generation for semantic search
- [ ] Add clearProjectCache cleanup
- [ ] Test structured storage and retrieval
- [ ] `tsc --noEmit` passes
