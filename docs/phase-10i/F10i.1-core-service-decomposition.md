# F10i.1 CoreService Decomposition

**Phase**: 10i - Code Quality & Infrastructure
**Priority**: High
**Dependencies**: None

## Goal

Split `CoreService` (1051 lines, 43 public methods, 10 domains) into focused domain services that `CoreService` delegates to. This reduces cognitive load, improves testability, and makes each domain independently evolvable.

## Current State

`CoreService` at `src/services/core-service.ts` is a monolithic class that handles:

| Domain | Public Methods | Lines | Complexity |
|--------|---------------|-------|------------|
| Service Accessors | 10 (private) | 79-160 | Lazy init + caching |
| Project Management | 6 | 162-193 | Low — thin wrappers |
| Entity Management | 5 | 195-241 | Medium — embedding gen on add |
| Codebase Indexing | 4 | 243-351 | Medium — batch + timestamps |
| Conversation Memory | 10 | 353-503 | High — multi-strategy search, LLM |
| Graph RAG | 4 | 520-599 | Medium — traversal, stats |
| Context Retrieval | 1 (+1 private) | 601-744 | High — 6-stage pipeline |
| Agent Patterns | 10 | 746-873 | Medium — checkpoints, memory, reflections |
| Git Hooks | 2 (+1 private) | 876-984 | Medium — fs + git ops |
| Documents | 1 | 986-1006 | Low — delegates |
| Utilities | 2 | 1008-1051 | Low |

It also maintains 8 `Map<string, T>` caches for per-project service instances.

## Implementation Plan

### Step 1: Create domain service interfaces

**File**: `src/services/types.ts`

Define interfaces for each domain service so the MCP layer and CLI can program to interfaces rather than concrete classes:

```typescript
export interface IProjectService {
  createProject(name: string, path: string, config?: ProjectConfig): Promise<Project>;
  getProject(nameOrId: string): Promise<Project | null>;
  listProjects(): Promise<Project[]>;
  setActiveProject(nameOrId: string): Promise<Project>;
  deleteProject(nameOrId: string, keepData?: boolean): Promise<void>;
  getActiveProject(): Project | null;
}

export interface IEntityService {
  addEntity(projectId: string, input: EntityInput): Promise<Entity>;
  getEntity(projectId: string, id: string): Promise<Entity | null>;
  getEntityByName(projectId: string, qualifiedName: string): Promise<Entity | null>;
  searchEntities(projectId: string, query: string, options?: SearchOptions): Promise<Entity[]>;
  deleteEntity(projectId: string, id: string): Promise<void>;
  resolveEntityId(projectId: string, nameOrId: string): Promise<string>;
}

export interface IIndexingService {
  indexCodebase(projectId: string, path: string, options?: IndexOptions): Promise<IndexResult>;
  indexFile(projectId: string, filePath: string): Promise<void>;
  syncFromGit(projectId: string, options?: SyncOptions): Promise<SyncResult>;
  getIndexStatus(projectId: string): Promise<IndexStatus>;
  indexDocument(projectId: string, filePath: string, options?: DocOptions): Promise<void>;
}

export interface IConversationService {
  createSession(projectId: string, name?: string): Promise<Session>;
  getSession(projectId: string, sessionId: string): Promise<Session | null>;
  listSessions(projectId: string, options?: ListOptions): Promise<Session[]>;
  archiveSession(projectId: string, sessionId: string): Promise<void>;
  storeMessage(projectId: string, sessionId: string, message: MessageInput): Promise<Message>;
  getMessages(projectId: string, sessionId: string, options?: MessageOptions): Promise<Message[]>;
  getHistory(projectId: string, options?: HistoryOptions): Promise<Message[]>;
  summarizeSession(projectId: string, sessionId: string): Promise<SessionSummary>;
  searchDecisions(projectId: string, query: string, options?: DecisionOptions): Promise<Decision[]>;
  createDecision(projectId: string, input: DecisionInput): Promise<Decision>;
}

export interface IGraphService {
  addRelationship(projectId: string, input: RelationshipInput): Promise<void>;
  getRelationships(projectId: string, entityId: string, options?: RelOptions): Promise<Relationship[]>;
  queryGraph(projectId: string, startEntity: string, options?: GraphOptions): Promise<GraphResult>;
  getGraphStats(projectId: string): Promise<GraphStats>;
}

export interface IRetrievalService {
  queryContext(projectId: string, query: string, options?: QueryOptions): Promise<ContextResult>;
}

export interface IAgentService {
  saveCheckpoint(projectId: string, sessionId: string, state: object, meta?: object): Promise<Checkpoint>;
  loadCheckpoint(projectId: string, sessionId: string, checkpointId?: string): Promise<Checkpoint | null>;
  listCheckpoints(projectId: string, sessionId: string): Promise<Checkpoint[]>;
  deleteCheckpoint(projectId: string, checkpointId: string): Promise<void>;
  spillMemory(projectId: string, sessionId: string, options?: SpillOptions): Promise<SpillResult>;
  recallMemory(projectId: string, sessionId: string, query: string): Promise<RecallResult>;
  getMemoryStatus(projectId: string, sessionId: string): Promise<MemoryStatus>;
  storeReflection(projectId: string, sessionId: string, input: ReflectionInput): Promise<void>;
  getReflections(projectId: string, sessionId: string, options?: ReflectionOptions): Promise<Reflection[]>;
  searchReflections(projectId: string, query: string, options?: SearchOptions): Promise<Reflection[]>;
}

export interface IHooksService {
  installHooks(projectId: string, repoPath: string, config?: HookConfig): Promise<void>;
  getImpactReport(projectId: string, base: string, target: string): Promise<ImpactReport>;
}
```

### Step 2: Extract domain service implementations

Create one file per domain service in `src/services/`:

| File | Class | Methods | Extracted From |
|------|-------|---------|----------------|
| `src/services/project-service.ts` | `ProjectService` | 6 | Lines 162-193 |
| `src/services/entity-service.ts` | `EntityService` | 5 + `resolveEntityId` | Lines 195-241, 1030-1050 |
| `src/services/indexing-service.ts` | `IndexingService` | 4 + `indexDocument` | Lines 243-351, 986-1006 |
| `src/services/conversation-service.ts` | `ConversationService` | 10 | Lines 353-518 |
| `src/services/graph-service.ts` | `GraphService` | 4 | Lines 520-599 |
| `src/services/retrieval-service.ts` | `RetrievalService` | 1 + `calculateConfidence` | Lines 601-744 |
| `src/services/agent-service.ts` | `AgentService` | 10 | Lines 746-873 |
| `src/services/hooks-service.ts` | `HooksService` | 2 + `generateImpactSuggestions` | Lines 876-984 |

Each domain service receives `AppContext` in its constructor and owns its own `Map` caches for per-project sub-service instances. For example:

```typescript
export class ConversationService implements IConversationService {
  private sessionManagers = new Map<string, SessionManager>();
  private messageStores = new Map<string, MessageStore>();
  private decisionStores = new Map<string, DecisionStore>();

  constructor(private context: AppContext) {}

  private getSessionManager(projectId: string): SessionManager { ... }
  private getMessageStore(projectId: string): MessageStore { ... }
  private getDecisionStore(projectId: string): DecisionStore { ... }

  // ... all 10 public methods moved here unchanged
}
```

### Step 3: Refactor CoreService into a facade

`CoreService` becomes a thin delegation facade (~150 lines):

```typescript
export class CoreService {
  readonly projects: ProjectService;
  readonly entities: EntityService;
  readonly indexing: IndexingService;
  readonly conversations: ConversationService;
  readonly graph: GraphService;
  readonly retrieval: RetrievalService;
  readonly agent: AgentService;
  readonly hooks: HooksService;

  constructor(context: AppContext) {
    this.projects = new ProjectService(context);
    this.entities = new EntityService(context);
    this.indexing = new IndexingService(context);
    this.conversations = new ConversationService(context);
    this.graph = new GraphService(context);
    this.retrieval = new RetrievalService(context);
    this.agent = new AgentService(context);
    this.hooks = new HooksService(context);
  }

  // Delegation methods preserved for backwards compatibility
  async createProject(...args) { return this.projects.createProject(...args); }
  // ... etc
}
```

### Step 4: Update ToolRegistry to use domain services

The tool registry currently calls `this.coreService.methodName()`. Update to use the domain sub-services:

```typescript
// Before
const result = await this.coreService.queryContext(projectId, query, options);

// After
const result = await this.coreService.retrieval.queryContext(projectId, query, options);
```

This is a mechanical find-and-replace per domain, guided by the method groupings above.

### Step 5: Update CLI commands

Same pattern as step 4 — each CLI command file updates its `coreService.method()` calls to `coreService.domain.method()`. Since CLI commands import `CoreService` via `src/cli/context.ts`, no import changes are needed.

### Step 6: Update `clearProjectCache`

The current `clearProjectCache()` method clears all 8 maps. After decomposition, each domain service owns its own maps. Add a `clearProjectCache(projectId)` method to each domain service, and have `CoreService.clearProjectCache()` delegate to all of them.

## File Changes

| File | Change |
|------|--------|
| `src/services/types.ts` | **New** — domain service interfaces |
| `src/services/project-service.ts` | **New** — extracted from CoreService |
| `src/services/entity-service.ts` | **New** — extracted from CoreService |
| `src/services/indexing-service.ts` | **New** — extracted from CoreService |
| `src/services/conversation-service.ts` | **New** — extracted from CoreService |
| `src/services/graph-service.ts` | **New** — extracted from CoreService |
| `src/services/retrieval-service.ts` | **New** — extracted from CoreService |
| `src/services/agent-service.ts` | **New** — extracted from CoreService |
| `src/services/hooks-service.ts` | **New** — extracted from CoreService |
| `src/services/core-service.ts` | **Rewrite** — thin facade (~150 lines) |
| `src/services/index.ts` | **Update** — export new services |
| `src/mcp/tool-registry.ts` | **Update** — use `coreService.domain.method()` |
| `src/cli/*.ts` (22 files) | **Update** — use `coreService.domain.method()` |

## Testing

- All existing tests should continue to pass since `CoreService` still exposes the same public API via delegation
- Add unit tests for each domain service in isolation (inject mock `AppContext`)
- Verify `tsc --noEmit` passes throughout

## Success Criteria

- `CoreService` is under 200 lines
- No domain service exceeds 300 lines
- Each domain service is independently testable with a mock `AppContext`
- All existing CLI commands and MCP tools work unchanged
- `tsc --noEmit` passes cleanly

## Tasks

- [ ] Create `src/services/types.ts` with domain service interfaces
- [ ] Extract `ProjectService`
- [ ] Extract `EntityService` (includes `resolveEntityId`)
- [ ] Extract `IndexingService` (includes `indexDocument`)
- [ ] Extract `ConversationService`
- [ ] Extract `GraphService`
- [ ] Extract `RetrievalService`
- [ ] Extract `AgentService`
- [ ] Extract `HooksService`
- [ ] Refactor `CoreService` into facade
- [ ] Update `ToolRegistry` calls
- [ ] Update CLI command calls
- [ ] Verify `tsc --noEmit` passes
- [ ] Run full test suite
