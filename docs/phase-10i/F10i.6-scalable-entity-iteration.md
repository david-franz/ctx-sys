# F10i.6 Scalable Entity Iteration

**Phase**: 10i - Code Quality & Infrastructure
**Priority**: Medium
**Dependencies**: None

## Goal

Replace the unbounded `list({ limit: 100000 })` call during codebase indexing with paginated iteration, preventing memory exhaustion on large codebases.

## Current State

In `src/services/core-service.ts`, the `indexCodebase()` method (around line 272) fetches all entities to generate embeddings:

```typescript
const allEntities = await entityStore.list({ limit: 100000 });
```

This loads up to 100,000 entity objects into memory simultaneously. Each entity includes `content` (full source code), `summary`, `metadata`, etc. For a large codebase with 50K+ entities, this could consume hundreds of MB of heap memory.

The entities are then filtered and passed to `embeddingManager.embedEntities()` which processes them in batches internally — but the full list is still held in memory during filtering and handoff.

## Implementation Plan

### Step 1: Add cursor-based pagination to EntityStore

**File**: `src/entities/store.ts`

Add a paginated list method that uses `OFFSET`/`LIMIT` or cursor-based iteration:

```typescript
/**
 * Iterate entities in fixed-size pages.
 * Yields arrays of entities, one page at a time.
 */
*listPaginated(options?: {
  type?: EntityType;
  pageSize?: number;
  where?: string;
}): Generator<Entity[]> {
  const pageSize = options?.pageSize ?? 500;
  let offset = 0;

  while (true) {
    const query = `
      SELECT * FROM ${this.prefix}_entities
      ${options?.type ? `WHERE type = ?` : ''}
      ORDER BY id
      LIMIT ? OFFSET ?
    `;
    const params = options?.type
      ? [options.type, pageSize, offset]
      : [pageSize, offset];
    const rows = this.db.all(query, params);

    if (rows.length === 0) break;

    yield rows.map(row => this.rowToEntity(row));
    offset += pageSize;

    if (rows.length < pageSize) break;
  }
}
```

Using a synchronous generator is appropriate here since `better-sqlite3` is synchronous.

### Step 2: Add streaming embedEntities to EmbeddingManager

**File**: `src/embeddings/manager.ts`

Add a method that accepts an iterable instead of a full array:

```typescript
/**
 * Embed entities from a paginated source, processing one page at a time.
 * Only one page of entities is in memory at any given time.
 */
async embedEntitiesPaginated(
  pages: Iterable<Entity[]>,
  options?: { force?: boolean }
): Promise<{ embedded: number; skipped: number }> {
  let embedded = 0;
  let skipped = 0;

  for (const page of pages) {
    // Filter to entities that need embedding (content hash changed)
    const needsEmbedding = options?.force
      ? page
      : page.filter(e => !this.isAlreadyEmbedded(e));

    skipped += page.length - needsEmbedding.length;

    if (needsEmbedding.length === 0) continue;

    // Existing batch embedding logic, operating on one page at a time
    await this.embedBatch(needsEmbedding);
    embedded += needsEmbedding.length;
  }

  return { embedded, skipped };
}
```

### Step 3: Update indexCodebase to use paginated flow

**File**: `src/services/core-service.ts` (or `src/services/indexing-service.ts` if F10i.1 is done)

```typescript
// Before
const allEntities = await entityStore.list({ limit: 100000 });
const toEmbed = allEntities.filter(e => e.content && e.content.length > 0);
const embedResult = await embeddingManager.embedEntities(toEmbed, { force: options?.force });

// After
const pages = entityStore.listPaginated({ pageSize: 500 });
const embedResult = await embeddingManager.embedEntitiesPaginated(pages, {
  force: options?.force
});
```

### Step 4: Add a count-based progress indicator

Since we no longer know the total count upfront, add an optional progress callback:

```typescript
async embedEntitiesPaginated(
  pages: Iterable<Entity[]>,
  options?: {
    force?: boolean;
    onProgress?: (processed: number, embedded: number) => void;
  }
): Promise<{ embedded: number; skipped: number }> {
  let processed = 0;
  let embedded = 0;

  for (const page of pages) {
    // ... process page ...
    processed += page.length;
    options?.onProgress?.(processed, embedded);
  }
  // ...
}
```

The CLI can use this for progress output:

```typescript
const result = await indexingService.indexCodebase(projectId, path, {
  onProgress: (processed, embedded) => {
    process.stdout.write(`\rProcessed ${processed} entities, embedded ${embedded}...`);
  }
});
```

## File Changes

| File | Change |
|------|--------|
| `src/entities/store.ts` | **Update** — add `listPaginated()` generator method |
| `src/embeddings/manager.ts` | **Update** — add `embedEntitiesPaginated()` method |
| `src/services/core-service.ts` | **Update** — use paginated flow in `indexCodebase()` |

## Testing

- Test `listPaginated()` yields correct page sizes
- Test `listPaginated()` with fewer entities than page size (single page)
- Test `listPaginated()` with exactly page size (no off-by-one)
- Test `embedEntitiesPaginated()` processes all pages
- Test memory stays bounded (optional — profile with large fixture)
- `tsc --noEmit` passes

## Success Criteria

- `indexCodebase()` never holds more than one page of entities in memory
- Page size is configurable (default 500)
- Embedding results are identical to the non-paginated version
- Progress callback works for CLI output
- Existing tests pass unchanged

## Tasks

- [ ] Add `listPaginated()` to EntityStore
- [ ] Add `embedEntitiesPaginated()` to EmbeddingManager
- [ ] Update `indexCodebase()` to use paginated flow
- [ ] Add progress callback support
- [ ] Verify `tsc --noEmit` passes
- [ ] Add pagination unit tests
- [ ] Run full test suite
