# F10i.2 Type Safety — Eliminate `as any` Casts

**Phase**: 10i - Code Quality & Infrastructure
**Priority**: High
**Dependencies**: None

## Goal

Remove all 28 `as any` casts across 10 source files by introducing proper type guards, branded string helpers, and interface extensions. This turns runtime type mismatches into compile-time errors.

## Current State

28 `as any` casts across 10 files, falling into 3 categories:

### Category 1: String → Narrow Union (19 casts)

External inputs (MCP tool params, CLI options, AST parser output) arrive as `string` but are assigned to narrow union types like `EntityType`, `GraphRelationshipType`, `IndexDepth`, etc.

**Files affected:**
- `src/mcp/tool-registry.ts` — 5 casts (config, depth, document type, strategies, hooks)
- `src/services/core-service.ts` — 4 casts (relationship type, types filter, triggerType)
- `src/ast/relationships/typescript-extractor.ts` — 6 casts (symbol.type → relationship sourceType/targetType)
- `src/ast/relationships/python-extractor.ts` — 3 casts (same pattern)
- `src/indexer/indexer.ts` — 2 casts (symbol.type → EntityType, parseResult → specific type)
- `src/cli/extract-rel-cmd.ts` — 2 casts (CLI option → EntityType, relationship string)
- `src/cli/instructions.ts` — 1 cast (entity.type → EntityType)

### Category 2: Property Access on Untyped Metadata (5 casts)

Accessing properties on `Record<string, unknown>` or loosely-typed objects.

**Files affected:**
- `src/documents/document-indexer.ts` — `(existing.metadata as any)?.hash`
- `src/embeddings/manager.ts` — `(this.provider as any).maxChars`
- `src/models/provider-factory.ts` — `(provider as any).name`
- `src/cli/status.ts` — `(ollamaResult as any).models` (3 occurrences)

### Category 3: Broad Type → Specific Type (4 casts)

Generic array types passed where specific type arrays are expected.

**Files affected:**
- `src/graph/traversal.ts` — `entityTypes as any` (string[] → EntityType[])
- `src/mcp/tool-registry.ts` — `strategies as any`, `hooks as any`

## Implementation Plan

### Fix Category 1: Runtime Validation Helpers

Create a set of type guard/assertion utilities:

**File**: `src/utils/type-guards.ts`

```typescript
import { EntityType, ENTITY_TYPES } from '../entities/types';
import { GraphRelationshipType, RELATIONSHIP_TYPES } from '../graph/types';

// Sets for O(1) lookup
const entityTypeSet = new Set<string>(ENTITY_TYPES);
const relTypeSet = new Set<string>(RELATIONSHIP_TYPES);

/** Type guard: is this string a valid EntityType? */
export function isEntityType(s: string): s is EntityType {
  return entityTypeSet.has(s);
}

/** Assert or return undefined */
export function toEntityType(s: string): EntityType | undefined {
  return isEntityType(s) ? s : undefined;
}

/** Assert or throw */
export function asEntityType(s: string): EntityType {
  if (!isEntityType(s)) throw new Error(`Invalid entity type: ${s}`);
  return s;
}

/** Type guard for relationship types */
export function isRelationshipType(s: string): s is GraphRelationshipType {
  return relTypeSet.has(s);
}

export function asRelationshipType(s: string): GraphRelationshipType {
  if (!isRelationshipType(s)) throw new Error(`Invalid relationship type: ${s}`);
  return s;
}

// Same pattern for: IndexDepth, DocumentType, SearchStrategy, HookType, etc.
```

This requires exporting the union values as const arrays from the type files:

```typescript
// src/entities/types.ts
export const ENTITY_TYPES = [
  'file', 'module', 'class', 'function', 'method', 'interface', 'type', 'variable',
  'document', 'section', 'requirement', 'feature', 'user-story',
  // ... all 27 types
] as const;
export type EntityType = typeof ENTITY_TYPES[number];

// src/graph/types.ts
export const RELATIONSHIP_TYPES = [
  'CONTAINS', 'CALLS', 'IMPORTS', 'IMPLEMENTS', 'EXTENDS',
  'MENTIONS', 'RELATES_TO', 'DEPENDS_ON', 'DEFINED_IN',
  'USES', 'REFERENCES', 'DOCUMENTS', 'CONFIGURES', 'TESTS'
] as const;
export type GraphRelationshipType = typeof RELATIONSHIP_TYPES[number];
```

**Then replace each cast:**

```typescript
// Before (tool-registry.ts line 428)
depth: depth as any,

// After
depth: asIndexDepth(depth),

// Before (core-service.ts line 529)
relationship: input.type as any,

// After
relationship: asRelationshipType(input.type),
```

### Fix Category 1b: AST Extractors

The AST extractors use `symbol.type` which is the parser's own string type. Define a mapping:

**File**: `src/ast/types.ts` — add:

```typescript
/** AST symbol types that directly map to EntityType */
export type AstSymbolType = 'function' | 'class' | 'method' | 'interface' | 'type' | 'variable' | 'module';

// Compile-time assertion that all AstSymbolType values are valid EntityType values
type AssertSubset<T extends EntityType> = T;
type _Check = AssertSubset<AstSymbolType>;
```

Then update the `RelationshipInput` type to accept `EntityType` for `sourceType`/`targetType` instead of `string`, and update the symbol type in the AST parser output to be `AstSymbolType` (which is a subset of `EntityType`). This eliminates the need for casts in all 9 extractor locations.

### Fix Category 2: Interface Extensions

**`metadata.hash` access** (`document-indexer.ts`):

Define a metadata shape for document entities:

```typescript
interface DocumentMetadata {
  hash: string;
  docType: string;
  [key: string]: unknown;
}

// Then use type narrowing:
const meta = existing.metadata as Record<string, unknown>;
if (meta && typeof meta.hash === 'string' && meta.hash === hash) { ... }
```

**`provider.maxChars` access** (`embeddings/manager.ts`):

Extend the `EmbeddingProvider` interface:

```typescript
export interface EmbeddingProvider {
  embed(texts: string[]): Promise<number[][]>;
  readonly dimensions: number;
  readonly maxChars?: number;  // Add optional property
}
```

Then access directly without cast: `this.provider.maxChars`.

**`provider.name` access** (`models/provider-factory.ts`):

Add `name` to the `LLMSummarizer` interface:

```typescript
export interface LLMSummarizer {
  summarize(content: string, options?: SummarizeOptions): Promise<string>;
  readonly name?: string;  // Add optional property
}
```

**`ollamaResult.models` access** (`cli/status.ts`):

Define a typed health check result:

```typescript
interface OllamaHealthResult {
  ok: boolean;
  models?: string[];
  error?: string;
}
```

Cast the result to this type instead of `any`.

### Fix Category 3: Generic Array → Typed Array

**`entityTypes as any` in `graph/traversal.ts`:**

Update `getByType()` signature to accept `string[]` and validate internally, or use the `isEntityType` guard to filter/validate the array:

```typescript
const validTypes = entityTypes.filter(isEntityType);
const entities = await this.entityStore.getByType(validTypes);
```

**`strategies as any` and `hooks as any` in `tool-registry.ts`:**

Same pattern — validate with type guards before passing to CoreService.

## File Changes

| File | Change |
|------|--------|
| `src/utils/type-guards.ts` | **New** — type guard/assertion utilities |
| `src/entities/types.ts` | **Update** — export `ENTITY_TYPES` const array, derive union from it |
| `src/graph/types.ts` | **Update** — export `RELATIONSHIP_TYPES` const array, derive union from it |
| `src/ast/types.ts` | **Update** — define `AstSymbolType` as EntityType subset |
| `src/embeddings/types.ts` | **Update** — add `maxChars?` to `EmbeddingProvider` |
| `src/summarization/types.ts` | **Update** — add `name?` to `LLMSummarizer` |
| `src/mcp/tool-registry.ts` | **Update** — replace 5 `as any` with type guards |
| `src/services/core-service.ts` | **Update** — replace 4 `as any` with type guards |
| `src/ast/relationships/typescript-extractor.ts` | **Update** — remove 6 casts via `AstSymbolType` |
| `src/ast/relationships/python-extractor.ts` | **Update** — remove 3 casts via `AstSymbolType` |
| `src/indexer/indexer.ts` | **Update** — replace 2 casts |
| `src/graph/traversal.ts` | **Update** — replace 1 cast with filter |
| `src/documents/document-indexer.ts` | **Update** — replace 1 cast with property check |
| `src/embeddings/manager.ts` | **Update** — remove 1 cast |
| `src/models/provider-factory.ts` | **Update** — remove 1 cast |
| `src/cli/status.ts` | **Update** — replace 3 casts with typed result |
| `src/cli/extract-rel-cmd.ts` | **Update** — replace 2 casts |
| `src/cli/instructions.ts` | **Update** — replace 1 cast |

## Testing

- `tsc --noEmit` must pass with zero errors (this is the primary validation)
- Type guards should reject invalid strings at runtime with clear error messages
- Add unit tests for type guard utilities in `tests/phase-10i/type-guards.test.ts`
- Run full test suite to catch any behavioral regressions

## Success Criteria

- Zero `as any` casts remain in `src/`
- `tsc --noEmit` passes
- Invalid type strings from external inputs (MCP, CLI) produce clear error messages instead of silently passing through
- All existing tests pass

## Tasks

- [ ] Create `src/utils/type-guards.ts` with guard functions
- [ ] Refactor `EntityType` and `GraphRelationshipType` to derive from const arrays
- [ ] Define `AstSymbolType` and update AST extractor interfaces
- [ ] Fix Category 1 casts (19 locations) with type guards
- [ ] Fix Category 2 casts (5 locations) with interface extensions
- [ ] Fix Category 3 casts (4 locations) with array validation
- [ ] Verify `tsc --noEmit` passes
- [ ] Add type guard unit tests
- [ ] Run full test suite
