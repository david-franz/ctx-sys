# F10f.6 Entity Type Scoring — Prefer Code Over File Stubs

**Phase**: 10f - Retrieval Quality
**Priority**: Medium
**Dependencies**: None

## Problem

File-level entities dominate results because they're lightweight (few tokens) and have broad keyword matches. For "how does embedding work", the results include:

```
class    EmbeddingManager          54%    (genuinely useful)
file     manager.ts                27%    (stub — just imports/exports)
file     mock.ts                   27%    (stub)
file     openai.ts                 26%    (stub)
file     factory.ts                26%    (stub)
file     connection.ts             16%    (irrelevant)
file     formatters.ts             16%    (irrelevant)
file     schema.ts                 16%    (irrelevant)
file     init.ts                   16%    (irrelevant)
```

The file stubs (`manager.ts`, `mock.ts`) are redundant — their classes/functions are already included as separate entities with more detail. The unrelated files (`connection.ts`, `formatters.ts`) are noise that got picked up through weak keyword or graph matches.

### Root Cause

The heuristic reranker (`src/retrieval/heuristic-reranker.ts`) has boosts for:
- Code entities with `filePath` (+0.1)
- Entities with summary (+0.1)
- Entities with many connections (+0.2)
- Instructions with priority (+0.5 high, -0.5 low)

But it has **no penalty for redundant file stubs** when their contents (classes, functions) are already in the results.

## Implementation

### Step 1: Add entity type weighting to reranker

**File**: `src/retrieval/heuristic-reranker.ts`

Add type-based scoring after the existing boosts:

```typescript
// Prefer substantive entities over stubs
const typeWeight: Record<string, number> = {
  'class': 0.15,
  'function': 0.1,
  'method': 0.1,
  'interface': 0.05,
  'type': 0.05,
  'document': 0.1,
  'section': 0.05,
  'file': -0.1,      // Penalize file stubs (their contents are separate entities)
  'module': -0.05,
};
boost += typeWeight[entity.type] || 0;
```

### Step 2: Deduplicate file stubs when contents present

**File**: `src/retrieval/context-assembler.ts`

In the assembly loop, skip file-type entities if any of their child entities (functions, classes from that file) are already in the results:

```typescript
// Build set of file paths already represented by code entities
const representedFiles = new Set<string>();
for (const result of sorted) {
  if (result.entity.type !== 'file' && result.entity.filePath) {
    representedFiles.add(result.entity.filePath);
  }
}

// In the assembly loop:
for (const result of sorted) {
  if (result.entity.type === 'file' && result.entity.filePath && representedFiles.has(result.entity.filePath)) {
    continue;  // Skip file stub — its contents are already included
  }
  // ... rest of assembly
}
```

## Expected Result

```
# Before:
class    EmbeddingManager          54%
file     manager.ts                27%    ← redundant
file     mock.ts                   27%    ← redundant
file     formatters.ts             16%    ← noise

# After:
class    EmbeddingManager          54%
class    OllamaEmbeddingProvider   52%
class    MockEmbeddingProvider      54%
document F10.2-incremental-embed   69%
```

More substantive content, less noise, same token budget.

## Success Criteria

- File stubs don't appear when their classes/functions are already in results
- Unrelated file entities get a reranking penalty
- Classes and functions get a small boost
- Results feel more focused and useful
