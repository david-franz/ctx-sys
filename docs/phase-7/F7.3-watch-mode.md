# F7.3 Watch Mode

**Phase**: 7 - Configuration & Polish
**Priority**: Low
**Dependencies**: F2.3 Codebase Indexing

## Goal

Real-time file monitoring and incremental updates.

## Overview

Watch mode monitors the project for file changes and updates the index automatically:
- Detect file additions, modifications, deletions
- Debounce rapid changes
- Re-index only affected files
- Update relationships

## Implementation

### File: `src/watch/watcher.ts`

```typescript
import chokidar, { FSWatcher } from 'chokidar';
import { CodebaseIndexer } from '../indexing/codebase-indexer';
import { EntityStore } from '../entities/store';
import { RelationshipStore } from '../relationships/store';
import { EmbeddingManager } from '../embeddings/manager';

interface WatchOptions {
  ignore?: string[];
  debounce?: number;          // ms to wait before processing
  onEvent?: (event: WatchEvent) => void;
}

interface WatchEvent {
  type: 'add' | 'change' | 'delete';
  path: string;
  timestamp: Date;
}

export class FileWatcher {
  private watcher: FSWatcher | null = null;
  private pendingChanges: Map<string, WatchEvent> = new Map();
  private debounceTimer: NodeJS.Timeout | null = null;

  constructor(
    private projectPath: string,
    private indexer: CodebaseIndexer,
    private entityStore: EntityStore,
    private relationshipStore: RelationshipStore,
    private embeddingManager: EmbeddingManager,
    private options: WatchOptions = {}
  ) {}

  start(): void {
    if (this.watcher) {
      throw new Error('Watcher already running');
    }

    const ignorePatterns = [
      '**/node_modules/**',
      '**/.git/**',
      '**/dist/**',
      '**/build/**',
      ...(this.options.ignore || [])
    ];

    this.watcher = chokidar.watch(this.projectPath, {
      ignored: ignorePatterns,
      persistent: true,
      ignoreInitial: true,
      awaitWriteFinish: {
        stabilityThreshold: 100,
        pollInterval: 100
      }
    });

    this.watcher
      .on('add', path => this.handleEvent('add', path))
      .on('change', path => this.handleEvent('change', path))
      .on('unlink', path => this.handleEvent('delete', path))
      .on('error', error => console.error('Watch error:', error));

    console.log(`Watching ${this.projectPath} for changes...`);
  }

  stop(): void {
    if (this.watcher) {
      this.watcher.close();
      this.watcher = null;
    }
    if (this.debounceTimer) {
      clearTimeout(this.debounceTimer);
      this.debounceTimer = null;
    }
    this.pendingChanges.clear();
  }

  private handleEvent(type: WatchEvent['type'], path: string): void {
    // Filter by supported file types
    if (!this.isSupportedFile(path)) {
      return;
    }

    const event: WatchEvent = {
      type,
      path,
      timestamp: new Date()
    };

    this.options.onEvent?.(event);

    // Add to pending changes
    this.pendingChanges.set(path, event);

    // Debounce processing
    if (this.debounceTimer) {
      clearTimeout(this.debounceTimer);
    }

    this.debounceTimer = setTimeout(
      () => this.processChanges(),
      this.options.debounce || 500
    );
  }

  private async processChanges(): Promise<void> {
    const changes = new Map(this.pendingChanges);
    this.pendingChanges.clear();

    console.log(`Processing ${changes.size} file changes...`);

    for (const [path, event] of changes) {
      try {
        switch (event.type) {
          case 'add':
          case 'change':
            await this.handleFileUpdate(path);
            break;
          case 'delete':
            await this.handleFileDelete(path);
            break;
        }
      } catch (error) {
        console.error(`Error processing ${path}:`, error);
      }
    }

    console.log('Changes processed.');
  }

  private async handleFileUpdate(path: string): Promise<void> {
    // Remove existing entities for this file
    const existing = await this.entityStore.getByFile(path);
    for (const entity of existing) {
      await this.relationshipStore.deleteForEntity(entity.id);
      await this.embeddingManager.deleteForEntity(entity.id);
    }
    await this.entityStore.deleteByFile(path);

    // Re-index the file
    await this.indexer.indexFile(path, {
      depth: 'full',
      summarize: true
    });
  }

  private async handleFileDelete(path: string): Promise<void> {
    const entities = await this.entityStore.getByFile(path);
    for (const entity of entities) {
      await this.relationshipStore.deleteForEntity(entity.id);
      await this.embeddingManager.deleteForEntity(entity.id);
      await this.entityStore.delete(entity.id);
    }
  }

  private isSupportedFile(path: string): boolean {
    const supportedExtensions = [
      '.ts', '.tsx', '.js', '.jsx', '.mjs',
      '.py', '.go', '.rs', '.java',
      '.c', '.h', '.cpp', '.hpp',
      '.md'
    ];
    return supportedExtensions.some(ext => path.endsWith(ext));
  }
}
```

## CLI Command

```bash
ctx-sys watch [options]

Options:
  --project <name>    Target project
  --debounce <ms>     Debounce interval (default: 500)

Example:
  ctx-sys watch --project my-app
```

## Tasks

- [ ] Implement FileWatcher
- [ ] Implement debouncing
- [ ] Handle file additions
- [ ] Handle file modifications
- [ ] Handle file deletions
- [ ] Add CLI command
- [ ] Write unit tests

## Testing

```typescript
describe('FileWatcher', () => {
  it('should detect file additions');
  it('should detect file modifications');
  it('should detect file deletions');
  it('should debounce rapid changes');
  it('should filter unsupported files');
});
```
