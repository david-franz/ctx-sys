# F10b.12 Wire Memory Tier Tools (spill/recall/status)

**Phase**: 10b - MCP Tool Fixes
**Priority**: High
**Dependencies**: None

## Problem

All three memory tier MCP tools (`memory_spill`, `memory_recall`, `memory_status`) return hardcoded empty results. The actual `MemoryTierManager` class is fully implemented and tested in `src/agent/memory-tier.ts` but never wired into `CoreService`.

### Root Cause

`CoreService` methods (lines 599-613) are placeholder stubs:

```typescript
async spillMemory(...): Promise<SpillResult> {
  // Placeholder - would implement with MemoryTierManager
  return { spilledCount: 0, tokensFreed: 0 };
}
```

### Existing Implementation

`MemoryTierManager` in `src/agent/memory-tier.ts` provides:
- `addToHot()` — add items to hot memory
- `spillToWarm()` — move old hot items to warm/cold tiers
- `recall()` — search warm/cold storage by relevance
- `getStatus()` — get tier statistics (hot/warm/cold counts and tokens)
- Full tests in `tests/phase-8/memory-tier.test.ts`

## Implementation Plan

### Step 1: Add MemoryTierManager to CoreService

**File**: `src/services/core-service.ts`

```typescript
import { MemoryTierManager } from '../agent/memory-tier';

// Add to lazy-initialized services
private memoryManagers: Map<string, MemoryTierManager> = new Map();

private getMemoryManager(projectId: string): MemoryTierManager {
  if (!this.memoryManagers.has(projectId)) {
    this.memoryManagers.set(projectId, new MemoryTierManager(
      this.context.db,
      projectId
    ));
  }
  return this.memoryManagers.get(projectId)!;
}
```

### Step 2: Wire Up Methods

```typescript
async spillMemory(projectId: string, sessionId: string, options?: SpillOptions): Promise<SpillResult> {
  const manager = this.getMemoryManager(projectId);
  const result = await manager.spillToWarm(sessionId, {
    maxTokens: options?.threshold
  });
  return {
    spilledCount: result.spilledCount,
    tokensFreed: result.tokensFreed
  };
}

async recallMemory(projectId: string, sessionId: string, query: string): Promise<RecallResult> {
  const manager = this.getMemoryManager(projectId);
  const items = await manager.recall(sessionId, query);
  return {
    items: items.map(item => ({
      id: item.id,
      content: item.content,
      type: item.type,
      relevance: item.relevanceScore
    })),
    tokensRecalled: items.reduce((sum, item) => sum + (item.tokenCount || 0), 0)
  };
}

async getMemoryStatus(projectId: string, sessionId: string): Promise<MemoryStatus> {
  const manager = this.getMemoryManager(projectId);
  const status = await manager.getStatus(sessionId);
  return {
    hotCount: status.hotCount,
    coldCount: status.coldCount,
    hotTokens: status.hotTokens,
    coldTokens: status.coldTokens
  };
}
```

### Step 3: Clear Memory Manager on Project Cache Clear

Add `this.memoryManagers.delete(projectId)` to `clearProjectCache()`.

## Testing

```typescript
describe('memory tier MCP tools', () => {
  it('memory_status should reflect added items', async () => {
    // Add items via store_message, then check status
    const status = await mcp.call('memory_status', { session: testSession });
    expect(status.hotCount).toBeGreaterThanOrEqual(0);
  });

  it('memory_spill should move items to cold', async () => {
    const result = await mcp.call('memory_spill', {
      session: testSession, threshold: 100
    });
    expect(result).toHaveProperty('spilledCount');
    expect(result).toHaveProperty('tokensFreed');
  });

  it('memory_recall should find relevant items', async () => {
    const result = await mcp.call('memory_recall', {
      session: testSession, query: 'database schema'
    });
    expect(result).toHaveProperty('items');
    expect(result).toHaveProperty('tokensRecalled');
  });
});
```

## Success Criteria

- `memory_status` returns real counts from `MemoryTierManager`
- `memory_spill` actually moves items between tiers
- `memory_recall` returns relevant items from cold/warm storage
