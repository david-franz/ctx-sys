# F10b.10 Fix reflection_query Search and Filters

**Phase**: 10b - MCP Tool Fixes
**Priority**: Medium
**Dependencies**: None

## Problem

Two issues with `reflection_query`:

1. **LIKE-only search**: Uses `messageStore.search()` which requires exact substring matches. Natural language queries like "search entities bug" fail because the content contains "search_entities" (with underscore)
2. **Ignored filters**: The `type` and `outcome` parameters are destructured in the handler but never passed to `searchReflections()`

### Observed Behavior

```
// Stored reflection about search entity bugs
reflection_query({ query: "search entities bug" }) → 0 results
reflection_query({ query: "search ranking may need tuning" }) → 1 result (exact substring)

// Type filter silently ignored
reflection_query({ query: "test", type: "bug" }) → searches all types
```

## Implementation Plan

### Step 1: Add Token-Based Search

**File**: `src/services/core-service.ts` (lines 641-645)

Split query into tokens and search for each token:

```typescript
async searchReflections(
  projectId: string,
  query: string,
  options?: { type?: string; outcome?: string }
): Promise<any[]> {
  const messageStore = this.getMessageStore(projectId);

  // Get all reflection messages
  const allMessages = await messageStore.query({ limit: 1000 });
  const reflections = allMessages.filter(m => m.metadata?.type === 'reflection');

  // Apply type filter
  let filtered = reflections;
  if (options?.type) {
    filtered = filtered.filter(m => m.metadata?.reflectionType === options.type);
  }
  if (options?.outcome) {
    filtered = filtered.filter(m => m.metadata?.outcome === options.outcome);
  }

  // Token-based relevance scoring
  const queryTokens = query.toLowerCase().split(/\s+/);
  const scored = filtered.map(m => {
    const content = m.content.toLowerCase();
    const matches = queryTokens.filter(t => content.includes(t));
    return { message: m, score: matches.length / queryTokens.length };
  });

  // Return sorted by relevance, filtering out zero-score results
  return scored
    .filter(s => s.score > 0)
    .sort((a, b) => b.score - a.score)
    .map(s => s.message);
}
```

### Step 2: Pass Filters in MCP Handler

**File**: `src/mcp/tool-registry.ts` — `reflection_query` handler

```typescript
const reflections = await this.coreService.searchReflections(projectId, query, {
  type, outcome
});
```

## Testing

```typescript
describe('reflection_query', () => {
  it('should find reflections with token-based search', async () => {
    await mcp.call('reflection_store', {
      session: testSession,
      content: 'The search_entities tool has ranking issues',
      type: 'bug'
    });
    const result = await mcp.call('reflection_query', {
      query: 'search entities ranking'
    });
    expect(result.count).toBeGreaterThan(0);
  });

  it('should respect type filter', async () => {
    const result = await mcp.call('reflection_query', {
      query: 'search', type: 'observation'
    });
    expect(result.reflections.every(r => r.type === 'observation')).toBe(true);
  });
});
```

## Success Criteria

- Token-based search finds reflections even without exact substring matches
- Type and outcome filters are applied correctly
- Results are ranked by relevance
