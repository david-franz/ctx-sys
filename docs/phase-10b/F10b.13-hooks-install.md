# F10b.13 Implement hooks_install

**Phase**: 10b - MCP Tool Fixes
**Priority**: Medium
**Dependencies**: None

## Problem

`hooks_install` reports `success: true` and `installed: ["post-commit"]` but writes no actual git hook files. The implementation is a silent no-op stub.

### Root Cause

`CoreService.installHooks()` (lines 699-703) is empty:

```typescript
async installHooks(projectId: string, repoPath: string, config?: HookConfig): Promise<void> {
  // Would use HookInstaller in production
  // For now, this is a no-op placeholder
}
```

The existing `HookInstaller` class exists at `src/hooks/hook-installer.ts` but is never used.

## Implementation Plan

### Step 1: Wire HookInstaller into CoreService

**File**: `src/services/core-service.ts`

```typescript
import { HookInstaller } from '../hooks/hook-installer';

async installHooks(projectId: string, repoPath: string, config?: HookConfig): Promise<string[]> {
  const installer = new HookInstaller();
  const hooks = config?.hooks || ['post-commit'];
  const installed: string[] = [];

  for (const hookName of hooks) {
    await installer.install(repoPath, hookName, {
      projectId,
      command: `ctx-sys sync --project ${projectId}`
    });
    installed.push(hookName);
  }

  return installed;
}
```

### Step 2: Implement HookInstaller if Missing

If `HookInstaller` doesn't have a working `install()` method, implement it:

```typescript
async install(repoPath: string, hookName: string, options: HookOptions): Promise<void> {
  const hooksDir = path.join(repoPath, '.git', 'hooks');
  const hookPath = path.join(hooksDir, hookName);

  // Check for existing hook
  if (fs.existsSync(hookPath)) {
    // Append to existing hook
    const existing = fs.readFileSync(hookPath, 'utf-8');
    if (existing.includes('ctx-sys')) return; // Already installed
    fs.appendFileSync(hookPath, `\n\n# ctx-sys auto-sync\n${options.command}\n`);
  } else {
    // Create new hook
    const content = `#!/bin/sh\n# ctx-sys auto-sync hook\n${options.command}\n`;
    fs.writeFileSync(hookPath, content, { mode: 0o755 });
  }
}
```

### Step 3: Update MCP Handler

**File**: `src/mcp/tool-registry.ts`

Return the actual list of installed hooks from the service call.

## Testing

```typescript
describe('hooks_install', () => {
  it('should create a post-commit hook file', async () => {
    const result = await mcp.call('hooks_install', {
      repo_path: testRepoPath
    });
    expect(result.success).toBe(true);
    expect(fs.existsSync(path.join(testRepoPath, '.git/hooks/post-commit'))).toBe(true);
  });

  it('should make hook executable', async () => {
    await mcp.call('hooks_install', { repo_path: testRepoPath });
    const stats = fs.statSync(path.join(testRepoPath, '.git/hooks/post-commit'));
    expect(stats.mode & 0o111).toBeTruthy(); // executable
  });

  it('should not duplicate on re-install', async () => {
    await mcp.call('hooks_install', { repo_path: testRepoPath });
    await mcp.call('hooks_install', { repo_path: testRepoPath });
    const content = fs.readFileSync(
      path.join(testRepoPath, '.git/hooks/post-commit'), 'utf-8'
    );
    const matches = content.match(/ctx-sys/g);
    expect(matches?.length).toBe(1);
  });
});
```

## Success Criteria

- Git hook files are actually created on disk
- Hooks are executable (mode 0o755)
- Re-installation is idempotent
- Existing hooks are preserved (appended to, not overwritten)
