# F8.4 Proactive Context

**Phase**: 8 - Agent Patterns
**Priority**: High
**Dependencies**: F6.2 Multi-Strategy Search, F7.3 Watch Mode, F2.5 Git Diff Processing

## Goal

Implement push-based context suggestions that proactively surface relevant information based on current activity, rather than waiting for explicit queries.

## Overview

Current retrieval is reactive â€” the agent must ask for context. Proactive context flips this:

1. **Watch** what the user/agent is working on (files, code, activity)
2. **Detect** when relevant context exists (related decisions, recent changes, docs)
3. **Push** suggestions before they're needed

This is the key differentiator that makes ctx-sys more valuable than a simple RAG system.

## Data Model

```typescript
interface ContextSubscription {
  id: string;
  sessionId: string;
  projectId: string;
  
  // What to watch
  watchPatterns: WatchPattern[];
  
  // How to notify
  callbackType: 'poll' | 'webhook' | 'sse';
  callbackUrl?: string;
  
  // Configuration
  minRelevanceScore: number;
  maxSuggestionsPerTrigger: number;
  cooldownMs: number;           // Avoid spamming
  
  // State
  lastTriggeredAt?: Date;
  enabled: boolean;
}

interface WatchPattern {
  type: 'file' | 'symbol' | 'topic' | 'entity';
  pattern: string;              // Glob, regex, or semantic query
  priority: number;
}

interface ContextSuggestion {
  id: string;
  sessionId: string;
  createdAt: Date;
  
  // Trigger context
  trigger: {
    type: 'file_change' | 'symbol_focus' | 'activity' | 'time';
    source: string;             // What triggered this
  };
  
  // Suggested context
  suggestions: SuggestionItem[];
  
  // Status
  status: 'pending' | 'shown' | 'used' | 'dismissed';
}

interface SuggestionItem {
  type: 'decision' | 'change' | 'doc' | 'related_code' | 'warning';
  title: string;
  summary: string;
  relevanceScore: number;
  entityId?: string;
  actionUrl?: string;
  
  // Why this is suggested
  reason: string;
}

interface ProactiveQuery {
  currentFile?: string;
  cursorPosition?: { line: number; column: number };
  recentFiles?: string[];
  currentSymbol?: string;
  sessionId: string;
  projectId: string;
}
```

## Implementation

### File: `src/agent/proactive.ts`

```typescript
import { Database } from '../db/database';
import { MultiStrategySearch } from '../retrieval/search';
import { EntityStore } from '../entities/store';
import { GitDiffProcessor } from '../git/diff';

export class ProactiveContextProvider {
  private subscriptions: Map<string, ContextSubscription> = new Map();
  private recentSuggestions: Map<string, Date> = new Map();
  
  constructor(
    private db: Database,
    private search: MultiStrategySearch,
    private entityStore: EntityStore,
    private gitProcessor: GitDiffProcessor,
    private config: ProactiveConfig = defaultProactiveConfig
  ) {}

  /**
   * Get proactive suggestions for current context
   */
  async suggest(query: ProactiveQuery): Promise<ContextSuggestion> {
    const suggestions: SuggestionItem[] = [];
    
    // 1. Find related decisions
    if (query.currentFile || query.currentSymbol) {
      const decisions = await this.findRelatedDecisions(query);
      suggestions.push(...decisions);
    }
    
    // 2. Find recent changes that might affect current work
    if (query.currentFile) {
      const changes = await this.findRelevantChanges(query);
      suggestions.push(...changes);
    }
    
    // 3. Find related documentation
    if (query.currentSymbol) {
      const docs = await this.findRelatedDocs(query);
      suggestions.push(...docs);
    }
    
    // 4. Find related code (potential dependencies/impacts)
    if (query.currentFile) {
      const relatedCode = await this.findRelatedCode(query);
      suggestions.push(...relatedCode);
    }
    
    // 5. Check for potential issues/warnings
    const warnings = await this.checkForWarnings(query);
    suggestions.push(...warnings);
    
    // Sort by relevance and dedupe
    const finalSuggestions = this.rankAndDedupe(suggestions);
    
    // Create suggestion record
    const suggestion: ContextSuggestion = {
      id: generateId('sug'),
      sessionId: query.sessionId,
      createdAt: new Date(),
      trigger: {
        type: query.currentFile ? 'file_change' : 'activity',
        source: query.currentFile || query.currentSymbol || 'session'
      },
      suggestions: finalSuggestions.slice(0, this.config.maxSuggestions),
      status: 'pending'
    };
    
    // Store for tracking
    await this.storeSuggestion(suggestion);
    
    return suggestion;
  }

  /**
   * Find decisions related to current context
   */
  private async findRelatedDecisions(query: ProactiveQuery): Promise<SuggestionItem[]> {
    const searchTerms: string[] = [];
    
    if (query.currentFile) {
      // Extract meaningful parts of file path
      const parts = query.currentFile.split('/').filter(p => !['src', 'lib', 'index'].includes(p));
      searchTerms.push(...parts);
    }
    
    if (query.currentSymbol) {
      searchTerms.push(query.currentSymbol);
    }
    
    if (searchTerms.length === 0) return [];
    
    const results = await this.search.search(searchTerms.join(' '), {
      projectId: query.projectId,
      entityTypes: ['decision'],
      limit: 5
    });
    
    return results.results
      .filter(r => r.score > 0.6)
      .map(r => ({
        type: 'decision' as const,
        title: `Decision: ${r.entity.name}`,
        summary: r.entity.summary || r.entity.content.slice(0, 200),
        relevanceScore: r.score,
        entityId: r.entity.id,
        reason: `Related to ${query.currentSymbol || query.currentFile}`
      }));
  }

  /**
   * Find recent changes that might affect current work
   */
  private async findRelevantChanges(query: ProactiveQuery): Promise<SuggestionItem[]> {
    if (!query.currentFile) return [];
    
    // Get entities related to current file
    const fileEntity = await this.entityStore.findByPath(query.currentFile);
    if (!fileEntity) return [];
    
    // Find entities that were recently modified and are related
    const relatedChanges = await this.db.all(`
      SELECT e.*, r.type as relation_type
      FROM entities e
      JOIN relationships r ON (r.source_id = e.id OR r.target_id = e.id)
      WHERE (r.source_id = ? OR r.target_id = ?)
        AND e.updated_at > datetime('now', '-7 days')
        AND e.id != ?
      ORDER BY e.updated_at DESC
      LIMIT 5
    `, [fileEntity.id, fileEntity.id, fileEntity.id]);
    
    return relatedChanges.map(change => ({
      type: 'change' as const,
      title: `Recent change: ${change.name}`,
      summary: `Modified ${this.formatTimeSince(new Date(change.updated_at))}`,
      relevanceScore: 0.7,
      entityId: change.id,
      reason: `${change.relation_type} relationship with current file`
    }));
  }

  /**
   * Find documentation related to current symbol
   */
  private async findRelatedDocs(query: ProactiveQuery): Promise<SuggestionItem[]> {
    if (!query.currentSymbol) return [];
    
    const results = await this.search.search(query.currentSymbol, {
      projectId: query.projectId,
      entityTypes: ['document', 'section'],
      limit: 3
    });
    
    return results.results
      .filter(r => r.score > 0.65)
      .map(r => ({
        type: 'doc' as const,
        title: `Doc: ${r.entity.name}`,
        summary: r.entity.summary || r.entity.content.slice(0, 150),
        relevanceScore: r.score,
        entityId: r.entity.id,
        reason: `Documentation mentions ${query.currentSymbol}`
      }));
  }

  /**
   * Find related code (callers, callees, similar functions)
   */
  private async findRelatedCode(query: ProactiveQuery): Promise<SuggestionItem[]> {
    if (!query.currentFile) return [];
    
    const fileEntity = await this.entityStore.findByPath(query.currentFile);
    if (!fileEntity) return [];
    
    // Get symbols in current file
    const symbols = await this.db.all(`
      SELECT e.* FROM entities e
      WHERE e.metadata_json LIKE '%"filePath":"${query.currentFile}"%'
        AND e.type IN ('function', 'class', 'method')
      LIMIT 5
    `);
    
    const relatedCode: SuggestionItem[] = [];
    
    for (const symbol of symbols) {
      // Find callers
      const callers = await this.db.all(`
        SELECT e.* FROM entities e
        JOIN relationships r ON r.source_id = e.id
        WHERE r.target_id = ? AND r.type = 'CALLS'
        LIMIT 2
      `, [symbol.id]);
      
      for (const caller of callers) {
        relatedCode.push({
          type: 'related_code',
          title: `Caller: ${caller.name}`,
          summary: `Calls ${symbol.name}`,
          relevanceScore: 0.6,
          entityId: caller.id,
          reason: 'Changes here may affect this caller'
        });
      }
    }
    
    return relatedCode.slice(0, 3);
  }

  /**
   * Check for potential issues/warnings
   */
  private async checkForWarnings(query: ProactiveQuery): Promise<SuggestionItem[]> {
    const warnings: SuggestionItem[] = [];
    
    if (query.currentFile) {
      // Check if file has associated failing tests
      const testIssues = await this.db.all(`
        SELECT e.* FROM entities e
        WHERE e.type = 'test'
          AND e.metadata_json LIKE '%"status":"failing"%'
          AND e.metadata_json LIKE '%${query.currentFile}%'
      `);
      
      if (testIssues.length > 0) {
        warnings.push({
          type: 'warning',
          title: 'Failing tests',
          summary: `${testIssues.length} test(s) related to this file are failing`,
          relevanceScore: 0.9,
          reason: 'Tests need attention'
        });
      }
      
      // Check for deprecated APIs in current file
      const deprecated = await this.db.all(`
        SELECT e.* FROM entities e
        JOIN relationships r ON r.target_id = e.id
        WHERE r.source_id IN (
          SELECT id FROM entities WHERE metadata_json LIKE '%"filePath":"${query.currentFile}"%'
        )
        AND e.metadata_json LIKE '%"deprecated":true%'
      `);
      
      if (deprecated.length > 0) {
        warnings.push({
          type: 'warning',
          title: 'Deprecated dependencies',
          summary: `Uses ${deprecated.length} deprecated API(s)`,
          relevanceScore: 0.8,
          entityId: deprecated[0].id,
          reason: 'Consider updating to newer APIs'
        });
      }
    }
    
    return warnings;
  }

  /**
   * Subscribe to proactive suggestions
   */
  async subscribe(subscription: Omit<ContextSubscription, 'id'>): Promise<ContextSubscription> {
    const full: ContextSubscription = {
      ...subscription,
      id: generateId('sub'),
      enabled: true
    };
    
    this.subscriptions.set(full.id, full);
    
    await this.db.run(`
      INSERT INTO context_subscriptions (
        id, session_id, project_id, watch_patterns_json,
        callback_type, callback_url, min_relevance_score,
        max_suggestions, cooldown_ms, enabled
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `, [
      full.id, full.sessionId, full.projectId,
      JSON.stringify(full.watchPatterns),
      full.callbackType, full.callbackUrl,
      full.minRelevanceScore, full.maxSuggestionsPerTrigger,
      full.cooldownMs, full.enabled
    ]);
    
    return full;
  }

  /**
   * Unsubscribe from proactive suggestions
   */
  async unsubscribe(subscriptionId: string): Promise<void> {
    this.subscriptions.delete(subscriptionId);
    await this.db.run(`DELETE FROM context_subscriptions WHERE id = ?`, [subscriptionId]);
  }

  /**
   * Mark suggestion as used (for feedback)
   */
  async markUsed(suggestionId: string, itemIndex: number): Promise<void> {
    await this.db.run(`
      UPDATE context_suggestions 
      SET status = 'used', used_item_index = ?
      WHERE id = ?
    `, [itemIndex, suggestionId]);
  }

  /**
   * Mark suggestion as dismissed
   */
  async dismiss(suggestionId: string): Promise<void> {
    await this.db.run(`
      UPDATE context_suggestions SET status = 'dismissed' WHERE id = ?
    `, [suggestionId]);
  }

  private rankAndDedupe(suggestions: SuggestionItem[]): SuggestionItem[] {
    // Remove duplicates by entityId
    const seen = new Set<string>();
    const unique = suggestions.filter(s => {
      if (s.entityId && seen.has(s.entityId)) return false;
      if (s.entityId) seen.add(s.entityId);
      return true;
    });
    
    // Sort by relevance
    return unique.sort((a, b) => b.relevanceScore - a.relevanceScore);
  }

  private formatTimeSince(date: Date): string {
    const seconds = Math.floor((Date.now() - date.getTime()) / 1000);
    if (seconds < 60) return 'just now';
    if (seconds < 3600) return `${Math.floor(seconds / 60)} minutes ago`;
    if (seconds < 86400) return `${Math.floor(seconds / 3600)} hours ago`;
    return `${Math.floor(seconds / 86400)} days ago`;
  }

  private async storeSuggestion(suggestion: ContextSuggestion): Promise<void> {
    await this.db.run(`
      INSERT INTO context_suggestions (
        id, session_id, created_at, trigger_json, suggestions_json, status
      ) VALUES (?, ?, ?, ?, ?, ?)
    `, [
      suggestion.id, suggestion.sessionId, suggestion.createdAt.toISOString(),
      JSON.stringify(suggestion.trigger), JSON.stringify(suggestion.suggestions),
      suggestion.status
    ]);
  }
}

interface ProactiveConfig {
  maxSuggestions: number;
  minRelevanceScore: number;
  recentChangeDays: number;
}

const defaultProactiveConfig: ProactiveConfig = {
  maxSuggestions: 5,
  minRelevanceScore: 0.5,
  recentChangeDays: 7
};
```

## Database Schema

```sql
-- Subscription storage
CREATE TABLE context_subscriptions (
  id TEXT PRIMARY KEY,
  session_id TEXT NOT NULL,
  project_id TEXT NOT NULL,
  watch_patterns_json TEXT,
  callback_type TEXT NOT NULL,
  callback_url TEXT,
  min_relevance_score REAL DEFAULT 0.5,
  max_suggestions INTEGER DEFAULT 5,
  cooldown_ms INTEGER DEFAULT 5000,
  enabled INTEGER DEFAULT 1,
  last_triggered_at TEXT,
  
  FOREIGN KEY (session_id) REFERENCES sessions(id),
  FOREIGN KEY (project_id) REFERENCES projects(id)
);

-- Suggestion storage (for tracking/feedback)
CREATE TABLE context_suggestions (
  id TEXT PRIMARY KEY,
  session_id TEXT NOT NULL,
  created_at TEXT NOT NULL,
  trigger_json TEXT,
  suggestions_json TEXT,
  status TEXT DEFAULT 'pending',
  used_item_index INTEGER,
  
  FOREIGN KEY (session_id) REFERENCES sessions(id)
);

CREATE INDEX idx_suggestions_session ON context_suggestions(session_id, created_at DESC);
CREATE INDEX idx_suggestions_status ON context_suggestions(status);
```

## MCP Tools

```typescript
{
  name: 'context_suggest',
  description: 'Get proactive context suggestions for current activity',
  inputSchema: {
    type: 'object',
    properties: {
      sessionId: { type: 'string' },
      projectId: { type: 'string' },
      currentFile: { type: 'string', description: 'Currently open file path' },
      currentSymbol: { type: 'string', description: 'Symbol at cursor' },
      cursorPosition: {
        type: 'object',
        properties: {
          line: { type: 'number' },
          column: { type: 'number' }
        }
      }
    },
    required: ['sessionId', 'projectId']
  }
},
{
  name: 'context_subscribe',
  description: 'Subscribe to proactive context notifications',
  inputSchema: {
    type: 'object',
    properties: {
      sessionId: { type: 'string' },
      projectId: { type: 'string' },
      watchPatterns: {
        type: 'array',
        items: {
          type: 'object',
          properties: {
            type: { type: 'string', enum: ['file', 'symbol', 'topic'] },
            pattern: { type: 'string' }
          }
        }
      },
      callbackUrl: { type: 'string', description: 'Webhook URL for notifications' }
    },
    required: ['sessionId', 'projectId', 'watchPatterns']
  }
},
{
  name: 'suggestion_feedback',
  description: 'Provide feedback on a suggestion',
  inputSchema: {
    type: 'object',
    properties: {
      suggestionId: { type: 'string' },
      action: { type: 'string', enum: ['used', 'dismissed'] },
      itemIndex: { type: 'number', description: 'Which suggestion item was used' }
    },
    required: ['suggestionId', 'action']
  }
}
```

## Examples

### Example 1: Opening a File

```typescript
// User opens src/auth/AuthService.ts

const suggestion = await proactive.suggest({
  sessionId: 'session-1',
  projectId: 'project-1',
  currentFile: 'src/auth/AuthService.ts'
});

// Returns:
{
  suggestions: [
    {
      type: 'decision',
      title: 'Decision: JWT token strategy',
      summary: 'We decided to use short-lived access tokens with refresh...',
      reason: 'Related to AuthService'
    },
    {
      type: 'change',
      title: 'Recent change: TokenRefresher.ts',
      summary: 'Modified 2 days ago',
      reason: 'CALLS relationship with AuthService'
    },
    {
      type: 'doc',
      title: 'Doc: Authentication Flow',
      summary: 'Documents the authentication flow including token refresh...',
      reason: 'Documentation mentions AuthService'
    }
  ]
}
```

### Example 2: Hovering on a Symbol

```typescript
// User hovers on `validateToken` function

const suggestion = await proactive.suggest({
  sessionId: 'session-1',
  projectId: 'project-1',
  currentSymbol: 'validateToken'
});

// Returns:
{
  suggestions: [
    {
      type: 'related_code',
      title: 'Caller: AuthMiddleware.handle',
      summary: 'Calls validateToken',
      reason: 'Changes here may affect this caller'
    },
    {
      type: 'warning',
      title: 'Deprecated dependency',
      summary: 'Uses deprecated jwt.verify() API',
      reason: 'Consider updating to newer API'
    }
  ]
}
```

### Example 3: Subscription for Continuous Suggestions

```typescript
await proactive.subscribe({
  sessionId: 'session-1',
  projectId: 'project-1',
  watchPatterns: [
    { type: 'file', pattern: 'src/auth/**', priority: 1 },
    { type: 'topic', pattern: 'authentication', priority: 2 }
  ],
  callbackType: 'webhook',
  callbackUrl: 'http://localhost:3000/suggestions',
  minRelevanceScore: 0.7,
  maxSuggestionsPerTrigger: 3,
  cooldownMs: 10000
});
```

## Configuration

```yaml
# ctx-sys.yaml
agent:
  proactive:
    enabled: true
    maxSuggestions: 5
    minRelevanceScore: 0.5
    recentChangeDays: 7
    # Suggestion types to enable
    enableDecisions: true
    enableRecentChanges: true
    enableDocs: true
    enableRelatedCode: true
    enableWarnings: true
```

## Testing

```typescript
describe('ProactiveContextProvider', () => {
  it('should suggest related decisions', async () => {
    // Setup: Store a decision about auth
    await entityStore.create({
      type: 'decision',
      name: 'JWT strategy',
      content: 'Use short-lived tokens with AuthService',
      projectId: 'project-1'
    });
    
    const suggestion = await proactive.suggest({
      sessionId: 'session-1',
      projectId: 'project-1',
      currentFile: 'src/auth/AuthService.ts'
    });
    
    expect(suggestion.suggestions.some(s => s.type === 'decision')).toBe(true);
  });

  it('should detect recent changes to related files', async () => {
    // Setup: Create relationship and update related file
    await createRelationship('file-a', 'file-b', 'IMPORTS');
    await entityStore.update('file-b', { updatedAt: new Date() });
    
    const suggestion = await proactive.suggest({
      sessionId: 'session-1',
      projectId: 'project-1',
      currentFile: 'src/file-a.ts'
    });
    
    expect(suggestion.suggestions.some(s => s.type === 'change')).toBe(true);
  });

  it('should track suggestion usage', async () => {
    const suggestion = await proactive.suggest({
      sessionId: 'session-1',
      projectId: 'project-1',
      currentFile: 'src/test.ts'
    });
    
    await proactive.markUsed(suggestion.id, 0);
    
    const stored = await db.get('SELECT * FROM context_suggestions WHERE id = ?', [suggestion.id]);
    expect(stored.status).toBe('used');
    expect(stored.used_item_index).toBe(0);
  });
});
```

## Metrics to Track

| Metric | Description |
|--------|-------------|
| `proactive_suggestion_count` | Total suggestions generated |
| `proactive_used_rate` | % of suggestions marked as used |
| `proactive_dismissed_rate` | % of suggestions dismissed |
| `proactive_latency_ms` | Time to generate suggestions |
| `suggestion_type_distribution` | Which types are most useful |
| `relevance_score_vs_usage` | Correlation between score and actual use |
