# F8.3 Reflection Storage

**Phase**: 8 - Agent Patterns
**Priority**: Medium
**Dependencies**: F3.2 Session Management, F1.3 Entity Storage

## Goal

Implement lesson storage and retrieval for agent self-improvement, enabling learning from past attempts within and across sessions.

## Overview

AI agents often make the same mistakes repeatedly because they lack memory of what worked and what didn't. Reflection storage enables:

1. Storing "lessons learned" after each attempt
2. Retrieving relevant lessons before new attempts
3. Cross-session learning (what worked in similar situations)
4. Explicit reasoning about past failures

This implements the "Reflection and Self-Improvement" pattern from the article.

## Data Model

```typescript
interface Reflection {
  id: string;
  sessionId: string;
  projectId: string;
  createdAt: Date;
  
  // Context
  taskDescription: string;
  attemptNumber: number;
  
  // What happened
  outcome: 'success' | 'partial' | 'failure';
  
  // Lessons
  whatWorked: string[];
  whatDidNotWork: string[];
  nextStrategy: string;
  
  // For retrieval
  tags: string[];
  embedding?: number[];
  
  // Link to related entities
  relatedEntityIds?: string[];
}

interface ReflectionQuery {
  sessionId?: string;           // Search within session
  projectId?: string;           // Search within project
  taskDescription?: string;     // Semantic search
  tags?: string[];              // Filter by tags
  outcomeFilter?: Reflection['outcome'][];
  limit?: number;
}

interface ReflectionSummary {
  totalReflections: number;
  successRate: number;
  commonFailures: string[];
  effectiveStrategies: string[];
  recentLessons: Reflection[];
}
```

## Database Schema

```sql
-- Reflection storage
CREATE TABLE reflections (
  id TEXT PRIMARY KEY,
  session_id TEXT NOT NULL,
  project_id TEXT NOT NULL,
  created_at TEXT NOT NULL,
  
  -- Context
  task_description TEXT NOT NULL,
  attempt_number INTEGER DEFAULT 1,
  
  -- Outcome
  outcome TEXT NOT NULL,  -- 'success', 'partial', 'failure'
  
  -- Lessons (JSON arrays)
  what_worked_json TEXT,
  what_did_not_work_json TEXT,
  next_strategy TEXT,
  
  -- Retrieval
  tags_json TEXT,
  embedding BLOB,
  
  -- Links
  related_entity_ids_json TEXT,
  
  FOREIGN KEY (session_id) REFERENCES sessions(id),
  FOREIGN KEY (project_id) REFERENCES projects(id)
);

CREATE INDEX idx_reflections_session ON reflections(session_id, created_at DESC);
CREATE INDEX idx_reflections_project ON reflections(project_id, outcome);
CREATE INDEX idx_reflections_outcome ON reflections(outcome, created_at DESC);

-- FTS for text search
CREATE VIRTUAL TABLE reflections_fts USING fts5(
  task_description,
  what_worked_json,
  what_did_not_work_json,
  next_strategy,
  content='reflections',
  content_rowid='rowid'
);
```

## Implementation

### File: `src/agent/reflection.ts`

```typescript
import { Database } from '../db/database';
import { EmbeddingManager } from '../embeddings/manager';
import { generateId } from '../utils/id';

export class ReflectionStore {
  constructor(
    private db: Database,
    private embeddingManager: EmbeddingManager,
    private config: ReflectionConfig = defaultReflectionConfig
  ) {}

  /**
   * Store a reflection after an attempt
   */
  async store(reflection: Omit<Reflection, 'id' | 'createdAt'>): Promise<Reflection> {
    const id = generateId('refl');
    const createdAt = new Date();
    
    // Generate embedding for semantic search
    const embeddingText = [
      reflection.taskDescription,
      ...reflection.whatWorked,
      ...reflection.whatDidNotWork,
      reflection.nextStrategy
    ].join(' ');
    
    const embedding = await this.embeddingManager.embed(embeddingText);

    const full: Reflection = {
      ...reflection,
      id,
      createdAt,
      embedding
    };

    await this.db.run(`
      INSERT INTO reflections (
        id, session_id, project_id, created_at,
        task_description, attempt_number, outcome,
        what_worked_json, what_did_not_work_json, next_strategy,
        tags_json, embedding, related_entity_ids_json
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `, [
      full.id,
      full.sessionId,
      full.projectId,
      full.createdAt.toISOString(),
      full.taskDescription,
      full.attemptNumber,
      full.outcome,
      JSON.stringify(full.whatWorked),
      JSON.stringify(full.whatDidNotWork),
      full.nextStrategy,
      JSON.stringify(full.tags),
      Buffer.from(new Float32Array(embedding).buffer),
      JSON.stringify(full.relatedEntityIds || [])
    ]);

    // Update FTS index
    await this.db.run(`
      INSERT INTO reflections_fts (rowid, task_description, what_worked_json, what_did_not_work_json, next_strategy)
      SELECT rowid, task_description, what_worked_json, what_did_not_work_json, next_strategy
      FROM reflections WHERE id = ?
    `, [full.id]);

    // Prune old reflections if needed
    await this.pruneOldReflections(full.sessionId);

    return full;
  }

  /**
   * Get recent reflections for a session
   */
  async getRecent(sessionId: string, limit: number = 5): Promise<Reflection[]> {
    const rows = await this.db.all(`
      SELECT * FROM reflections
      WHERE session_id = ?
      ORDER BY created_at DESC
      LIMIT ?
    `, [sessionId, limit]);

    return rows.map(this.rowToReflection);
  }

  /**
   * Search for relevant reflections
   */
  async search(query: ReflectionQuery): Promise<Reflection[]> {
    const conditions: string[] = [];
    const params: unknown[] = [];

    if (query.sessionId) {
      conditions.push('session_id = ?');
      params.push(query.sessionId);
    }

    if (query.projectId) {
      conditions.push('project_id = ?');
      params.push(query.projectId);
    }

    if (query.outcomeFilter?.length) {
      const placeholders = query.outcomeFilter.map(() => '?').join(',');
      conditions.push(`outcome IN (${placeholders})`);
      params.push(...query.outcomeFilter);
    }

    // Semantic search if task description provided
    if (query.taskDescription) {
      const embedding = await this.embeddingManager.embed(query.taskDescription);
      
      const whereClause = conditions.length ? `WHERE ${conditions.join(' AND ')}` : '';
      
      const rows = await this.db.all(`
        SELECT *, vec_distance_cosine(embedding, ?) as distance
        FROM reflections
        ${whereClause}
        ORDER BY distance ASC
        LIMIT ?
      `, [
        Buffer.from(new Float32Array(embedding).buffer),
        ...params,
        query.limit || 5
      ]);

      return rows.map(this.rowToReflection);
    }

    // Non-semantic search
    const whereClause = conditions.length ? `WHERE ${conditions.join(' AND ')}` : '';
    const rows = await this.db.all(`
      SELECT * FROM reflections
      ${whereClause}
      ORDER BY created_at DESC
      LIMIT ?
    `, [...params, query.limit || 5]);

    return rows.map(this.rowToReflection);
  }

  /**
   * Get summary of reflections for a project/session
   */
  async getSummary(projectId: string, sessionId?: string): Promise<ReflectionSummary> {
    const whereClause = sessionId
      ? 'WHERE project_id = ? AND session_id = ?'
      : 'WHERE project_id = ?';
    const params = sessionId ? [projectId, sessionId] : [projectId];

    // Count by outcome
    const outcomes = await this.db.all(`
      SELECT outcome, COUNT(*) as count
      FROM reflections
      ${whereClause}
      GROUP BY outcome
    `, params);

    const total = outcomes.reduce((sum, o) => sum + o.count, 0);
    const successes = outcomes.find(o => o.outcome === 'success')?.count || 0;

    // Get common failure patterns
    const failures = await this.db.all(`
      SELECT what_did_not_work_json
      FROM reflections
      ${whereClause} AND outcome = 'failure'
      ORDER BY created_at DESC
      LIMIT 20
    `, params);

    const failurePatterns = this.extractCommonPatterns(
      failures.flatMap(f => JSON.parse(f.what_did_not_work_json || '[]'))
    );

    // Get effective strategies
    const successes_data = await this.db.all(`
      SELECT what_worked_json
      FROM reflections
      ${whereClause} AND outcome = 'success'
      ORDER BY created_at DESC
      LIMIT 20
    `, params);

    const effectiveStrategies = this.extractCommonPatterns(
      successes_data.flatMap(s => JSON.parse(s.what_worked_json || '[]'))
    );

    // Recent lessons
    const recent = await this.db.all(`
      SELECT * FROM reflections
      ${whereClause}
      ORDER BY created_at DESC
      LIMIT 5
    `, params);

    return {
      totalReflections: total,
      successRate: total > 0 ? successes / total : 0,
      commonFailures: failurePatterns,
      effectiveStrategies,
      recentLessons: recent.map(this.rowToReflection)
    };
  }

  /**
   * Format reflections for inclusion in prompt
   */
  formatForPrompt(reflections: Reflection[]): string {
    if (reflections.length === 0) return '';

    const lines = ['## Previous Lessons Learned\n'];
    
    for (const r of reflections) {
      lines.push(`### Attempt ${r.attemptNumber} (${r.outcome})`);
      lines.push(`Task: ${r.taskDescription}`);
      
      if (r.whatWorked.length > 0) {
        lines.push('What worked:');
        r.whatWorked.forEach(w => lines.push(`  - ${w}`));
      }
      
      if (r.whatDidNotWork.length > 0) {
        lines.push('What did not work:');
        r.whatDidNotWork.forEach(w => lines.push(`  - ${w}`));
      }
      
      lines.push(`Next strategy: ${r.nextStrategy}`);
      lines.push('');
    }

    return lines.join('\n');
  }

  /**
   * Extract common patterns from a list of strings
   */
  private extractCommonPatterns(items: string[]): string[] {
    const counts = new Map<string, number>();
    
    for (const item of items) {
      const normalized = item.toLowerCase().trim();
      counts.set(normalized, (counts.get(normalized) || 0) + 1);
    }

    return Array.from(counts.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, 5)
      .map(([pattern]) => pattern);
  }

  /**
   * Prune old reflections to stay under limit
   */
  private async pruneOldReflections(sessionId: string): Promise<void> {
    await this.db.run(`
      DELETE FROM reflections
      WHERE session_id = ? AND id NOT IN (
        SELECT id FROM reflections
        WHERE session_id = ?
        ORDER BY created_at DESC
        LIMIT ?
      )
    `, [sessionId, sessionId, this.config.maxReflectionsPerSession]);
  }

  private rowToReflection(row: any): Reflection {
    return {
      id: row.id,
      sessionId: row.session_id,
      projectId: row.project_id,
      createdAt: new Date(row.created_at),
      taskDescription: row.task_description,
      attemptNumber: row.attempt_number,
      outcome: row.outcome,
      whatWorked: JSON.parse(row.what_worked_json || '[]'),
      whatDidNotWork: JSON.parse(row.what_did_not_work_json || '[]'),
      nextStrategy: row.next_strategy,
      tags: JSON.parse(row.tags_json || '[]'),
      relatedEntityIds: JSON.parse(row.related_entity_ids_json || '[]')
    };
  }
}

interface ReflectionConfig {
  maxReflectionsPerSession: number;
  maxReflectionsPerProject: number;
}

const defaultReflectionConfig: ReflectionConfig = {
  maxReflectionsPerSession: 20,
  maxReflectionsPerProject: 100
};
```

### Integration with Agent Execution

```typescript
// src/agent/reflective-executor.ts

export class ReflectiveExecutor {
  private reflectionStore: ReflectionStore;
  
  async executeWithReflection(
    sessionId: string,
    projectId: string,
    task: string,
    execute: () => Promise<ExecutionResult>
  ): Promise<ExecutionResult> {
    // Get relevant past lessons
    const pastLessons = await this.reflectionStore.search({
      projectId,
      taskDescription: task,
      limit: 3
    });

    // Include lessons in execution context
    const lessonsPrompt = this.reflectionStore.formatForPrompt(pastLessons);
    
    // Track attempt
    const attemptNumber = await this.getAttemptNumber(sessionId, task);
    
    try {
      const result = await execute();
      
      // Store reflection on success
      await this.reflectionStore.store({
        sessionId,
        projectId,
        taskDescription: task,
        attemptNumber,
        outcome: 'success',
        whatWorked: result.strategies || [],
        whatDidNotWork: [],
        nextStrategy: 'Continue with this approach',
        tags: this.extractTags(task)
      });
      
      return result;
      
    } catch (error) {
      // Store reflection on failure
      await this.reflectionStore.store({
        sessionId,
        projectId,
        taskDescription: task,
        attemptNumber,
        outcome: 'failure',
        whatWorked: [],
        whatDidNotWork: [(error as Error).message],
        nextStrategy: this.suggestNextStrategy(error as Error, pastLessons),
        tags: this.extractTags(task)
      });
      
      throw error;
    }
  }

  private suggestNextStrategy(error: Error, pastLessons: Reflection[]): string {
    // Use past lessons to suggest what to try next
    const successfulStrategies = pastLessons
      .filter(l => l.outcome === 'success')
      .flatMap(l => l.whatWorked);
    
    if (successfulStrategies.length > 0) {
      return `Try: ${successfulStrategies[0]}`;
    }
    
    return 'Try a different approach';
  }

  private extractTags(task: string): string[] {
    // Simple tag extraction from task description
    const tags: string[] = [];
    
    if (task.includes('auth')) tags.push('authentication');
    if (task.includes('test')) tags.push('testing');
    if (task.includes('error') || task.includes('fix')) tags.push('debugging');
    if (task.includes('refactor')) tags.push('refactoring');
    
    return tags;
  }
}
```

## MCP Tools

```typescript
{
  name: 'reflection_store',
  description: 'Store a lesson learned from an attempt',
  inputSchema: {
    type: 'object',
    properties: {
      sessionId: { type: 'string' },
      taskDescription: { type: 'string' },
      attemptNumber: { type: 'number' },
      outcome: { type: 'string', enum: ['success', 'partial', 'failure'] },
      whatWorked: { type: 'array', items: { type: 'string' } },
      whatDidNotWork: { type: 'array', items: { type: 'string' } },
      nextStrategy: { type: 'string' }
    },
    required: ['sessionId', 'taskDescription', 'outcome', 'nextStrategy']
  }
},
{
  name: 'reflection_get',
  description: 'Get recent lessons for a session',
  inputSchema: {
    type: 'object',
    properties: {
      sessionId: { type: 'string' },
      limit: { type: 'number', default: 5 }
    },
    required: ['sessionId']
  }
},
{
  name: 'reflection_search',
  description: 'Search for relevant lessons across sessions',
  inputSchema: {
    type: 'object',
    properties: {
      projectId: { type: 'string' },
      taskDescription: { type: 'string', description: 'Semantic search for similar tasks' },
      outcomeFilter: { type: 'array', items: { type: 'string' } }
    },
    required: ['projectId']
  }
},
{
  name: 'reflection_summary',
  description: 'Get summary of lessons learned for a project',
  inputSchema: {
    type: 'object',
    properties: {
      projectId: { type: 'string' },
      sessionId: { type: 'string', description: 'Optional: limit to session' }
    },
    required: ['projectId']
  }
}
```

## Examples

### Example 1: Learning from Failed Code Generation

```
Attempt 1: "Generate a function to parse CSV files"
Outcome: failure
What didn't work: 
  - Forgot to handle quoted fields
  - Didn't consider line breaks in values
Next strategy: Use a proper CSV parsing library instead of regex

Attempt 2: (with reflection)
Previous lessons loaded:
  - "Forgot to handle quoted fields"
  - "Use a proper CSV parsing library"
  
Result: Uses csv-parse library, handles edge cases
Outcome: success
What worked:
  - Used established csv-parse library
  - Handled edge cases from library docs
```

### Example 2: Cross-Session Learning

```
Session A: "Fix authentication timeout issue"
Outcome: success
What worked: "Increased token refresh buffer from 5s to 30s"

[Later, different session]

Session B: "Debug auth errors in production"
→ Search: "authentication" + "error"
→ Found: Lesson from Session A about token refresh
→ Agent checks token refresh timing first
```

### Example 3: Reflection Summary

```json
{
  "totalReflections": 45,
  "successRate": 0.73,
  "commonFailures": [
    "forgot to handle edge cases",
    "didn't check for null values",
    "timeout on external api calls"
  ],
  "effectiveStrategies": [
    "use established libraries",
    "add input validation first",
    "check error handling before logic"
  ]
}
```

## Configuration

```yaml
# ctx-sys.yaml
agent:
  reflection:
    enabled: true
    maxReflectionsPerSession: 20
    maxReflectionsPerProject: 100
    autoReflect: true           # Auto-store after each task
    includePastLessons: 3       # Lessons to include in prompts
```

## Testing

```typescript
describe('ReflectionStore', () => {
  it('should store and retrieve reflections', async () => {
    await store.store({
      sessionId: 'session-1',
      projectId: 'project-1',
      taskDescription: 'Parse CSV file',
      attemptNumber: 1,
      outcome: 'failure',
      whatWorked: [],
      whatDidNotWork: ['Regex failed on quoted fields'],
      nextStrategy: 'Use csv-parse library',
      tags: ['parsing']
    });
    
    const recent = await store.getRecent('session-1');
    expect(recent[0].whatDidNotWork).toContain('Regex failed on quoted fields');
  });

  it('should search semantically across sessions', async () => {
    // Store reflection about auth
    await store.store({
      sessionId: 'session-1',
      projectId: 'project-1',
      taskDescription: 'Fix authentication token expiry',
      outcome: 'success',
      whatWorked: ['Increased refresh buffer'],
      whatDidNotWork: [],
      nextStrategy: 'Monitor token timing',
      tags: ['auth']
    });
    
    // Search from different session
    const results = await store.search({
      projectId: 'project-1',
      taskDescription: 'Debug login timeout issues'
    });
    
    expect(results.length).toBeGreaterThan(0);
    expect(results[0].tags).toContain('auth');
  });

  it('should prune old reflections', async () => {
    for (let i = 0; i < 25; i++) {
      await store.store({
        sessionId: 'session-1',
        projectId: 'project-1',
        taskDescription: `Task ${i}`,
        outcome: 'success',
        whatWorked: [],
        whatDidNotWork: [],
        nextStrategy: 'Continue',
        tags: []
      });
    }
    
    const all = await store.getRecent('session-1', 100);
    expect(all.length).toBeLessThanOrEqual(20);
  });
});
```

## Metrics to Track

| Metric | Description |
|--------|-------------|
| `reflection_store_count` | Number of reflections stored |
| `reflection_search_count` | Number of reflection searches |
| `reflection_hit_rate` | % of searches finding relevant lessons |
| `outcome_improvement_rate` | Success rate after applying lessons |
| `cross_session_reuse` | Lessons used across different sessions |
