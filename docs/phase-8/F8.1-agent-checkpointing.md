# F8.1 Agent Checkpointing

**Phase**: 8 - Agent Patterns
**Priority**: High
**Dependencies**: F3.2 Session Management, F1.1 Database Schema

## Goal

Implement checkpoint save/restore for agent execution state, enabling resumable long-running tasks and failure recovery.

## Overview

Modern AI agents execute multi-step workflows that can be expensive and time-consuming. Without checkpointing:
- Failures mid-execution waste all previous progress
- Users can't interrupt and resume later
- Debugging requires replaying entire workflows
- State is lost on session restart

Checkpointing solves this by persisting agent state after each step, allowing resume from the last successful checkpoint.

## Data Model

```typescript
interface Checkpoint {
  id: string;                    // Unique checkpoint ID
  sessionId: string;             // Associated session
  projectId: string;
  stepNumber: number;            // Position in execution
  createdAt: Date;
  
  // Execution state
  state: AgentState;
  
  // Metadata
  metadata: {
    description?: string;        // Human-readable checkpoint name
    triggerType: 'auto' | 'manual' | 'error';
    durationMs: number;          // Time to reach this checkpoint
    tokenUsage?: number;
  };
}

interface AgentState {
  // The original request
  query: string;
  
  // High-level plan
  plan: PlanStep[];
  currentStepIndex: number;
  
  // Accumulated results from completed steps
  results: StepResult[];
  
  // Working memory
  context: Record<string, unknown>;
  
  // Error recovery
  lastError?: {
    stepIndex: number;
    message: string;
    timestamp: Date;
  };
}

interface PlanStep {
  id: string;
  description: string;
  action: string;               // Tool/action to execute
  parameters: Record<string, unknown>;
  status: 'pending' | 'running' | 'completed' | 'failed' | 'skipped';
  dependencies?: string[];      // Step IDs this depends on
}

interface StepResult {
  stepId: string;
  output: unknown;
  completedAt: Date;
  durationMs: number;
  tokenUsage?: number;
}
```

## Database Schema

```sql
-- Checkpoint storage
CREATE TABLE checkpoints (
  id TEXT PRIMARY KEY,
  session_id TEXT NOT NULL,
  project_id TEXT NOT NULL,
  step_number INTEGER NOT NULL,
  created_at TEXT NOT NULL,
  
  -- Serialized state
  state_json TEXT NOT NULL,
  
  -- Metadata
  description TEXT,
  trigger_type TEXT NOT NULL,
  duration_ms INTEGER,
  token_usage INTEGER,
  
  FOREIGN KEY (session_id) REFERENCES sessions(id),
  FOREIGN KEY (project_id) REFERENCES projects(id)
);

CREATE INDEX idx_checkpoints_session ON checkpoints(session_id, step_number DESC);
CREATE INDEX idx_checkpoints_project ON checkpoints(project_id, created_at DESC);
```

## Implementation

### File: `src/agent/checkpoints.ts`

```typescript
import { Database } from '../db/database';
import { generateId } from '../utils/id';

export class CheckpointManager {
  constructor(private db: Database) {}

  /**
   * Save a checkpoint of the current agent state
   */
  async save(
    sessionId: string,
    projectId: string,
    state: AgentState,
    options: SaveOptions = {}
  ): Promise<Checkpoint> {
    const checkpoint: Checkpoint = {
      id: generateId('ckpt'),
      sessionId,
      projectId,
      stepNumber: state.currentStepIndex,
      createdAt: new Date(),
      state,
      metadata: {
        description: options.description,
        triggerType: options.triggerType || 'auto',
        durationMs: options.durationMs || 0,
        tokenUsage: options.tokenUsage
      }
    };

    await this.db.run(`
      INSERT INTO checkpoints (
        id, session_id, project_id, step_number, created_at,
        state_json, description, trigger_type, duration_ms, token_usage
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `, [
      checkpoint.id,
      checkpoint.sessionId,
      checkpoint.projectId,
      checkpoint.stepNumber,
      checkpoint.createdAt.toISOString(),
      JSON.stringify(checkpoint.state),
      checkpoint.metadata.description,
      checkpoint.metadata.triggerType,
      checkpoint.metadata.durationMs,
      checkpoint.metadata.tokenUsage
    ]);

    // Prune old checkpoints if exceeding limit
    await this.pruneOldCheckpoints(sessionId);

    return checkpoint;
  }

  /**
   * Load the latest checkpoint for a session
   */
  async loadLatest(sessionId: string): Promise<Checkpoint | null> {
    const row = await this.db.get(`
      SELECT * FROM checkpoints
      WHERE session_id = ?
      ORDER BY step_number DESC, created_at DESC
      LIMIT 1
    `, [sessionId]);

    return row ? this.rowToCheckpoint(row) : null;
  }

  /**
   * Load a specific checkpoint by ID
   */
  async load(checkpointId: string): Promise<Checkpoint | null> {
    const row = await this.db.get(`
      SELECT * FROM checkpoints WHERE id = ?
    `, [checkpointId]);

    return row ? this.rowToCheckpoint(row) : null;
  }

  /**
   * List all checkpoints for a session
   */
  async list(sessionId: string): Promise<CheckpointSummary[]> {
    const rows = await this.db.all(`
      SELECT id, step_number, created_at, description, trigger_type, duration_ms
      FROM checkpoints
      WHERE session_id = ?
      ORDER BY step_number DESC
    `, [sessionId]);

    return rows.map(row => ({
      id: row.id,
      stepNumber: row.step_number,
      createdAt: new Date(row.created_at),
      description: row.description,
      triggerType: row.trigger_type as 'auto' | 'manual' | 'error',
      durationMs: row.duration_ms
    }));
  }

  /**
   * Delete a checkpoint
   */
  async delete(checkpointId: string): Promise<void> {
    await this.db.run(`DELETE FROM checkpoints WHERE id = ?`, [checkpointId]);
  }

  /**
   * Delete all checkpoints for a session
   */
  async clearSession(sessionId: string): Promise<void> {
    await this.db.run(`DELETE FROM checkpoints WHERE session_id = ?`, [sessionId]);
  }

  /**
   * Prune old checkpoints to stay under limit
   */
  private async pruneOldCheckpoints(
    sessionId: string,
    maxCheckpoints: number = 10
  ): Promise<void> {
    await this.db.run(`
      DELETE FROM checkpoints
      WHERE session_id = ? AND id NOT IN (
        SELECT id FROM checkpoints
        WHERE session_id = ?
        ORDER BY step_number DESC, created_at DESC
        LIMIT ?
      )
    `, [sessionId, sessionId, maxCheckpoints]);
  }

  private rowToCheckpoint(row: any): Checkpoint {
    return {
      id: row.id,
      sessionId: row.session_id,
      projectId: row.project_id,
      stepNumber: row.step_number,
      createdAt: new Date(row.created_at),
      state: JSON.parse(row.state_json),
      metadata: {
        description: row.description,
        triggerType: row.trigger_type,
        durationMs: row.duration_ms,
        tokenUsage: row.token_usage
      }
    };
  }
}

interface SaveOptions {
  description?: string;
  triggerType?: 'auto' | 'manual' | 'error';
  durationMs?: number;
  tokenUsage?: number;
}

interface CheckpointSummary {
  id: string;
  stepNumber: number;
  createdAt: Date;
  description?: string;
  triggerType: 'auto' | 'manual' | 'error';
  durationMs: number;
}
```

### Agent Executor with Checkpointing

```typescript
// src/agent/executor.ts

export class CheckpointedExecutor {
  private checkpointManager: CheckpointManager;
  
  /**
   * Execute a plan with automatic checkpointing
   */
  async execute(
    sessionId: string,
    projectId: string,
    plan: PlanStep[],
    options: ExecuteOptions = {}
  ): Promise<ExecutionResult> {
    // Check for existing checkpoint to resume from
    let state: AgentState;
    const existingCheckpoint = options.resumeFromCheckpoint
      ? await this.checkpointManager.loadLatest(sessionId)
      : null;

    if (existingCheckpoint) {
      state = existingCheckpoint.state;
      console.log(`Resuming from checkpoint at step ${state.currentStepIndex}`);
    } else {
      state = this.initializeState(plan, options.query || '');
    }

    const startTime = Date.now();
    
    try {
      // Execute remaining steps
      while (state.currentStepIndex < state.plan.length) {
        const step = state.plan[state.currentStepIndex];
        
        // Skip completed steps
        if (step.status === 'completed') {
          state.currentStepIndex++;
          continue;
        }

        // Execute step
        step.status = 'running';
        const stepStartTime = Date.now();
        
        try {
          const result = await this.executeStep(step, state);
          
          // Record result
          step.status = 'completed';
          state.results.push({
            stepId: step.id,
            output: result,
            completedAt: new Date(),
            durationMs: Date.now() - stepStartTime
          });
          
          state.currentStepIndex++;
          
          // Auto-checkpoint after each step
          if (options.autoCheckpoint !== false) {
            await this.checkpointManager.save(sessionId, projectId, state, {
              triggerType: 'auto',
              durationMs: Date.now() - startTime
            });
          }
          
        } catch (stepError) {
          step.status = 'failed';
          state.lastError = {
            stepIndex: state.currentStepIndex,
            message: (stepError as Error).message,
            timestamp: new Date()
          };
          
          // Checkpoint on error for recovery
          await this.checkpointManager.save(sessionId, projectId, state, {
            triggerType: 'error',
            description: `Failed at step ${state.currentStepIndex}: ${step.description}`,
            durationMs: Date.now() - startTime
          });
          
          throw stepError;
        }
      }

      // Final checkpoint
      await this.checkpointManager.save(sessionId, projectId, state, {
        triggerType: 'auto',
        description: 'Execution complete',
        durationMs: Date.now() - startTime
      });

      return {
        success: true,
        state,
        totalDurationMs: Date.now() - startTime
      };

    } catch (error) {
      return {
        success: false,
        state,
        error: (error as Error).message,
        totalDurationMs: Date.now() - startTime
      };
    }
  }

  private initializeState(plan: PlanStep[], query: string): AgentState {
    return {
      query,
      plan,
      currentStepIndex: 0,
      results: [],
      context: {}
    };
  }

  private async executeStep(step: PlanStep, state: AgentState): Promise<unknown> {
    // Implementation depends on step.action type
    // This is where tool calls, API requests, etc. happen
    throw new Error('executeStep must be implemented');
  }
}

interface ExecuteOptions {
  query?: string;
  resumeFromCheckpoint?: boolean;
  autoCheckpoint?: boolean;
}

interface ExecutionResult {
  success: boolean;
  state: AgentState;
  error?: string;
  totalDurationMs: number;
}
```

## MCP Tools

```typescript
// Checkpoint management tools

{
  name: 'checkpoint_save',
  description: 'Save current execution state as a checkpoint',
  inputSchema: {
    type: 'object',
    properties: {
      sessionId: { type: 'string' },
      state: { type: 'object', description: 'Current agent state to save' },
      description: { type: 'string', description: 'Human-readable checkpoint name' }
    },
    required: ['sessionId', 'state']
  }
},
{
  name: 'checkpoint_load',
  description: 'Load the latest checkpoint for a session',
  inputSchema: {
    type: 'object',
    properties: {
      sessionId: { type: 'string' },
      checkpointId: { type: 'string', description: 'Specific checkpoint ID (optional)' }
    },
    required: ['sessionId']
  }
},
{
  name: 'checkpoint_list',
  description: 'List all checkpoints for a session',
  inputSchema: {
    type: 'object',
    properties: {
      sessionId: { type: 'string' }
    },
    required: ['sessionId']
  }
}
```

## Examples

### Example 1: Research Agent with Checkpoints

```
Query: "Find all competitors and their quarterly revenue"

Plan:
  Step 1: Identify competitors from industry database
  Step 2: Fetch Q4 revenue for each competitor
  Step 3: Compile comparison report

Checkpoint 1 (after Step 1):
{
  "currentStepIndex": 1,
  "results": [
    { "stepId": "1", "output": ["CompanyA", "CompanyB", "CompanyC"] }
  ]
}

[Network failure during Step 2]

Checkpoint 2 (error):
{
  "currentStepIndex": 1,
  "lastError": { "message": "API timeout", "stepIndex": 1 }
}

[Resume later]
→ Loads Checkpoint 2
→ Skips Step 1 (already done)
→ Retries Step 2
→ Completes Step 3
```

### Example 2: Manual Checkpoint for Long Task

```typescript
// Agent can request manual checkpoint
await checkpointManager.save(sessionId, projectId, currentState, {
  triggerType: 'manual',
  description: 'User requested pause before external API calls'
});
```

## Configuration

```yaml
# ctx-sys.yaml
agent:
  checkpoints:
    enabled: true
    autoCheckpoint: true
    maxCheckpointsPerSession: 10
    pruneAfterDays: 30
    compressState: true        # Compress large states
```

## Testing

```typescript
describe('CheckpointManager', () => {
  it('should save and load checkpoints', async () => {
    const state: AgentState = {
      query: 'test query',
      plan: [{ id: '1', description: 'Step 1', action: 'test', parameters: {}, status: 'completed' }],
      currentStepIndex: 1,
      results: [{ stepId: '1', output: 'result', completedAt: new Date(), durationMs: 100 }],
      context: {}
    };
    
    const saved = await manager.save('session-1', 'project-1', state);
    const loaded = await manager.loadLatest('session-1');
    
    expect(loaded).not.toBeNull();
    expect(loaded!.state.currentStepIndex).toBe(1);
    expect(loaded!.state.results[0].output).toBe('result');
  });

  it('should prune old checkpoints', async () => {
    // Save 15 checkpoints
    for (let i = 0; i < 15; i++) {
      await manager.save('session-1', 'project-1', { currentStepIndex: i } as AgentState);
    }
    
    const checkpoints = await manager.list('session-1');
    expect(checkpoints.length).toBeLessThanOrEqual(10);
  });

  it('should resume from checkpoint', async () => {
    const checkpoint = await manager.loadLatest('session-1');
    const result = await executor.execute('session-1', 'project-1', plan, {
      resumeFromCheckpoint: true
    });
    
    // Should skip already-completed steps
    expect(result.state.results.length).toBeGreaterThan(checkpoint!.state.results.length);
  });
});
```

## Metrics to Track

| Metric | Description |
|--------|-------------|
| `checkpoint_save_count` | Number of checkpoints saved |
| `checkpoint_resume_count` | Number of times execution resumed |
| `checkpoint_save_size_bytes` | Average checkpoint size |
| `checkpoint_save_latency_ms` | Time to save checkpoint |
| `steps_recovered` | Steps not re-executed due to checkpointing |
