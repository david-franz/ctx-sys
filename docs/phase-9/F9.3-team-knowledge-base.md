# F9.3 Team Knowledge Base

**Phase**: 9 - Integrations & Analytics
**Priority**: Medium
**Dependencies**: F3.2 Session Management, F3.4 Decision Extraction, F5.2 Entity Resolution

## Goal

Enable shared context across team members, allowing decisions, conversations, and knowledge to be searchable organization-wide while respecting access controls.

## Overview

Individual developers accumulate valuable context through their conversations:
- Architecture decisions made during debugging sessions
- Workarounds discovered for tricky problems
- Domain knowledge shared by experts
- Tribal knowledge that never gets documented

Without sharing, this knowledge is siloed. Team Knowledge Base enables:
- Shared project spanning team conversations
- Decision search across all team members' sessions
- "Who knows about X?" queries based on conversation history
- Onboarding mode that surfaces relevant history for new devs
- Access control for sensitive information

## Data Model

```typescript
interface Team {
  id: string;
  name: string;
  slug: string;                      // URL-friendly identifier
  createdAt: Date;
  
  // Settings
  settings: TeamSettings;
  
  // Membership
  members: TeamMember[];
  
  // Shared spaces
  projects: SharedProject[];
}

interface TeamSettings {
  defaultVisibility: 'public' | 'team' | 'private';
  allowExternalSharing: boolean;
  autoShareDecisions: boolean;
  retentionDays: number;
  
  // AI settings
  enableCrossUserSearch: boolean;
  anonymizeContributions: boolean;
}

interface TeamMember {
  userId: string;
  teamId: string;
  role: 'owner' | 'admin' | 'member' | 'viewer';
  joinedAt: Date;
  
  // Preferences
  sharePreference: 'all' | 'decisions-only' | 'manual';
  anonymize: boolean;
}

interface SharedProject {
  projectId: string;
  teamId: string;
  sharedAt: Date;
  sharedBy: string;
  
  // Access
  accessLevel: 'read' | 'write' | 'admin';
  
  // Stats
  contributorCount: number;
  decisionCount: number;
  lastActivity: Date;
}

interface SharedKnowledge {
  id: string;
  teamId: string;
  projectId?: string;
  
  // Source
  sourceType: 'decision' | 'insight' | 'documentation' | 'conversation';
  sourceSessionId?: string;
  contributorId: string;
  
  // Content
  title: string;
  content: string;
  summary: string;
  
  // Classification
  visibility: 'public' | 'team' | 'private';
  tags: string[];
  topics: string[];
  
  // Metadata
  createdAt: Date;
  updatedAt: Date;
  
  // Engagement
  views: number;
  helpfulVotes: number;
  references: string[];            // IDs of related knowledge
}

interface KnowledgeSearchResult {
  knowledge: SharedKnowledge;
  score: number;
  matchType: 'exact' | 'semantic' | 'related';
  
  // Attribution
  contributor?: {
    id: string;
    name: string;
    expertise: string[];
  };
  
  // Context
  relatedDecisions: string[];
  relatedCode: string[];
}

interface ExpertiseProfile {
  userId: string;
  teamId: string;
  
  // Computed from contributions
  topics: TopicExpertise[];
  recentActivity: ActivitySummary[];
  
  // Stats
  totalContributions: number;
  helpfulnessScore: number;
}

interface TopicExpertise {
  topic: string;
  confidence: number;              // 0-1 based on contribution depth
  contributionCount: number;
  lastContribution: Date;
}

interface OnboardingContext {
  userId: string;
  teamId: string;
  startedAt: Date;
  
  // Progress tracking
  topicsExplored: string[];
  decisionsReviewed: string[];
  expertsConnected: string[];
  
  // Recommendations
  suggestedTopics: SuggestedTopic[];
  suggestedExperts: string[];
  essentialDecisions: string[];
}

interface SuggestedTopic {
  topic: string;
  relevance: 'critical' | 'important' | 'helpful';
  reason: string;
  resources: SharedKnowledge[];
}
```

## Database Schema

```sql
-- Teams
CREATE TABLE teams (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL,
  slug TEXT UNIQUE NOT NULL,
  created_at TEXT NOT NULL,
  settings_json TEXT NOT NULL DEFAULT '{}'
);

CREATE INDEX idx_teams_slug ON teams(slug);

-- Team members
CREATE TABLE team_members (
  user_id TEXT NOT NULL,
  team_id TEXT NOT NULL,
  role TEXT NOT NULL,
  joined_at TEXT NOT NULL,
  share_preference TEXT DEFAULT 'decisions-only',
  anonymize INTEGER DEFAULT 0,
  
  PRIMARY KEY (user_id, team_id),
  FOREIGN KEY (team_id) REFERENCES teams(id)
);

CREATE INDEX idx_team_members_team ON team_members(team_id);

-- Shared projects
CREATE TABLE shared_projects (
  project_id TEXT NOT NULL,
  team_id TEXT NOT NULL,
  shared_at TEXT NOT NULL,
  shared_by TEXT NOT NULL,
  access_level TEXT DEFAULT 'read',
  
  PRIMARY KEY (project_id, team_id),
  FOREIGN KEY (team_id) REFERENCES teams(id),
  FOREIGN KEY (project_id) REFERENCES projects(id)
);

-- Shared knowledge items
CREATE TABLE shared_knowledge (
  id TEXT PRIMARY KEY,
  team_id TEXT NOT NULL,
  project_id TEXT,
  
  source_type TEXT NOT NULL,
  source_session_id TEXT,
  contributor_id TEXT NOT NULL,
  
  title TEXT NOT NULL,
  content TEXT NOT NULL,
  summary TEXT,
  
  visibility TEXT DEFAULT 'team',
  tags_json TEXT DEFAULT '[]',
  topics_json TEXT DEFAULT '[]',
  
  created_at TEXT NOT NULL,
  updated_at TEXT NOT NULL,
  
  views INTEGER DEFAULT 0,
  helpful_votes INTEGER DEFAULT 0,
  references_json TEXT DEFAULT '[]',
  
  -- For semantic search
  embedding BLOB,
  
  FOREIGN KEY (team_id) REFERENCES teams(id)
);

CREATE INDEX idx_knowledge_team ON shared_knowledge(team_id, created_at DESC);
CREATE INDEX idx_knowledge_contributor ON shared_knowledge(contributor_id);
CREATE INDEX idx_knowledge_visibility ON shared_knowledge(visibility, team_id);

-- Full-text search for knowledge
CREATE VIRTUAL TABLE knowledge_fts USING fts5(
  title, content, summary, tags,
  content='shared_knowledge',
  content_rowid='rowid'
);

-- Expertise tracking
CREATE TABLE user_expertise (
  user_id TEXT NOT NULL,
  team_id TEXT NOT NULL,
  topic TEXT NOT NULL,
  confidence REAL DEFAULT 0,
  contribution_count INTEGER DEFAULT 0,
  last_contribution TEXT,
  
  PRIMARY KEY (user_id, team_id, topic),
  FOREIGN KEY (team_id) REFERENCES teams(id)
);

CREATE INDEX idx_expertise_topic ON user_expertise(team_id, topic, confidence DESC);

-- Knowledge votes
CREATE TABLE knowledge_votes (
  knowledge_id TEXT NOT NULL,
  user_id TEXT NOT NULL,
  vote INTEGER NOT NULL,           -- 1 or -1
  created_at TEXT NOT NULL,
  
  PRIMARY KEY (knowledge_id, user_id),
  FOREIGN KEY (knowledge_id) REFERENCES shared_knowledge(id)
);

-- Onboarding progress
CREATE TABLE onboarding_progress (
  user_id TEXT NOT NULL,
  team_id TEXT NOT NULL,
  started_at TEXT NOT NULL,
  
  topics_explored_json TEXT DEFAULT '[]',
  decisions_reviewed_json TEXT DEFAULT '[]',
  experts_connected_json TEXT DEFAULT '[]',
  
  PRIMARY KEY (user_id, team_id),
  FOREIGN KEY (team_id) REFERENCES teams(id)
);
```

## Implementation

### File: `src/team/knowledge-base.ts`

```typescript
import { Database } from '../db/database';
import { EmbeddingManager } from '../embeddings/manager';
import { generateId } from '../utils/id';

export class TeamKnowledgeBase {
  constructor(
    private db: Database,
    private embeddingManager: EmbeddingManager
  ) {}

  /**
   * Share knowledge with the team
   */
  async shareKnowledge(
    teamId: string,
    contributorId: string,
    input: ShareKnowledgeInput
  ): Promise<SharedKnowledge> {
    // Check contributor is team member
    const member = await this.getMember(teamId, contributorId);
    if (!member) {
      throw new Error('User is not a team member');
    }
    
    // Generate embedding for semantic search
    const embedding = await this.embeddingManager.generateEmbedding(
      `${input.title} ${input.content}`
    );
    
    // Extract topics from content
    const topics = await this.extractTopics(input.content);
    
    const knowledge: SharedKnowledge = {
      id: generateId('know'),
      teamId,
      projectId: input.projectId,
      sourceType: input.sourceType,
      sourceSessionId: input.sourceSessionId,
      contributorId: member.anonymize ? 'anonymous' : contributorId,
      title: input.title,
      content: input.content,
      summary: input.summary || await this.generateSummary(input.content),
      visibility: input.visibility || 'team',
      tags: input.tags || [],
      topics,
      createdAt: new Date(),
      updatedAt: new Date(),
      views: 0,
      helpfulVotes: 0,
      references: []
    };
    
    await this.db.run(`
      INSERT INTO shared_knowledge (
        id, team_id, project_id, source_type, source_session_id,
        contributor_id, title, content, summary, visibility,
        tags_json, topics_json, created_at, updated_at, embedding
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `, [
      knowledge.id,
      knowledge.teamId,
      knowledge.projectId,
      knowledge.sourceType,
      knowledge.sourceSessionId,
      knowledge.contributorId,
      knowledge.title,
      knowledge.content,
      knowledge.summary,
      knowledge.visibility,
      JSON.stringify(knowledge.tags),
      JSON.stringify(knowledge.topics),
      knowledge.createdAt.toISOString(),
      knowledge.updatedAt.toISOString(),
      embedding
    ]);
    
    // Update FTS index
    await this.db.run(`
      INSERT INTO knowledge_fts (rowid, title, content, summary, tags)
      SELECT rowid, title, content, summary, tags_json
      FROM shared_knowledge WHERE id = ?
    `, [knowledge.id]);
    
    // Update contributor expertise
    await this.updateExpertise(contributorId, teamId, topics);
    
    return knowledge;
  }

  /**
   * Search team knowledge base
   */
  async search(
    teamId: string,
    userId: string,
    query: string,
    options: SearchOptions = {}
  ): Promise<KnowledgeSearchResult[]> {
    const results: KnowledgeSearchResult[] = [];
    
    // Semantic search
    const queryEmbedding = await this.embeddingManager.generateEmbedding(query);
    
    const semanticResults = await this.db.all(`
      SELECT
        k.*,
        vec_distance_cosine(k.embedding, ?) as distance
      FROM shared_knowledge k
      WHERE k.team_id = ?
        AND (k.visibility = 'public' 
             OR (k.visibility = 'team' AND ? IN (SELECT user_id FROM team_members WHERE team_id = ?))
             OR k.contributor_id = ?)
      ORDER BY distance ASC
      LIMIT ?
    `, [queryEmbedding, teamId, userId, teamId, userId, options.limit || 20]);
    
    // Full-text search for exact matches
    const ftsResults = await this.db.all(`
      SELECT k.*, fts.rank
      FROM knowledge_fts fts
      JOIN shared_knowledge k ON k.rowid = fts.rowid
      WHERE knowledge_fts MATCH ?
        AND k.team_id = ?
      ORDER BY fts.rank
      LIMIT ?
    `, [this.escapeFtsQuery(query), teamId, options.limit || 20]);
    
    // Merge and deduplicate results
    const seen = new Set<string>();
    
    // Add FTS results first (exact matches)
    for (const row of ftsResults) {
      if (!seen.has(row.id)) {
        seen.add(row.id);
        results.push(await this.enrichResult(row, 'exact', -row.rank));
      }
    }
    
    // Add semantic results
    for (const row of semanticResults) {
      if (!seen.has(row.id)) {
        seen.add(row.id);
        results.push(await this.enrichResult(row, 'semantic', 1 - row.distance));
      }
    }
    
    // Sort by combined score
    results.sort((a, b) => b.score - a.score);
    
    // Record view for analytics
    await this.recordSearchView(userId, results.slice(0, 5).map(r => r.knowledge.id));
    
    return results.slice(0, options.limit || 20);
  }

  /**
   * Find experts on a topic
   */
  async findExperts(
    teamId: string,
    topic: string,
    limit: number = 5
  ): Promise<ExpertiseProfile[]> {
    const rows = await this.db.all(`
      SELECT
        e.user_id,
        e.topic,
        e.confidence,
        e.contribution_count,
        e.last_contribution,
        m.role
      FROM user_expertise e
      JOIN team_members m ON m.user_id = e.user_id AND m.team_id = e.team_id
      WHERE e.team_id = ?
        AND e.topic LIKE ?
      ORDER BY e.confidence DESC, e.contribution_count DESC
      LIMIT ?
    `, [teamId, `%${topic}%`, limit]);
    
    const profiles: ExpertiseProfile[] = [];
    
    for (const row of rows) {
      // Get full expertise profile
      const allTopics = await this.db.all(`
        SELECT topic, confidence, contribution_count, last_contribution
        FROM user_expertise
        WHERE user_id = ? AND team_id = ?
        ORDER BY confidence DESC
        LIMIT 10
      `, [row.user_id, teamId]);
      
      profiles.push({
        userId: row.user_id,
        teamId,
        topics: allTopics.map(t => ({
          topic: t.topic,
          confidence: t.confidence,
          contributionCount: t.contribution_count,
          lastContribution: new Date(t.last_contribution)
        })),
        recentActivity: [],
        totalContributions: allTopics.reduce((sum, t) => sum + t.contribution_count, 0),
        helpfulnessScore: 0 // Calculated separately
      });
    }
    
    return profiles;
  }

  /**
   * Get onboarding recommendations for a new team member
   */
  async getOnboardingContext(
    teamId: string,
    userId: string
  ): Promise<OnboardingContext> {
    // Get or create onboarding progress
    let progress = await this.getOnboardingProgress(teamId, userId);
    if (!progress) {
      progress = await this.createOnboardingProgress(teamId, userId);
    }
    
    // Find essential decisions (high-impact, frequently referenced)
    const essentialDecisions = await this.db.all(`
      SELECT id, title, summary
      FROM shared_knowledge
      WHERE team_id = ?
        AND source_type = 'decision'
        AND helpful_votes > 0
        AND id NOT IN (SELECT value FROM json_each(?))
      ORDER BY helpful_votes DESC, views DESC
      LIMIT 10
    `, [teamId, JSON.stringify(progress.decisionsReviewed)]);
    
    // Find suggested topics based on project activity
    const suggestedTopics = await this.getSuggestedTopics(teamId, progress);
    
    // Find experts to connect with
    const suggestedExperts = await this.getSuggestedExperts(teamId, suggestedTopics);
    
    return {
      userId,
      teamId,
      startedAt: progress.startedAt,
      topicsExplored: progress.topicsExplored,
      decisionsReviewed: progress.decisionsReviewed,
      expertsConnected: progress.expertsConnected,
      suggestedTopics,
      suggestedExperts,
      essentialDecisions: essentialDecisions.map(d => d.id)
    };
  }

  /**
   * Auto-share decisions from a session
   */
  async autoShareFromSession(
    teamId: string,
    sessionId: string,
    contributorId: string
  ): Promise<SharedKnowledge[]> {
    // Check team settings allow auto-share
    const team = await this.getTeam(teamId);
    if (!team.settings.autoShareDecisions) {
      return [];
    }
    
    // Check user preference
    const member = await this.getMember(teamId, contributorId);
    if (member.sharePreference === 'manual') {
      return [];
    }
    
    // Get decisions from session
    const decisions = await this.db.all(`
      SELECT * FROM decisions
      WHERE session_id = ?
        AND confidence > 0.7
    `, [sessionId]);
    
    const shared: SharedKnowledge[] = [];
    
    for (const decision of decisions) {
      // Check if already shared
      const existing = await this.db.get(`
        SELECT id FROM shared_knowledge
        WHERE source_session_id = ? AND source_type = 'decision'
          AND content = ?
      `, [sessionId, decision.decision]);
      
      if (existing) continue;
      
      const knowledge = await this.shareKnowledge(teamId, contributorId, {
        sourceType: 'decision',
        sourceSessionId: sessionId,
        projectId: decision.project_id,
        title: this.generateDecisionTitle(decision.decision),
        content: decision.decision,
        summary: decision.rationale,
        tags: decision.tags || [],
        visibility: 'team'
      });
      
      shared.push(knowledge);
    }
    
    return shared;
  }

  /**
   * Vote on knowledge helpfulness
   */
  async vote(
    knowledgeId: string,
    userId: string,
    helpful: boolean
  ): Promise<void> {
    const vote = helpful ? 1 : -1;
    
    await this.db.run(`
      INSERT OR REPLACE INTO knowledge_votes (knowledge_id, user_id, vote, created_at)
      VALUES (?, ?, ?, ?)
    `, [knowledgeId, userId, vote, new Date().toISOString()]);
    
    // Update aggregate count
    await this.db.run(`
      UPDATE shared_knowledge
      SET helpful_votes = (
        SELECT SUM(vote) FROM knowledge_votes WHERE knowledge_id = ?
      )
      WHERE id = ?
    `, [knowledgeId, knowledgeId]);
  }

  private async enrichResult(
    row: any,
    matchType: 'exact' | 'semantic' | 'related',
    score: number
  ): Promise<KnowledgeSearchResult> {
    const knowledge = this.rowToKnowledge(row);
    
    // Get contributor info if not anonymous
    let contributor;
    if (knowledge.contributorId !== 'anonymous') {
      contributor = await this.getContributorInfo(knowledge.contributorId, knowledge.teamId);
    }
    
    return {
      knowledge,
      score,
      matchType,
      contributor,
      relatedDecisions: [],
      relatedCode: []
    };
  }

  private async updateExpertise(
    userId: string,
    teamId: string,
    topics: string[]
  ): Promise<void> {
    for (const topic of topics) {
      await this.db.run(`
        INSERT INTO user_expertise (user_id, team_id, topic, confidence, contribution_count, last_contribution)
        VALUES (?, ?, ?, 0.1, 1, ?)
        ON CONFLICT (user_id, team_id, topic) DO UPDATE SET
          confidence = MIN(1.0, confidence + 0.05),
          contribution_count = contribution_count + 1,
          last_contribution = excluded.last_contribution
      `, [userId, teamId, topic, new Date().toISOString()]);
    }
  }

  private async extractTopics(content: string): Promise<string[]> {
    // Simple keyword extraction - could be enhanced with NLP
    const words = content.toLowerCase().split(/\W+/);
    const stopwords = new Set(['the', 'a', 'an', 'is', 'are', 'was', 'were', 'be', 'been', 'being']);
    
    const wordFreq = new Map<string, number>();
    for (const word of words) {
      if (word.length > 3 && !stopwords.has(word)) {
        wordFreq.set(word, (wordFreq.get(word) || 0) + 1);
      }
    }
    
    // Return top 5 by frequency
    return [...wordFreq.entries()]
      .sort((a, b) => b[1] - a[1])
      .slice(0, 5)
      .map(([word]) => word);
  }

  private async generateSummary(content: string): Promise<string> {
    // Simple extractive summary - first few sentences
    const sentences = content.split(/[.!?]+/).filter(s => s.trim().length > 0);
    return sentences.slice(0, 2).join('. ') + '.';
  }

  private generateDecisionTitle(decision: string): string {
    // Extract first clause or truncate
    const firstClause = decision.split(/[,;:]|because|since|as/i)[0];
    if (firstClause.length <= 60) {
      return firstClause.trim();
    }
    return decision.substring(0, 57).trim() + '...';
  }

  private escapeFtsQuery(query: string): string {
    // Escape special FTS5 characters
    return query.replace(/['"()]/g, ' ').trim();
  }

  private rowToKnowledge(row: any): SharedKnowledge {
    return {
      id: row.id,
      teamId: row.team_id,
      projectId: row.project_id,
      sourceType: row.source_type,
      sourceSessionId: row.source_session_id,
      contributorId: row.contributor_id,
      title: row.title,
      content: row.content,
      summary: row.summary,
      visibility: row.visibility,
      tags: JSON.parse(row.tags_json || '[]'),
      topics: JSON.parse(row.topics_json || '[]'),
      createdAt: new Date(row.created_at),
      updatedAt: new Date(row.updated_at),
      views: row.views,
      helpfulVotes: row.helpful_votes,
      references: JSON.parse(row.references_json || '[]')
    };
  }
}
```

### File: `src/team/team-manager.ts`

```typescript
import { Database } from '../db/database';
import { generateId } from '../utils/id';

export class TeamManager {
  constructor(private db: Database) {}

  /**
   * Create a new team
   */
  async createTeam(
    name: string,
    ownerId: string,
    settings: Partial<TeamSettings> = {}
  ): Promise<Team> {
    const team: Team = {
      id: generateId('team'),
      name,
      slug: this.generateSlug(name),
      createdAt: new Date(),
      settings: { ...defaultTeamSettings, ...settings },
      members: [],
      projects: []
    };
    
    await this.db.run(`
      INSERT INTO teams (id, name, slug, created_at, settings_json)
      VALUES (?, ?, ?, ?, ?)
    `, [team.id, team.name, team.slug, team.createdAt.toISOString(), JSON.stringify(team.settings)]);
    
    // Add owner as first member
    await this.addMember(team.id, ownerId, 'owner');
    
    return team;
  }

  /**
   * Add a member to the team
   */
  async addMember(
    teamId: string,
    userId: string,
    role: TeamMember['role'] = 'member'
  ): Promise<TeamMember> {
    const member: TeamMember = {
      userId,
      teamId,
      role,
      joinedAt: new Date(),
      sharePreference: 'decisions-only',
      anonymize: false
    };
    
    await this.db.run(`
      INSERT INTO team_members (user_id, team_id, role, joined_at, share_preference, anonymize)
      VALUES (?, ?, ?, ?, ?, ?)
    `, [member.userId, member.teamId, member.role, member.joinedAt.toISOString(), member.sharePreference, 0]);
    
    return member;
  }

  /**
   * Share a project with the team
   */
  async shareProject(
    teamId: string,
    projectId: string,
    sharedBy: string,
    accessLevel: 'read' | 'write' | 'admin' = 'read'
  ): Promise<SharedProject> {
    // Verify user can share
    const member = await this.getMember(teamId, sharedBy);
    if (!member || !['owner', 'admin'].includes(member.role)) {
      throw new Error('Insufficient permissions to share project');
    }
    
    const shared: SharedProject = {
      projectId,
      teamId,
      sharedAt: new Date(),
      sharedBy,
      accessLevel,
      contributorCount: 0,
      decisionCount: 0,
      lastActivity: new Date()
    };
    
    await this.db.run(`
      INSERT OR REPLACE INTO shared_projects (project_id, team_id, shared_at, shared_by, access_level)
      VALUES (?, ?, ?, ?, ?)
    `, [shared.projectId, shared.teamId, shared.sharedAt.toISOString(), shared.sharedBy, shared.accessLevel]);
    
    return shared;
  }

  /**
   * Get team with members and projects
   */
  async getTeam(teamId: string): Promise<Team | null> {
    const row = await this.db.get(`SELECT * FROM teams WHERE id = ?`, [teamId]);
    if (!row) return null;
    
    const members = await this.db.all(`
      SELECT * FROM team_members WHERE team_id = ?
    `, [teamId]);
    
    const projects = await this.db.all(`
      SELECT * FROM shared_projects WHERE team_id = ?
    `, [teamId]);
    
    return {
      id: row.id,
      name: row.name,
      slug: row.slug,
      createdAt: new Date(row.created_at),
      settings: JSON.parse(row.settings_json),
      members: members.map(m => ({
        userId: m.user_id,
        teamId: m.team_id,
        role: m.role,
        joinedAt: new Date(m.joined_at),
        sharePreference: m.share_preference,
        anonymize: m.anonymize === 1
      })),
      projects: projects.map(p => ({
        projectId: p.project_id,
        teamId: p.team_id,
        sharedAt: new Date(p.shared_at),
        sharedBy: p.shared_by,
        accessLevel: p.access_level,
        contributorCount: 0,
        decisionCount: 0,
        lastActivity: new Date(p.shared_at)
      }))
    };
  }

  /**
   * Update member preferences
   */
  async updateMemberPreferences(
    teamId: string,
    userId: string,
    preferences: Partial<Pick<TeamMember, 'sharePreference' | 'anonymize'>>
  ): Promise<void> {
    const updates: string[] = [];
    const values: any[] = [];
    
    if (preferences.sharePreference !== undefined) {
      updates.push('share_preference = ?');
      values.push(preferences.sharePreference);
    }
    
    if (preferences.anonymize !== undefined) {
      updates.push('anonymize = ?');
      values.push(preferences.anonymize ? 1 : 0);
    }
    
    if (updates.length > 0) {
      values.push(teamId, userId);
      await this.db.run(`
        UPDATE team_members SET ${updates.join(', ')}
        WHERE team_id = ? AND user_id = ?
      `, values);
    }
  }

  private generateSlug(name: string): string {
    return name
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-|-$/g, '');
  }

  private async getMember(teamId: string, userId: string): Promise<TeamMember | null> {
    const row = await this.db.get(`
      SELECT * FROM team_members WHERE team_id = ? AND user_id = ?
    `, [teamId, userId]);
    
    if (!row) return null;
    
    return {
      userId: row.user_id,
      teamId: row.team_id,
      role: row.role,
      joinedAt: new Date(row.joined_at),
      sharePreference: row.share_preference,
      anonymize: row.anonymize === 1
    };
  }
}

const defaultTeamSettings: TeamSettings = {
  defaultVisibility: 'team',
  allowExternalSharing: false,
  autoShareDecisions: true,
  retentionDays: 365,
  enableCrossUserSearch: true,
  anonymizeContributions: false
};
```

## MCP Tools

### Tool: `team_search_knowledge`

```typescript
{
  name: 'team_search_knowledge',
  description: 'Search team knowledge base for shared decisions, insights, and documentation',
  parameters: {
    teamId: { type: 'string', required: true },
    query: { type: 'string', required: true },
    limit: { type: 'number', default: 10 },
    sourceType: { type: 'string', enum: ['decision', 'insight', 'documentation', 'conversation'] }
  },
  handler: async ({ teamId, query, limit, sourceType }, context) => {
    const results = await knowledgeBase.search(teamId, context.userId, query, {
      limit,
      sourceType
    });
    
    return {
      results: results.map(r => ({
        id: r.knowledge.id,
        title: r.knowledge.title,
        summary: r.knowledge.summary,
        type: r.knowledge.sourceType,
        score: r.score,
        contributor: r.contributor?.name,
        topics: r.knowledge.topics,
        helpful: r.knowledge.helpfulVotes
      })),
      total: results.length
    };
  }
}
```

### Tool: `team_find_expert`

```typescript
{
  name: 'team_find_expert',
  description: 'Find team members with expertise on a topic',
  parameters: {
    teamId: { type: 'string', required: true },
    topic: { type: 'string', required: true },
    limit: { type: 'number', default: 5 }
  },
  handler: async ({ teamId, topic, limit }) => {
    const experts = await knowledgeBase.findExperts(teamId, topic, limit);
    
    return {
      experts: experts.map(e => ({
        userId: e.userId,
        confidence: e.topics.find(t => t.topic.includes(topic))?.confidence || 0,
        relatedTopics: e.topics.slice(0, 5).map(t => t.topic),
        totalContributions: e.totalContributions
      }))
    };
  }
}
```

### Tool: `team_share_knowledge`

```typescript
{
  name: 'team_share_knowledge',
  description: 'Share a decision, insight, or documentation with the team',
  parameters: {
    teamId: { type: 'string', required: true },
    title: { type: 'string', required: true },
    content: { type: 'string', required: true },
    sourceType: { type: 'string', required: true, enum: ['decision', 'insight', 'documentation'] },
    tags: { type: 'array', items: { type: 'string' } },
    visibility: { type: 'string', enum: ['public', 'team', 'private'], default: 'team' }
  },
  handler: async (params, context) => {
    const knowledge = await knowledgeBase.shareKnowledge(params.teamId, context.userId, {
      title: params.title,
      content: params.content,
      sourceType: params.sourceType,
      tags: params.tags,
      visibility: params.visibility
    });
    
    return {
      id: knowledge.id,
      title: knowledge.title,
      topics: knowledge.topics,
      shared: true
    };
  }
}
```

### Tool: `team_get_onboarding`

```typescript
{
  name: 'team_get_onboarding',
  description: 'Get onboarding recommendations for a new team member',
  parameters: {
    teamId: { type: 'string', required: true }
  },
  handler: async ({ teamId }, context) => {
    const onboarding = await knowledgeBase.getOnboardingContext(teamId, context.userId);
    
    return {
      progress: {
        topicsExplored: onboarding.topicsExplored.length,
        decisionsReviewed: onboarding.decisionsReviewed.length,
        expertsConnected: onboarding.expertsConnected.length
      },
      recommended: {
        topics: onboarding.suggestedTopics.map(t => ({
          topic: t.topic,
          relevance: t.relevance,
          reason: t.reason
        })),
        decisions: onboarding.essentialDecisions,
        experts: onboarding.suggestedExperts
      }
    };
  }
}
```

## Testing

```typescript
describe('TeamKnowledgeBase', () => {
  let kb: TeamKnowledgeBase;
  let teamManager: TeamManager;
  let teamId: string;
  
  beforeEach(async () => {
    const db = await createTestDatabase();
    kb = new TeamKnowledgeBase(db, new MockEmbeddingManager());
    teamManager = new TeamManager(db);
    
    const team = await teamManager.createTeam('Test Team', 'user1');
    teamId = team.id;
    await teamManager.addMember(teamId, 'user2', 'member');
  });
  
  describe('sharing knowledge', () => {
    it('should share decision with team', async () => {
      const knowledge = await kb.shareKnowledge(teamId, 'user1', {
        sourceType: 'decision',
        title: 'Use TypeScript',
        content: 'We decided to use TypeScript for type safety',
        tags: ['typescript', 'tooling']
      });
      
      expect(knowledge.id).toBeDefined();
      expect(knowledge.topics.length).toBeGreaterThan(0);
    });
    
    it('should anonymize contributor if requested', async () => {
      await teamManager.updateMemberPreferences(teamId, 'user1', { anonymize: true });
      
      const knowledge = await kb.shareKnowledge(teamId, 'user1', {
        sourceType: 'insight',
        title: 'Performance tip',
        content: 'Always use indexes on frequently queried columns'
      });
      
      expect(knowledge.contributorId).toBe('anonymous');
    });
  });
  
  describe('searching', () => {
    it('should find knowledge by semantic search', async () => {
      await kb.shareKnowledge(teamId, 'user1', {
        sourceType: 'decision',
        title: 'Authentication approach',
        content: 'Use JWT tokens for stateless authentication with refresh token rotation'
      });
      
      const results = await kb.search(teamId, 'user2', 'how do we handle auth?');
      
      expect(results.length).toBeGreaterThan(0);
      expect(results[0].knowledge.title).toContain('Authentication');
    });
    
    it('should respect visibility settings', async () => {
      await kb.shareKnowledge(teamId, 'user1', {
        sourceType: 'insight',
        title: 'Private note',
        content: 'Something only I should see',
        visibility: 'private'
      });
      
      const results = await kb.search(teamId, 'user2', 'private note');
      expect(results.length).toBe(0);
    });
  });
  
  describe('expertise tracking', () => {
    it('should identify experts by contributions', async () => {
      // User1 contributes multiple auth-related items
      for (let i = 0; i < 5; i++) {
        await kb.shareKnowledge(teamId, 'user1', {
          sourceType: 'decision',
          title: `Auth decision ${i}`,
          content: `Authentication implementation detail ${i}`
        });
      }
      
      const experts = await kb.findExperts(teamId, 'auth');
      
      expect(experts[0].userId).toBe('user1');
      expect(experts[0].topics[0].confidence).toBeGreaterThan(0.2);
    });
  });
});
```

## Success Metrics

| Metric | Target | Measurement |
|--------|--------|-------------|
| Search latency | < 500ms | Query to results |
| Knowledge reuse | 30%+ | Queries finding relevant shared knowledge |
| Onboarding time | -25% | Time for new devs to be productive |
| Expert finding | 80%+ | Accuracy of expert recommendations |
| Contributor engagement | 60%+ | Team members sharing knowledge |

## Future Enhancements

1. **Slack/Teams integration** - Share and search from chat
2. **Knowledge graphs** - Visualize relationships between topics
3. **Learning paths** - Structured onboarding curricula
4. **Q&A mode** - Ask questions, get expert answers
5. **Knowledge verification** - Periodically validate shared knowledge is still accurate
6. **Cross-team search** - Search across multiple teams (with permissions)
7. **AI-generated summaries** - Automatic team knowledge digests
