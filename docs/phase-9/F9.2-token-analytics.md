# F9.2 Token Analytics

**Phase**: 9 - Integrations & Analytics
**Priority**: Critical (Proves ROI)
**Dependencies**: F1.1 Database Schema, F6.3 Context Assembly, F1.5 MCP Server

## Goal

Track and visualize token usage to demonstrate ROI, enabling users to quantify the value of intelligent context retrieval versus naive full-context approaches.

## Overview

Without analytics, ctx-sys value is invisible. Users need to see:
- How many tokens they're using vs. would have used
- Cost savings in dollars
- Quality of retrieved context
- Usage patterns over time

This feature makes the value proposition concrete and measurable.

## Value Proposition

```
Traditional approach:
  - Send entire codebase context every query
  - 100,000 tokens per query
  - $3.00 per query (at $0.03/1k tokens)

With ctx-sys:
  - Send only relevant context
  - 5,000 tokens per query (avg)
  - $0.15 per query

Savings per query: $2.85 (95%)
```

## Data Model

```typescript
interface QueryLog {
  id: string;
  projectId: string;
  sessionId: string;
  timestamp: Date;
  
  // Query details
  query: string;
  queryType: 'context' | 'search' | 'decision' | 'entity';
  
  // Token metrics
  tokensRetrieved: number;           // What we actually retrieved
  tokensEstimatedFull: number;       // What full context would be
  tokensSaved: number;               // Difference
  
  // Cost estimates
  costActual: number;                // Based on retrieved
  costEstimatedFull: number;         // Based on full context
  costSaved: number;
  
  // Quality metrics
  relevanceScore: number;            // Average relevance of results
  itemCount: number;                 // Number of items returned
  wasUseful?: boolean;               // User feedback if provided
  
  // Performance
  latencyMs: number;
  
  // Retrieval details
  retrievalStrategies: string[];     // Which strategies were used
  itemTypes: Record<string, number>; // Count by type
}

interface UsageStats {
  period: 'day' | 'week' | 'month' | 'all';
  startDate: Date;
  endDate: Date;
  
  // Aggregate metrics
  totalQueries: number;
  totalTokensRetrieved: number;
  totalTokensSaved: number;
  totalTokensEstimatedFull: number;
  
  // Cost metrics
  totalCostActual: number;
  totalCostSaved: number;
  savingsPercent: number;
  
  // Quality metrics
  averageRelevance: number;
  usefulnessRate: number;            // % marked useful
  
  // Breakdowns
  byDay: DailyStats[];
  byQueryType: Record<string, QueryTypeStats>;
  byProject: Record<string, ProjectStats>;
}

interface DailyStats {
  date: string;                      // YYYY-MM-DD
  queries: number;
  tokensRetrieved: number;
  tokensSaved: number;
  costSaved: number;
  avgRelevance: number;
}

interface QueryTypeStats {
  queryType: string;
  queries: number;
  avgTokens: number;
  avgSavings: number;
  avgRelevance: number;
}

interface ProjectStats {
  projectId: string;
  projectName: string;
  queries: number;
  tokensSaved: number;
  costSaved: number;
}

interface TokenPricing {
  inputTokens: number;               // Price per 1k input tokens
  outputTokens: number;              // Price per 1k output tokens
  modelId: string;                   // Which model this applies to
}

interface AnalyticsConfig {
  // Pricing
  pricing: TokenPricing;
  
  // Full context estimation
  estimationMethod: 'measured' | 'heuristic' | 'manual';
  fullContextSize?: number;          // Manual override
  
  // Retention
  retentionDays: number;             // How long to keep detailed logs
  aggregateAfterDays: number;        // When to roll up to daily
  
  // Privacy
  logQueries: boolean;               // Store actual query text
  anonymize: boolean;                // Strip identifying info
}

interface FullContextEstimate {
  projectId: string;
  measuredAt: Date;
  
  // What full context would include
  totalFiles: number;
  totalLines: number;
  totalTokens: number;
  
  // Breakdown
  codeTokens: number;
  docTokens: number;
  configTokens: number;
  
  // Compression scenarios
  withSummaries: number;             // Using file summaries
  withFiltering: number;             // Excluding tests, etc.
  minimal: number;                   // Only entry points
}
```

## Database Schema

```sql
-- Query logs for detailed tracking
CREATE TABLE query_logs (
  id TEXT PRIMARY KEY,
  project_id TEXT NOT NULL,
  session_id TEXT,
  timestamp TEXT NOT NULL,
  
  -- Query details
  query TEXT,                        -- NULL if logQueries=false
  query_type TEXT NOT NULL,
  
  -- Token metrics
  tokens_retrieved INTEGER NOT NULL,
  tokens_estimated_full INTEGER NOT NULL,
  tokens_saved INTEGER GENERATED ALWAYS AS (tokens_estimated_full - tokens_retrieved) STORED,
  
  -- Cost (in cents for precision)
  cost_actual_cents INTEGER,
  cost_estimated_full_cents INTEGER,
  cost_saved_cents INTEGER GENERATED ALWAYS AS (cost_estimated_full_cents - cost_actual_cents) STORED,
  
  -- Quality
  relevance_score REAL,
  item_count INTEGER,
  was_useful INTEGER,                -- NULL, 0, or 1
  
  -- Performance
  latency_ms INTEGER,
  
  -- Details (JSON)
  strategies_json TEXT,
  item_types_json TEXT,
  
  FOREIGN KEY (project_id) REFERENCES projects(id)
);

CREATE INDEX idx_query_logs_project_time ON query_logs(project_id, timestamp DESC);
CREATE INDEX idx_query_logs_session ON query_logs(session_id, timestamp DESC);

-- Aggregated daily stats (for long-term storage)
CREATE TABLE daily_stats (
  project_id TEXT NOT NULL,
  date TEXT NOT NULL,                -- YYYY-MM-DD
  
  queries INTEGER NOT NULL DEFAULT 0,
  tokens_retrieved INTEGER NOT NULL DEFAULT 0,
  tokens_saved INTEGER NOT NULL DEFAULT 0,
  cost_saved_cents INTEGER NOT NULL DEFAULT 0,
  
  avg_relevance REAL,
  useful_count INTEGER DEFAULT 0,
  not_useful_count INTEGER DEFAULT 0,
  
  PRIMARY KEY (project_id, date),
  FOREIGN KEY (project_id) REFERENCES projects(id)
);

-- Full context estimates per project
CREATE TABLE full_context_estimates (
  project_id TEXT PRIMARY KEY,
  measured_at TEXT NOT NULL,
  
  total_files INTEGER NOT NULL,
  total_lines INTEGER NOT NULL,
  total_tokens INTEGER NOT NULL,
  
  code_tokens INTEGER,
  doc_tokens INTEGER,
  config_tokens INTEGER,
  
  with_summaries INTEGER,
  with_filtering INTEGER,
  minimal INTEGER,
  
  FOREIGN KEY (project_id) REFERENCES projects(id)
);
```

## Implementation

### File: `src/analytics/query-logger.ts`

```typescript
import { Database } from '../db/database';
import { generateId } from '../utils/id';
import { estimateTokens } from '../utils/tokens';
import { AnalyticsConfig, QueryLog } from './types';

export class QueryLogger {
  private config: AnalyticsConfig;
  
  constructor(
    private db: Database,
    config: Partial<AnalyticsConfig> = {}
  ) {
    this.config = { ...defaultAnalyticsConfig, ...config };
  }

  /**
   * Log a query with its token metrics
   */
  async logQuery(
    projectId: string,
    query: string,
    result: QueryResult,
    options: LogOptions = {}
  ): Promise<QueryLog> {
    const fullContextEstimate = await this.getFullContextEstimate(projectId);
    
    const log: QueryLog = {
      id: generateId('qlog'),
      projectId,
      sessionId: options.sessionId,
      timestamp: new Date(),
      
      query: this.config.logQueries ? query : undefined,
      queryType: options.queryType || 'context',
      
      // Token calculations
      tokensRetrieved: result.totalTokens,
      tokensEstimatedFull: fullContextEstimate,
      tokensSaved: fullContextEstimate - result.totalTokens,
      
      // Cost calculations
      costActual: this.calculateCost(result.totalTokens),
      costEstimatedFull: this.calculateCost(fullContextEstimate),
      costSaved: this.calculateCost(fullContextEstimate - result.totalTokens),
      
      // Quality
      relevanceScore: result.averageRelevance,
      itemCount: result.items.length,
      
      // Performance
      latencyMs: options.latencyMs || 0,
      
      // Details
      retrievalStrategies: result.strategiesUsed,
      itemTypes: this.countByType(result.items)
    };
    
    await this.persistLog(log);
    
    // Check if we need to aggregate old logs
    await this.maybeAggregateOldLogs(projectId);
    
    return log;
  }

  /**
   * Record user feedback on usefulness
   */
  async recordFeedback(logId: string, wasUseful: boolean): Promise<void> {
    await this.db.run(`
      UPDATE query_logs SET was_useful = ? WHERE id = ?
    `, [wasUseful ? 1 : 0, logId]);
  }

  /**
   * Get usage statistics for a period
   */
  async getStats(
    projectId: string,
    period: 'day' | 'week' | 'month' | 'all' = 'week'
  ): Promise<UsageStats> {
    const { startDate, endDate } = this.getPeriodDates(period);
    
    // Get aggregate stats
    const stats = await this.db.get(`
      SELECT
        COUNT(*) as total_queries,
        SUM(tokens_retrieved) as total_tokens_retrieved,
        SUM(tokens_saved) as total_tokens_saved,
        SUM(tokens_estimated_full) as total_tokens_full,
        SUM(cost_actual_cents) as total_cost_actual,
        SUM(cost_saved_cents) as total_cost_saved,
        AVG(relevance_score) as avg_relevance,
        SUM(CASE WHEN was_useful = 1 THEN 1 ELSE 0 END) as useful_count,
        SUM(CASE WHEN was_useful = 0 THEN 1 ELSE 0 END) as not_useful_count
      FROM query_logs
      WHERE project_id = ?
        AND timestamp >= ?
        AND timestamp <= ?
    `, [projectId, startDate.toISOString(), endDate.toISOString()]);
    
    // Get daily breakdown
    const dailyRows = await this.db.all(`
      SELECT
        DATE(timestamp) as date,
        COUNT(*) as queries,
        SUM(tokens_retrieved) as tokens_retrieved,
        SUM(tokens_saved) as tokens_saved,
        SUM(cost_saved_cents) as cost_saved,
        AVG(relevance_score) as avg_relevance
      FROM query_logs
      WHERE project_id = ?
        AND timestamp >= ?
        AND timestamp <= ?
      GROUP BY DATE(timestamp)
      ORDER BY date
    `, [projectId, startDate.toISOString(), endDate.toISOString()]);
    
    // Get breakdown by query type
    const typeRows = await this.db.all(`
      SELECT
        query_type,
        COUNT(*) as queries,
        AVG(tokens_retrieved) as avg_tokens,
        AVG(tokens_saved) as avg_savings,
        AVG(relevance_score) as avg_relevance
      FROM query_logs
      WHERE project_id = ?
        AND timestamp >= ?
        AND timestamp <= ?
      GROUP BY query_type
    `, [projectId, startDate.toISOString(), endDate.toISOString()]);
    
    const usefulTotal = stats.useful_count + stats.not_useful_count;
    
    return {
      period,
      startDate,
      endDate,
      
      totalQueries: stats.total_queries || 0,
      totalTokensRetrieved: stats.total_tokens_retrieved || 0,
      totalTokensSaved: stats.total_tokens_saved || 0,
      totalTokensEstimatedFull: stats.total_tokens_full || 0,
      
      totalCostActual: (stats.total_cost_actual || 0) / 100,
      totalCostSaved: (stats.total_cost_saved || 0) / 100,
      savingsPercent: stats.total_tokens_full 
        ? ((stats.total_tokens_saved / stats.total_tokens_full) * 100) 
        : 0,
      
      averageRelevance: stats.avg_relevance || 0,
      usefulnessRate: usefulTotal > 0 
        ? (stats.useful_count / usefulTotal) * 100 
        : null,
      
      byDay: dailyRows.map(row => ({
        date: row.date,
        queries: row.queries,
        tokensRetrieved: row.tokens_retrieved,
        tokensSaved: row.tokens_saved,
        costSaved: row.cost_saved / 100,
        avgRelevance: row.avg_relevance
      })),
      
      byQueryType: Object.fromEntries(
        typeRows.map(row => [row.query_type, {
          queryType: row.query_type,
          queries: row.queries,
          avgTokens: Math.round(row.avg_tokens),
          avgSavings: Math.round(row.avg_savings),
          avgRelevance: row.avg_relevance
        }])
      ),
      
      byProject: {} // Populated for cross-project queries
    };
  }

  /**
   * Get recent query logs with details
   */
  async getRecentLogs(
    projectId: string,
    limit: number = 50
  ): Promise<QueryLog[]> {
    const rows = await this.db.all(`
      SELECT * FROM query_logs
      WHERE project_id = ?
      ORDER BY timestamp DESC
      LIMIT ?
    `, [projectId, limit]);
    
    return rows.map(this.rowToLog);
  }

  private async getFullContextEstimate(projectId: string): Promise<number> {
    // Check for measured estimate
    const estimate = await this.db.get(`
      SELECT total_tokens FROM full_context_estimates
      WHERE project_id = ?
    `, [projectId]);
    
    if (estimate) {
      return estimate.total_tokens;
    }
    
    // Fall back to heuristic
    return this.config.fullContextSize || 100000;
  }

  private calculateCost(tokens: number): number {
    return (tokens / 1000) * this.config.pricing.inputTokens;
  }

  private countByType(items: any[]): Record<string, number> {
    const counts: Record<string, number> = {};
    for (const item of items) {
      const type = item.type || 'unknown';
      counts[type] = (counts[type] || 0) + 1;
    }
    return counts;
  }

  private async persistLog(log: QueryLog): Promise<void> {
    await this.db.run(`
      INSERT INTO query_logs (
        id, project_id, session_id, timestamp,
        query, query_type,
        tokens_retrieved, tokens_estimated_full,
        cost_actual_cents, cost_estimated_full_cents,
        relevance_score, item_count, latency_ms,
        strategies_json, item_types_json
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `, [
      log.id,
      log.projectId,
      log.sessionId,
      log.timestamp.toISOString(),
      log.query,
      log.queryType,
      log.tokensRetrieved,
      log.tokensEstimatedFull,
      Math.round(log.costActual * 100),
      Math.round(log.costEstimatedFull * 100),
      log.relevanceScore,
      log.itemCount,
      log.latencyMs,
      JSON.stringify(log.retrievalStrategies),
      JSON.stringify(log.itemTypes)
    ]);
  }

  private async maybeAggregateOldLogs(projectId: string): Promise<void> {
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - this.config.aggregateAfterDays);
    
    // Aggregate old logs into daily stats
    await this.db.run(`
      INSERT OR REPLACE INTO daily_stats (
        project_id, date, queries, tokens_retrieved, tokens_saved,
        cost_saved_cents, avg_relevance, useful_count, not_useful_count
      )
      SELECT
        project_id,
        DATE(timestamp) as date,
        COUNT(*),
        SUM(tokens_retrieved),
        SUM(tokens_saved),
        SUM(cost_saved_cents),
        AVG(relevance_score),
        SUM(CASE WHEN was_useful = 1 THEN 1 ELSE 0 END),
        SUM(CASE WHEN was_useful = 0 THEN 1 ELSE 0 END)
      FROM query_logs
      WHERE project_id = ?
        AND timestamp < ?
      GROUP BY DATE(timestamp)
    `, [projectId, cutoffDate.toISOString()]);
    
    // Delete aggregated logs
    await this.db.run(`
      DELETE FROM query_logs
      WHERE project_id = ? AND timestamp < ?
    `, [projectId, cutoffDate.toISOString()]);
  }

  private getPeriodDates(period: string): { startDate: Date; endDate: Date } {
    const endDate = new Date();
    const startDate = new Date();
    
    switch (period) {
      case 'day':
        startDate.setHours(0, 0, 0, 0);
        break;
      case 'week':
        startDate.setDate(startDate.getDate() - 7);
        break;
      case 'month':
        startDate.setMonth(startDate.getMonth() - 1);
        break;
      case 'all':
        startDate.setFullYear(2020);
        break;
    }
    
    return { startDate, endDate };
  }

  private rowToLog(row: any): QueryLog {
    return {
      id: row.id,
      projectId: row.project_id,
      sessionId: row.session_id,
      timestamp: new Date(row.timestamp),
      query: row.query,
      queryType: row.query_type,
      tokensRetrieved: row.tokens_retrieved,
      tokensEstimatedFull: row.tokens_estimated_full,
      tokensSaved: row.tokens_saved,
      costActual: row.cost_actual_cents / 100,
      costEstimatedFull: row.cost_estimated_full_cents / 100,
      costSaved: row.cost_saved_cents / 100,
      relevanceScore: row.relevance_score,
      itemCount: row.item_count,
      wasUseful: row.was_useful === null ? undefined : row.was_useful === 1,
      latencyMs: row.latency_ms,
      retrievalStrategies: JSON.parse(row.strategies_json || '[]'),
      itemTypes: JSON.parse(row.item_types_json || '{}')
    };
  }
}

const defaultAnalyticsConfig: AnalyticsConfig = {
  pricing: {
    inputTokens: 0.03,   // $0.03 per 1k input tokens (GPT-4 pricing)
    outputTokens: 0.06,
    modelId: 'gpt-4'
  },
  estimationMethod: 'heuristic',
  retentionDays: 90,
  aggregateAfterDays: 7,
  logQueries: true,
  anonymize: false
};
```

### File: `src/analytics/full-context-estimator.ts`

```typescript
import { Database } from '../db/database';
import { estimateTokens } from '../utils/tokens';
import * as fs from 'fs/promises';
import * as path from 'path';

export class FullContextEstimator {
  constructor(private db: Database) {}

  /**
   * Measure the full context size for a project
   */
  async measureProject(projectId: string, projectPath: string): Promise<FullContextEstimate> {
    const stats = {
      totalFiles: 0,
      totalLines: 0,
      totalTokens: 0,
      codeTokens: 0,
      docTokens: 0,
      configTokens: 0
    };
    
    // Walk the project directory
    const files = await this.walkDirectory(projectPath);
    
    for (const file of files) {
      try {
        const content = await fs.readFile(file, 'utf-8');
        const lines = content.split('\n').length;
        const tokens = estimateTokens(content);
        
        stats.totalFiles++;
        stats.totalLines += lines;
        stats.totalTokens += tokens;
        
        // Categorize by file type
        const ext = path.extname(file).toLowerCase();
        if (this.isCodeFile(ext)) {
          stats.codeTokens += tokens;
        } else if (this.isDocFile(ext)) {
          stats.docTokens += tokens;
        } else if (this.isConfigFile(ext, file)) {
          stats.configTokens += tokens;
        }
      } catch (error) {
        // Skip files that can't be read
      }
    }
    
    // Calculate compressed scenarios
    const withSummaries = Math.round(stats.totalTokens * 0.15);  // ~85% reduction with summaries
    const withFiltering = Math.round(stats.totalTokens * 0.40);  // ~60% after filtering tests etc
    const minimal = Math.round(stats.totalTokens * 0.05);        // ~95% reduction, only entry points
    
    const estimate: FullContextEstimate = {
      projectId,
      measuredAt: new Date(),
      totalFiles: stats.totalFiles,
      totalLines: stats.totalLines,
      totalTokens: stats.totalTokens,
      codeTokens: stats.codeTokens,
      docTokens: stats.docTokens,
      configTokens: stats.configTokens,
      withSummaries,
      withFiltering,
      minimal
    };
    
    // Persist estimate
    await this.persistEstimate(estimate);
    
    return estimate;
  }

  /**
   * Get the stored estimate for a project
   */
  async getEstimate(projectId: string): Promise<FullContextEstimate | null> {
    const row = await this.db.get(`
      SELECT * FROM full_context_estimates WHERE project_id = ?
    `, [projectId]);
    
    if (!row) return null;
    
    return {
      projectId: row.project_id,
      measuredAt: new Date(row.measured_at),
      totalFiles: row.total_files,
      totalLines: row.total_lines,
      totalTokens: row.total_tokens,
      codeTokens: row.code_tokens,
      docTokens: row.doc_tokens,
      configTokens: row.config_tokens,
      withSummaries: row.with_summaries,
      withFiltering: row.with_filtering,
      minimal: row.minimal
    };
  }

  private async walkDirectory(dir: string): Promise<string[]> {
    const files: string[] = [];
    const ignoreDirs = new Set(['node_modules', '.git', 'dist', 'build', 'coverage', '__pycache__']);
    
    async function walk(currentDir: string) {
      const entries = await fs.readdir(currentDir, { withFileTypes: true });
      
      for (const entry of entries) {
        const fullPath = path.join(currentDir, entry.name);
        
        if (entry.isDirectory()) {
          if (!ignoreDirs.has(entry.name) && !entry.name.startsWith('.')) {
            await walk(fullPath);
          }
        } else if (entry.isFile()) {
          files.push(fullPath);
        }
      }
    }
    
    await walk(dir);
    return files;
  }

  private isCodeFile(ext: string): boolean {
    const codeExts = new Set(['.ts', '.js', '.tsx', '.jsx', '.py', '.java', '.go', '.rs', '.cpp', '.c', '.h']);
    return codeExts.has(ext);
  }

  private isDocFile(ext: string): boolean {
    const docExts = new Set(['.md', '.txt', '.rst', '.adoc']);
    return docExts.has(ext);
  }

  private isConfigFile(ext: string, filename: string): boolean {
    const configExts = new Set(['.json', '.yaml', '.yml', '.toml', '.ini', '.env']);
    const configNames = new Set(['package.json', 'tsconfig.json', 'webpack.config.js']);
    return configExts.has(ext) || configNames.has(path.basename(filename));
  }

  private async persistEstimate(estimate: FullContextEstimate): Promise<void> {
    await this.db.run(`
      INSERT OR REPLACE INTO full_context_estimates (
        project_id, measured_at, total_files, total_lines, total_tokens,
        code_tokens, doc_tokens, config_tokens,
        with_summaries, with_filtering, minimal
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `, [
      estimate.projectId,
      estimate.measuredAt.toISOString(),
      estimate.totalFiles,
      estimate.totalLines,
      estimate.totalTokens,
      estimate.codeTokens,
      estimate.docTokens,
      estimate.configTokens,
      estimate.withSummaries,
      estimate.withFiltering,
      estimate.minimal
    ]);
  }
}
```

### File: `src/analytics/dashboard.ts`

```typescript
import { QueryLogger } from './query-logger';
import { FullContextEstimator } from './full-context-estimator';

export interface DashboardData {
  summary: SummaryCard;
  savingsChart: ChartData;
  queryTypesChart: ChartData;
  relevanceChart: ChartData;
  recentQueries: RecentQueryItem[];
  projectComparison?: ProjectComparison[];
}

export interface SummaryCard {
  totalQueries: number;
  tokensSaved: string;           // Formatted with K/M suffix
  costSaved: string;             // Formatted as currency
  savingsPercent: number;
  avgRelevance: number;
  trend: 'up' | 'down' | 'stable';
  trendValue: number;
}

export interface ChartData {
  labels: string[];
  datasets: {
    label: string;
    data: number[];
    color?: string;
  }[];
}

export interface RecentQueryItem {
  id: string;
  timestamp: string;
  query: string;
  tokensSaved: number;
  relevance: number;
  wasUseful?: boolean;
}

export class DashboardService {
  constructor(
    private queryLogger: QueryLogger,
    private contextEstimator: FullContextEstimator
  ) {}

  /**
   * Get all dashboard data for rendering
   */
  async getDashboardData(
    projectId: string,
    period: 'day' | 'week' | 'month' = 'week'
  ): Promise<DashboardData> {
    const [currentStats, previousStats, recentLogs] = await Promise.all([
      this.queryLogger.getStats(projectId, period),
      this.queryLogger.getStats(projectId, this.getPreviousPeriod(period)),
      this.queryLogger.getRecentLogs(projectId, 10)
    ]);
    
    // Calculate trend
    const trend = this.calculateTrend(currentStats, previousStats);
    
    return {
      summary: {
        totalQueries: currentStats.totalQueries,
        tokensSaved: this.formatTokens(currentStats.totalTokensSaved),
        costSaved: this.formatCurrency(currentStats.totalCostSaved),
        savingsPercent: Math.round(currentStats.savingsPercent),
        avgRelevance: Math.round(currentStats.averageRelevance * 100) / 100,
        trend: trend.direction,
        trendValue: trend.value
      },
      
      savingsChart: {
        labels: currentStats.byDay.map(d => this.formatDate(d.date)),
        datasets: [
          {
            label: 'Tokens Retrieved',
            data: currentStats.byDay.map(d => d.tokensRetrieved),
            color: '#4CAF50'
          },
          {
            label: 'Tokens Saved',
            data: currentStats.byDay.map(d => d.tokensSaved),
            color: '#2196F3'
          }
        ]
      },
      
      queryTypesChart: {
        labels: Object.keys(currentStats.byQueryType),
        datasets: [{
          label: 'Queries',
          data: Object.values(currentStats.byQueryType).map(t => t.queries)
        }]
      },
      
      relevanceChart: {
        labels: currentStats.byDay.map(d => this.formatDate(d.date)),
        datasets: [{
          label: 'Average Relevance',
          data: currentStats.byDay.map(d => d.avgRelevance * 100),
          color: '#FF9800'
        }]
      },
      
      recentQueries: recentLogs.map(log => ({
        id: log.id,
        timestamp: this.formatTimestamp(log.timestamp),
        query: log.query?.substring(0, 50) || '[query not logged]',
        tokensSaved: log.tokensSaved,
        relevance: Math.round(log.relevanceScore * 100),
        wasUseful: log.wasUseful
      }))
    };
  }

  /**
   * Generate a report for export
   */
  async generateReport(
    projectId: string,
    period: 'week' | 'month'
  ): Promise<AnalyticsReport> {
    const stats = await this.queryLogger.getStats(projectId, period);
    const estimate = await this.contextEstimator.getEstimate(projectId);
    
    return {
      generatedAt: new Date(),
      period,
      projectId,
      
      summary: {
        totalQueries: stats.totalQueries,
        totalTokensSaved: stats.totalTokensSaved,
        totalCostSaved: stats.totalCostSaved,
        savingsPercent: stats.savingsPercent,
        avgRelevance: stats.averageRelevance
      },
      
      comparison: estimate ? {
        fullContextSize: estimate.totalTokens,
        avgRetrievedSize: stats.totalQueries > 0 
          ? stats.totalTokensRetrieved / stats.totalQueries 
          : 0,
        compressionRatio: estimate.totalTokens > 0
          ? (stats.totalTokensRetrieved / stats.totalQueries) / estimate.totalTokens
          : 0
      } : undefined,
      
      dailyBreakdown: stats.byDay,
      queryTypeBreakdown: stats.byQueryType
    };
  }

  private getPreviousPeriod(period: string): 'day' | 'week' | 'month' {
    // Return same period type for comparison
    return period as 'day' | 'week' | 'month';
  }

  private calculateTrend(
    current: UsageStats,
    previous: UsageStats
  ): { direction: 'up' | 'down' | 'stable'; value: number } {
    if (!previous.totalQueries) {
      return { direction: 'stable', value: 0 };
    }
    
    const currentAvgSavings = current.totalQueries > 0 
      ? current.totalTokensSaved / current.totalQueries 
      : 0;
    const previousAvgSavings = previous.totalQueries > 0
      ? previous.totalTokensSaved / previous.totalQueries
      : 0;
    
    const change = previousAvgSavings > 0
      ? ((currentAvgSavings - previousAvgSavings) / previousAvgSavings) * 100
      : 0;
    
    return {
      direction: change > 5 ? 'up' : change < -5 ? 'down' : 'stable',
      value: Math.abs(Math.round(change))
    };
  }

  private formatTokens(tokens: number): string {
    if (tokens >= 1000000) {
      return `${(tokens / 1000000).toFixed(1)}M`;
    }
    if (tokens >= 1000) {
      return `${(tokens / 1000).toFixed(1)}K`;
    }
    return tokens.toString();
  }

  private formatCurrency(amount: number): string {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: 'USD'
    }).format(amount);
  }

  private formatDate(date: string): string {
    return new Date(date).toLocaleDateString('en-US', { weekday: 'short' });
  }

  private formatTimestamp(date: Date): string {
    const now = new Date();
    const diff = now.getTime() - date.getTime();
    const minutes = Math.floor(diff / 60000);
    
    if (minutes < 60) return `${minutes}m ago`;
    if (minutes < 1440) return `${Math.floor(minutes / 60)}h ago`;
    return date.toLocaleDateString();
  }
}
```

## MCP Tools

### Tool: `analytics_get_stats`

```typescript
{
  name: 'analytics_get_stats',
  description: 'Get token usage statistics for a project',
  parameters: {
    projectId: { type: 'string', required: true },
    period: { type: 'string', enum: ['day', 'week', 'month', 'all'], default: 'week' }
  },
  handler: async ({ projectId, period }) => {
    const stats = await queryLogger.getStats(projectId, period);
    return {
      period: stats.period,
      totalQueries: stats.totalQueries,
      tokensSaved: stats.totalTokensSaved,
      tokensSavedFormatted: formatTokens(stats.totalTokensSaved),
      costSaved: stats.totalCostSaved,
      costSavedFormatted: formatCurrency(stats.totalCostSaved),
      savingsPercent: Math.round(stats.savingsPercent),
      averageRelevance: stats.averageRelevance
    };
  }
}
```

### Tool: `analytics_record_feedback`

```typescript
{
  name: 'analytics_record_feedback',
  description: 'Record whether a query result was useful',
  parameters: {
    queryLogId: { type: 'string', required: true },
    wasUseful: { type: 'boolean', required: true }
  },
  handler: async ({ queryLogId, wasUseful }) => {
    await queryLogger.recordFeedback(queryLogId, wasUseful);
    return { success: true };
  }
}
```

### Tool: `analytics_measure_project`

```typescript
{
  name: 'analytics_measure_project',
  description: 'Measure and store full context size for ROI calculation',
  parameters: {
    projectId: { type: 'string', required: true },
    projectPath: { type: 'string', required: true }
  },
  handler: async ({ projectId, projectPath }) => {
    const estimate = await contextEstimator.measureProject(projectId, projectPath);
    return {
      totalFiles: estimate.totalFiles,
      totalLines: estimate.totalLines,
      totalTokens: estimate.totalTokens,
      totalTokensFormatted: formatTokens(estimate.totalTokens),
      breakdown: {
        code: formatTokens(estimate.codeTokens),
        docs: formatTokens(estimate.docTokens),
        config: formatTokens(estimate.configTokens)
      },
      compressionScenarios: {
        withSummaries: formatTokens(estimate.withSummaries),
        withFiltering: formatTokens(estimate.withFiltering),
        minimal: formatTokens(estimate.minimal)
      }
    };
  }
}
```

### Tool: `analytics_get_recent_logs`

```typescript
{
  name: 'analytics_get_recent_logs',
  description: 'Get recent query logs with token details',
  parameters: {
    projectId: { type: 'string', required: true },
    limit: { type: 'number', default: 20, max: 100 }
  },
  handler: async ({ projectId, limit }) => {
    const logs = await queryLogger.getRecentLogs(projectId, limit);
    return {
      logs: logs.map(log => ({
        id: log.id,
        timestamp: log.timestamp.toISOString(),
        queryType: log.queryType,
        tokensRetrieved: log.tokensRetrieved,
        tokensSaved: log.tokensSaved,
        costSaved: log.costSaved.toFixed(4),
        relevanceScore: log.relevanceScore,
        wasUseful: log.wasUseful
      }))
    };
  }
}
```

## Testing

### Unit Tests

```typescript
describe('QueryLogger', () => {
  let logger: QueryLogger;
  let db: Database;
  
  beforeEach(async () => {
    db = await createTestDatabase();
    logger = new QueryLogger(db);
  });
  
  it('should calculate token savings correctly', async () => {
    const log = await logger.logQuery('proj1', 'test query', {
      items: [],
      totalTokens: 5000,
      averageRelevance: 0.8,
      strategiesUsed: ['semantic']
    });
    
    expect(log.tokensRetrieved).toBe(5000);
    expect(log.tokensEstimatedFull).toBe(100000); // Default estimate
    expect(log.tokensSaved).toBe(95000);
  });
  
  it('should calculate cost savings', async () => {
    const log = await logger.logQuery('proj1', 'test query', {
      items: [],
      totalTokens: 5000,
      averageRelevance: 0.8,
      strategiesUsed: []
    });
    
    // At $0.03/1k tokens
    expect(log.costActual).toBeCloseTo(0.15, 2);
    expect(log.costEstimatedFull).toBeCloseTo(3.0, 2);
    expect(log.costSaved).toBeCloseTo(2.85, 2);
  });
  
  it('should aggregate stats by period', async () => {
    // Log several queries
    for (let i = 0; i < 10; i++) {
      await logger.logQuery('proj1', `query ${i}`, {
        items: [],
        totalTokens: 5000 + i * 100,
        averageRelevance: 0.7 + i * 0.02,
        strategiesUsed: []
      });
    }
    
    const stats = await logger.getStats('proj1', 'day');
    
    expect(stats.totalQueries).toBe(10);
    expect(stats.totalTokensRetrieved).toBe(54500); // Sum of 5000+5100+...+5900
  });
  
  it('should record and include feedback', async () => {
    const log = await logger.logQuery('proj1', 'test', {
      items: [], totalTokens: 1000, averageRelevance: 0.5, strategiesUsed: []
    });
    
    await logger.recordFeedback(log.id, true);
    
    const retrieved = (await logger.getRecentLogs('proj1', 1))[0];
    expect(retrieved.wasUseful).toBe(true);
  });
});

describe('FullContextEstimator', () => {
  it('should measure project size', async () => {
    const estimator = new FullContextEstimator(db);
    const estimate = await estimator.measureProject('proj1', '/path/to/project');
    
    expect(estimate.totalFiles).toBeGreaterThan(0);
    expect(estimate.totalTokens).toBeGreaterThan(0);
    expect(estimate.codeTokens + estimate.docTokens + estimate.configTokens)
      .toBeLessThanOrEqual(estimate.totalTokens);
  });
  
  it('should calculate compression scenarios', async () => {
    const estimator = new FullContextEstimator(db);
    const estimate = await estimator.measureProject('proj1', '/path/to/project');
    
    expect(estimate.withSummaries).toBeLessThan(estimate.totalTokens);
    expect(estimate.minimal).toBeLessThan(estimate.withSummaries);
  });
});
```

### Integration Tests

```typescript
describe('Analytics Integration', () => {
  it('should track queries through context_query', async () => {
    // Make a context query
    const result = await mcpClient.callTool('context_query', {
      projectId: 'proj1',
      query: 'How does auth work?'
    });
    
    // Check that it was logged
    const logs = await mcpClient.callTool('analytics_get_recent_logs', {
      projectId: 'proj1',
      limit: 1
    });
    
    expect(logs.logs[0].tokensRetrieved).toBe(result.totalTokens);
  });
  
  it('should provide accurate ROI metrics', async () => {
    // Measure project
    await mcpClient.callTool('analytics_measure_project', {
      projectId: 'proj1',
      projectPath: testProjectPath
    });
    
    // Make queries
    for (let i = 0; i < 5; i++) {
      await mcpClient.callTool('context_query', {
        projectId: 'proj1',
        query: `query ${i}`
      });
    }
    
    // Get stats
    const stats = await mcpClient.callTool('analytics_get_stats', {
      projectId: 'proj1',
      period: 'day'
    });
    
    expect(stats.savingsPercent).toBeGreaterThan(50);
  });
});
```

## Success Metrics

| Metric | Target | Measurement |
|--------|--------|-------------|
| Logging overhead | < 10ms | Time added to queries |
| Storage efficiency | < 1KB/query | Average log size |
| Dashboard load | < 500ms | Time to render stats |
| Accuracy | > 95% | Token count accuracy |
| Adoption | 100% | Queries with analytics |

## Future Enhancements

1. **Team dashboards** - Aggregate stats across team members
2. **Cost forecasting** - Predict future token usage and costs
3. **A/B testing** - Compare different retrieval strategies
4. **Quality correlation** - Relate relevance scores to task success
5. **Model comparisons** - Track performance across different models
6. **Custom pricing** - Support for different model/provider pricing
7. **Alerts** - Notify when usage spikes or quality drops
8. **Export formats** - CSV, PDF, JSON for stakeholder reports
