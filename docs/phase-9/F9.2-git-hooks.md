# F9.2 Git Hooks

**Phase**: 9 - Integrations & Analytics
**Priority**: High
**Dependencies**: F9.1 Token Analytics

## Goal

Automate context synchronization through git hooks, ensuring the index stays current without manual intervention and surfacing relevant historical context during code review workflows.

## Overview

Manual indexing creates friction and staleness. Git hooks eliminate both by:

- Pre-commit: Auto-index changed files before committing
- Post-merge: Sync index when pulling/merging changes
- Pre-push: Validate index is current before pushing
- PR webhook: Surface relevant context for code reviewers
- Impact analysis: Answer "What changed that affects X?"

This transforms ctx-sys from a pull-based tool into a proactive system that maintains itself.

## Architecture

```
┌─────────────────────────────────────────────────────────┐
│                     Git Repository                       │
├─────────────────────────────────────────────────────────┤
│  .git/hooks/                                            │
│  ├── pre-commit           → ctx-sys hook handler        │
│  ├── post-merge           → ctx-sys hook handler        │
│  ├── pre-push             → ctx-sys hook handler        │
│  └── post-checkout        → ctx-sys hook handler        │
└──────────────────┬──────────────────────────────────────┘
                   │
         ┌─────────▼─────────┐
         │  Hook Handler     │
         │  (CLI tool)       │
         └─────────┬─────────┘
                   │
         ┌─────────▼─────────┐
         │  Hook Dispatcher  │
         │  - Parse event    │
         │  - Validate ctx   │
         │  - Route to impl  │
         └─────────┬─────────┘
                   │
    ┌──────────────┼──────────────┐
    │              │              │
┌───▼────┐    ┌───▼────┐    ┌───▼────┐
│ Index  │    │ Sync   │    │ Impact │
│ Files  │    │ Branch │    │ Report │
└───┬────┘    └───┬────┘    └───┬────┘
    │             │             │
    └─────────────┼─────────────┘
                  │
         ┌────────▼────────┐
         │   MCP Client    │
         │   (HTTP/stdio)  │
         └────────┬────────┘
                  │
         ┌────────▼────────┐
         │   ctx-sys       │
         │   MCP Server    │
         └─────────────────┘
```

## Data Model

```typescript
interface HookConfig {
  // Which hooks are enabled
  enablePreCommit: boolean;
  enablePostMerge: boolean;
  enablePrePush: boolean;
  enablePostCheckout: boolean;

  // Behavior settings
  indexOnCommit: boolean;           // Auto-index changed files
  syncOnMerge: boolean;             // Sync index after merge
  validateOnPush: boolean;          // Check index freshness before push
  generateImpactReport: boolean;    // Create impact analysis on merge

  // Performance tuning
  maxFilesToIndex: number;          // Skip if too many changed files
  timeoutMs: number;                // Max time for hook execution
  asyncMode: boolean;               // Run indexing in background

  // Integration
  serverUrl: string;                // ctx-sys MCP server
  projectId: string;                // Which project to update

  // Reporting
  verbosity: 'silent' | 'normal' | 'verbose';
  notifyOnError: boolean;
  logPath?: string;
}

interface HookEvent {
  type: 'pre-commit' | 'post-merge' | 'pre-push' | 'post-checkout';
  timestamp: Date;

  // Git context
  repository: string;
  currentBranch: string;
  currentCommit: string;
  previousCommit?: string;         // For post-merge, post-checkout

  // Changed files
  stagedFiles?: string[];          // For pre-commit
  mergedFiles?: string[];          // For post-merge

  // Remote info
  remoteName?: string;             // For pre-push
  remoteUrl?: string;
}

interface HookResult {
  success: boolean;
  duration: number;                 // Milliseconds

  // What was done
  filesIndexed: number;
  entitiesUpdated: number;
  decisionsLinked: number;

  // Output for user
  message?: string;
  warnings?: string[];
  errors?: string[];

  // Impact analysis (if generated)
  impactReport?: ImpactReport;
}

interface ImpactReport {
  generatedAt: Date;
  baseBranch: string;
  targetBranch: string;

  // Changed files summary
  filesAdded: string[];
  filesModified: string[];
  filesDeleted: string[];

  // Impact analysis
  affectedEntities: AffectedEntity[];
  affectedDecisions: AffectedDecision[];
  relatedContexts: RelatedContext[];

  // Risk indicators
  riskLevel: 'low' | 'medium' | 'high';
  reasons: string[];

  // Recommendations
  suggestions: string[];
}

interface AffectedEntity {
  entityId: string;
  name: string;
  type: 'function' | 'class' | 'interface' | 'module';
  filePath: string;
  changeType: 'modified' | 'deleted' | 'signature-changed';
  usageCount: number;              // How many places reference it
}

interface AffectedDecision {
  decisionId: string;
  summary: string;
  relatedFiles: string[];          // Which changed files are mentioned
  mightBeInvalidated: boolean;     // Decision may no longer hold
}

interface RelatedContext {
  title: string;
  summary: string;
  relevanceScore: number;
  filePaths: string[];
}

interface WebhookConfig {
  // GitHub/GitLab/etc. webhook settings
  enabled: boolean;
  secret: string;                   // Webhook verification secret
  listenPort: number;

  // Events to handle
  handlePullRequest: boolean;
  handlePush: boolean;
  handleRelease: boolean;

  // What to do
  commentOnPR: boolean;             // Post impact report as PR comment
  updateStatus: boolean;            // Set commit status check
  notifySlack?: string;             // Slack webhook URL
}

interface PRContextComment {
  prNumber: number;
  repository: string;

  // Context to surface
  relevantDecisions: Decision[];
  affectedEntities: AffectedEntity[];
  relatedHistory: ChangeItem[];

  // Formatted comment body
  commentBody: string;
}
```

## Database Schema

```sql
-- Track hook executions for debugging
CREATE TABLE hook_executions (
  id TEXT PRIMARY KEY,
  project_id TEXT NOT NULL,
  hook_type TEXT NOT NULL,         -- 'pre-commit', 'post-merge', etc.
  timestamp TEXT NOT NULL,

  -- Git context
  repository TEXT NOT NULL,
  branch TEXT NOT NULL,
  commit_hash TEXT,

  -- Execution details
  duration_ms INTEGER,
  success INTEGER NOT NULL,        -- 0 or 1
  files_indexed INTEGER DEFAULT 0,
  entities_updated INTEGER DEFAULT 0,

  -- Results
  message TEXT,
  warnings_json TEXT,              -- JSON array
  errors_json TEXT,                -- JSON array

  FOREIGN KEY (project_id) REFERENCES projects(id)
);

CREATE INDEX idx_hook_executions_project ON hook_executions(project_id, timestamp DESC);
CREATE INDEX idx_hook_executions_type ON hook_executions(hook_type, success);

-- Store impact reports for PR reviews
CREATE TABLE impact_reports (
  id TEXT PRIMARY KEY,
  project_id TEXT NOT NULL,
  generated_at TEXT NOT NULL,

  -- Git context
  base_branch TEXT NOT NULL,
  target_branch TEXT NOT NULL,
  commit_range TEXT,

  -- Summary counts
  files_added INTEGER DEFAULT 0,
  files_modified INTEGER DEFAULT 0,
  files_deleted INTEGER DEFAULT 0,
  affected_entities INTEGER DEFAULT 0,
  affected_decisions INTEGER DEFAULT 0,

  -- Risk assessment
  risk_level TEXT,                 -- 'low', 'medium', 'high'
  reasons_json TEXT,               -- JSON array

  -- Full report (JSON)
  report_json TEXT NOT NULL,

  FOREIGN KEY (project_id) REFERENCES projects(id)
);

CREATE INDEX idx_impact_reports_project ON impact_reports(project_id, generated_at DESC);

-- Track which files have been indexed from which commits
CREATE TABLE indexed_commits (
  project_id TEXT NOT NULL,
  commit_hash TEXT NOT NULL,
  indexed_at TEXT NOT NULL,
  file_count INTEGER NOT NULL,

  PRIMARY KEY (project_id, commit_hash),
  FOREIGN KEY (project_id) REFERENCES projects(id)
);
```

## Implementation

### File: `src/hooks/hook-installer.ts`

```typescript
import * as fs from 'fs/promises';
import * as path from 'path';
import { execSync } from 'child_process';

export class HookInstaller {
  /**
   * Install ctx-sys hooks into a git repository
   */
  async install(
    repoPath: string,
    config: Partial<HookConfig> = {}
  ): Promise<InstallResult> {
    const hooksDir = path.join(repoPath, '.git', 'hooks');

    // Verify this is a git repository
    try {
      await fs.access(hooksDir);
    } catch {
      throw new Error('Not a git repository');
    }

    const hookConfig: HookConfig = { ...defaultHookConfig, ...config };
    const installed: string[] = [];

    // Install enabled hooks
    if (hookConfig.enablePreCommit) {
      await this.installHook(hooksDir, 'pre-commit', hookConfig);
      installed.push('pre-commit');
    }

    if (hookConfig.enablePostMerge) {
      await this.installHook(hooksDir, 'post-merge', hookConfig);
      installed.push('post-merge');
    }

    if (hookConfig.enablePrePush) {
      await this.installHook(hooksDir, 'pre-push', hookConfig);
      installed.push('pre-push');
    }

    if (hookConfig.enablePostCheckout) {
      await this.installHook(hooksDir, 'post-checkout', hookConfig);
      installed.push('post-checkout');
    }

    // Save config
    const configPath = path.join(repoPath, '.ctx-sys', 'hooks.json');
    await fs.mkdir(path.dirname(configPath), { recursive: true });
    await fs.writeFile(configPath, JSON.stringify(hookConfig, null, 2));

    return {
      success: true,
      installed,
      configPath
    };
  }

  /**
   * Uninstall ctx-sys hooks
   */
  async uninstall(repoPath: string): Promise<void> {
    const hooksDir = path.join(repoPath, '.git', 'hooks');
    const hookNames = ['pre-commit', 'post-merge', 'pre-push', 'post-checkout'];

    for (const hookName of hookNames) {
      const hookPath = path.join(hooksDir, hookName);

      try {
        const content = await fs.readFile(hookPath, 'utf-8');

        // Only remove if it's our hook
        if (content.includes('ctx-sys-hook')) {
          await fs.unlink(hookPath);
        }
      } catch {
        // Hook doesn't exist, continue
      }
    }
  }

  private async installHook(
    hooksDir: string,
    hookName: string,
    config: HookConfig
  ): Promise<void> {
    const hookPath = path.join(hooksDir, hookName);

    // Check if hook already exists
    try {
      await fs.access(hookPath);

      // Back it up
      const backupPath = `${hookPath}.pre-ctx-sys`;
      await fs.copyFile(hookPath, backupPath);
    } catch {
      // No existing hook, that's fine
    }

    // Write our hook
    const hookContent = this.generateHookScript(hookName, config);
    await fs.writeFile(hookPath, hookContent);
    await fs.chmod(hookPath, 0o755);
  }

  private generateHookScript(hookName: string, config: HookConfig): string {
    // Generate shell script that calls our hook handler
    return `#!/bin/bash
# ctx-sys-hook: ${hookName}
# Auto-generated by ctx-sys. Do not edit manually.

# Configuration
CTX_SYS_SERVER="${config.serverUrl}"
CTX_SYS_PROJECT="${config.projectId}"
CTX_SYS_TIMEOUT="${config.timeoutMs}"
CTX_SYS_VERBOSE="${config.verbosity}"

# Find ctx-sys hook handler
if command -v ctx-sys-hook &> /dev/null; then
  HOOK_HANDLER="ctx-sys-hook"
elif [ -f "./node_modules/.bin/ctx-sys-hook" ]; then
  HOOK_HANDLER="./node_modules/.bin/ctx-sys-hook"
else
  echo "Warning: ctx-sys-hook not found, skipping" >&2
  exit 0
fi

# Execute hook with timeout
if [ "${config.asyncMode}" = "true" ]; then
  # Run in background, don't block git operation
  $HOOK_HANDLER ${hookName} "$@" &>/dev/null &
  exit 0
else
  # Run synchronously
  timeout ${config.timeoutMs}ms $HOOK_HANDLER ${hookName} "$@"
  exit_code=$?

  if [ $exit_code -eq 124 ]; then
    echo "Warning: ctx-sys hook timed out" >&2
    exit 0  # Don't block git operation on timeout
  fi

  exit $exit_code
fi
`;
  }
}

const defaultHookConfig: HookConfig = {
  enablePreCommit: true,
  enablePostMerge: true,
  enablePrePush: false,
  enablePostCheckout: false,

  indexOnCommit: true,
  syncOnMerge: true,
  validateOnPush: false,
  generateImpactReport: true,

  maxFilesToIndex: 100,
  timeoutMs: 10000,
  asyncMode: false,

  serverUrl: 'http://localhost:3000',
  projectId: '',

  verbosity: 'normal',
  notifyOnError: true
};
```

### File: `src/hooks/hook-handler.ts`

```typescript
import { HookEvent, HookResult, HookConfig } from './types';
import { MCPClient } from '../mcp/client';
import { ImpactAnalyzer } from './impact-analyzer';
import { execSync } from 'child_process';
import * as path from 'path';
import * as fs from 'fs/promises';

export class HookHandler {
  private config: HookConfig;
  private mcpClient: MCPClient;
  private impactAnalyzer: ImpactAnalyzer;

  constructor(config: HookConfig) {
    this.config = config;
    this.mcpClient = new MCPClient({ serverUrl: config.serverUrl });
    this.impactAnalyzer = new ImpactAnalyzer(this.mcpClient);
  }

  /**
   * Handle a git hook event
   */
  async handle(event: HookEvent): Promise<HookResult> {
    const startTime = Date.now();

    try {
      this.log('verbose', `Handling ${event.type} hook`);

      let result: Partial<HookResult>;

      switch (event.type) {
        case 'pre-commit':
          result = await this.handlePreCommit(event);
          break;
        case 'post-merge':
          result = await this.handlePostMerge(event);
          break;
        case 'pre-push':
          result = await this.handlePrePush(event);
          break;
        case 'post-checkout':
          result = await this.handlePostCheckout(event);
          break;
        default:
          throw new Error(`Unknown hook type: ${event.type}`);
      }

      const duration = Date.now() - startTime;

      // Log execution
      await this.logExecution(event, { ...result, success: true, duration });

      return {
        success: true,
        duration,
        filesIndexed: result.filesIndexed || 0,
        entitiesUpdated: result.entitiesUpdated || 0,
        decisionsLinked: result.decisionsLinked || 0,
        message: result.message,
        warnings: result.warnings,
        errors: result.errors,
        impactReport: result.impactReport
      };
    } catch (error) {
      const duration = Date.now() - startTime;
      const errorMsg = error instanceof Error ? error.message : 'Unknown error';

      this.log('normal', `Hook failed: ${errorMsg}`);

      await this.logExecution(event, {
        success: false,
        duration,
        errors: [errorMsg]
      });

      return {
        success: false,
        duration,
        filesIndexed: 0,
        entitiesUpdated: 0,
        decisionsLinked: 0,
        errors: [errorMsg]
      };
    }
  }

  private async handlePreCommit(event: HookEvent): Promise<Partial<HookResult>> {
    if (!this.config.indexOnCommit) {
      return { message: 'Indexing on commit disabled' };
    }

    // Get staged files
    const stagedFiles = this.getStagedFiles(event.repository);

    if (stagedFiles.length === 0) {
      return { message: 'No files to index' };
    }

    if (stagedFiles.length > this.config.maxFilesToIndex) {
      return {
        message: `Too many files (${stagedFiles.length}), skipping auto-index`,
        warnings: ['Consider manually running ctx-sys index after commit']
      };
    }

    this.log('normal', `Indexing ${stagedFiles.length} staged files...`);

    // Index files via MCP
    const result = await this.mcpClient.callTool('index_files', {
      projectId: this.config.projectId,
      filePaths: stagedFiles
    });

    return {
      filesIndexed: result.filesIndexed,
      entitiesUpdated: result.entitiesExtracted,
      message: `Indexed ${result.filesIndexed} files`
    };
  }

  private async handlePostMerge(event: HookEvent): Promise<Partial<HookResult>> {
    const tasks: Promise<any>[] = [];
    const results: Partial<HookResult> = {
      warnings: [],
      errors: []
    };

    // 1. Sync index if enabled
    if (this.config.syncOnMerge) {
      this.log('normal', 'Syncing index after merge...');

      tasks.push(
        this.syncMergedFiles(event)
          .then(syncResult => {
            results.filesIndexed = syncResult.filesIndexed;
            results.entitiesUpdated = syncResult.entitiesUpdated;
          })
          .catch(err => {
            results.warnings?.push(`Index sync failed: ${err.message}`);
          })
      );
    }

    // 2. Generate impact report if enabled
    if (this.config.generateImpactReport) {
      this.log('normal', 'Generating impact report...');

      tasks.push(
        this.impactAnalyzer.analyze({
          projectId: this.config.projectId,
          baseBranch: this.detectBaseBranch(event.repository),
          targetBranch: event.currentBranch,
          previousCommit: event.previousCommit,
          currentCommit: event.currentCommit
        })
          .then(report => {
            results.impactReport = report;

            // Display summary
            this.displayImpactSummary(report);
          })
          .catch(err => {
            results.warnings?.push(`Impact analysis failed: ${err.message}`);
          })
      );
    }

    await Promise.all(tasks);

    return results;
  }

  private async handlePrePush(event: HookEvent): Promise<Partial<HookResult>> {
    if (!this.config.validateOnPush) {
      return { message: 'Push validation disabled' };
    }

    // Check if index is up to date
    const status = await this.mcpClient.callTool('index_status', {
      projectId: this.config.projectId
    });

    if (!status.isUpToDate) {
      return {
        success: false,
        errors: [
          'Index is out of date. Run `ctx-sys index` before pushing.',
          `Unindexed files: ${status.unindexedCount}`
        ]
      };
    }

    return {
      message: 'Index is up to date'
    };
  }

  private async handlePostCheckout(event: HookEvent): Promise<Partial<HookResult>> {
    // Check if we switched branches (not just checked out a file)
    if (!event.previousCommit || event.previousCommit === event.currentCommit) {
      return { message: 'File checkout, skipping' };
    }

    this.log('normal', `Switched from ${event.previousCommit} to ${event.currentCommit}`);

    // Optionally re-index if many files changed
    const changedFiles = this.getChangedFiles(
      event.repository,
      event.previousCommit,
      event.currentCommit
    );

    if (changedFiles.length > 10) {
      this.log('normal', `${changedFiles.length} files changed, consider re-indexing`);
      return {
        warnings: [`Branch has ${changedFiles.length} changes, run ctx-sys index to update`]
      };
    }

    return { message: 'Branch switched' };
  }

  private async syncMergedFiles(event: HookEvent): Promise<{ filesIndexed: number; entitiesUpdated: number }> {
    const mergedFiles = event.mergedFiles || this.getMergedFiles(event.repository);

    if (mergedFiles.length === 0) {
      return { filesIndexed: 0, entitiesUpdated: 0 };
    }

    const result = await this.mcpClient.callTool('index_files', {
      projectId: this.config.projectId,
      filePaths: mergedFiles
    });

    return {
      filesIndexed: result.filesIndexed,
      entitiesUpdated: result.entitiesExtracted
    };
  }

  private getStagedFiles(repoPath: string): string[] {
    try {
      const output = execSync('git diff --cached --name-only', {
        cwd: repoPath,
        encoding: 'utf-8'
      });

      return output.trim().split('\n').filter(Boolean);
    } catch {
      return [];
    }
  }

  private getMergedFiles(repoPath: string): string[] {
    try {
      // Get files changed in the last merge
      const output = execSync('git diff --name-only HEAD@{1} HEAD', {
        cwd: repoPath,
        encoding: 'utf-8'
      });

      return output.trim().split('\n').filter(Boolean);
    } catch {
      return [];
    }
  }

  private getChangedFiles(repoPath: string, from: string, to: string): string[] {
    try {
      const output = execSync(`git diff --name-only ${from} ${to}`, {
        cwd: repoPath,
        encoding: 'utf-8'
      });

      return output.trim().split('\n').filter(Boolean);
    } catch {
      return [];
    }
  }

  private detectBaseBranch(repoPath: string): string {
    try {
      // Try to detect the main branch name
      const branches = execSync('git branch -r', {
        cwd: repoPath,
        encoding: 'utf-8'
      });

      if (branches.includes('origin/main')) return 'main';
      if (branches.includes('origin/master')) return 'master';
      return 'main';
    } catch {
      return 'main';
    }
  }

  private displayImpactSummary(report: ImpactReport): void {
    if (this.config.verbosity === 'silent') return;

    console.log('\n=== Impact Analysis ===');
    console.log(`Risk Level: ${report.riskLevel.toUpperCase()}`);
    console.log(`Files: +${report.filesAdded.length} ~${report.filesModified.length} -${report.filesDeleted.length}`);
    console.log(`Affected: ${report.affectedEntities.length} entities, ${report.affectedDecisions.length} decisions`);

    if (report.suggestions.length > 0) {
      console.log('\nRecommendations:');
      report.suggestions.forEach(s => console.log(`  - ${s}`));
    }

    console.log('');
  }

  private async logExecution(event: HookEvent, result: Partial<HookResult>): Promise<void> {
    try {
      await this.mcpClient.callTool('log_hook_execution', {
        projectId: this.config.projectId,
        hookType: event.type,
        repository: event.repository,
        branch: event.currentBranch,
        commitHash: event.currentCommit,
        duration: result.duration,
        success: result.success,
        filesIndexed: result.filesIndexed || 0,
        entitiesUpdated: result.entitiesUpdated || 0,
        message: result.message,
        warnings: result.warnings,
        errors: result.errors
      });
    } catch (error) {
      // Don't fail hook if logging fails
      this.log('verbose', `Failed to log execution: ${error}`);
    }
  }

  private log(level: 'silent' | 'normal' | 'verbose', message: string): void {
    const levels = { silent: 0, normal: 1, verbose: 2 };
    const configLevel = levels[this.config.verbosity];
    const messageLevel = levels[level];

    if (messageLevel <= configLevel) {
      console.error(`ctx-sys: ${message}`);
    }
  }
}
```

### File: `src/hooks/impact-analyzer.ts`

```typescript
import { MCPClient } from '../mcp/client';
import { ImpactReport, AffectedEntity, AffectedDecision } from './types';
import { execSync } from 'child_process';

export class ImpactAnalyzer {
  constructor(private mcpClient: MCPClient) {}

  /**
   * Analyze the impact of changes between commits/branches
   */
  async analyze(options: {
    projectId: string;
    baseBranch: string;
    targetBranch: string;
    previousCommit?: string;
    currentCommit?: string;
  }): Promise<ImpactReport> {
    const { projectId, baseBranch, targetBranch, previousCommit, currentCommit } = options;

    // Get changed files
    const changedFiles = await this.getChangedFiles(baseBranch, targetBranch);

    // Analyze each category
    const [affectedEntities, affectedDecisions, relatedContexts] = await Promise.all([
      this.findAffectedEntities(projectId, changedFiles),
      this.findAffectedDecisions(projectId, changedFiles),
      this.findRelatedContexts(projectId, changedFiles)
    ]);

    // Calculate risk level
    const { riskLevel, reasons } = this.assessRisk(
      changedFiles,
      affectedEntities,
      affectedDecisions
    );

    // Generate suggestions
    const suggestions = this.generateSuggestions(
      changedFiles,
      affectedEntities,
      affectedDecisions
    );

    return {
      generatedAt: new Date(),
      baseBranch,
      targetBranch,

      filesAdded: changedFiles.added,
      filesModified: changedFiles.modified,
      filesDeleted: changedFiles.deleted,

      affectedEntities,
      affectedDecisions,
      relatedContexts,

      riskLevel,
      reasons,
      suggestions
    };
  }

  private async getChangedFiles(
    base: string,
    target: string
  ): Promise<{ added: string[]; modified: string[]; deleted: string[] }> {
    try {
      const output = execSync(`git diff --name-status ${base}...${target}`, {
        encoding: 'utf-8'
      });

      const added: string[] = [];
      const modified: string[] = [];
      const deleted: string[] = [];

      for (const line of output.trim().split('\n')) {
        if (!line) continue;

        const [status, file] = line.split('\t');

        if (status === 'A') added.push(file);
        else if (status === 'M') modified.push(file);
        else if (status === 'D') deleted.push(file);
      }

      return { added, modified, deleted };
    } catch {
      return { added: [], modified: [], deleted: [] };
    }
  }

  private async findAffectedEntities(
    projectId: string,
    changedFiles: { added: string[]; modified: string[]; deleted: string[] }
  ): Promise<AffectedEntity[]> {
    const affected: AffectedEntity[] = [];

    // Check modified and deleted files for entities
    const filesToCheck = [...changedFiles.modified, ...changedFiles.deleted];

    for (const filePath of filesToCheck) {
      // Query entities in this file
      const result = await this.mcpClient.callTool('entity_search', {
        projectId,
        filters: { filePath }
      });

      for (const entity of result.entities) {
        // Check usage count
        const usageResult = await this.mcpClient.callTool('entity_references', {
          projectId,
          entityId: entity.id
        });

        affected.push({
          entityId: entity.id,
          name: entity.name,
          type: entity.type,
          filePath: entity.filePath,
          changeType: changedFiles.deleted.includes(filePath) ? 'deleted' : 'modified',
          usageCount: usageResult.references.length
        });
      }
    }

    return affected;
  }

  private async findAffectedDecisions(
    projectId: string,
    changedFiles: { added: string[]; modified: string[]; deleted: string[] }
  ): Promise<AffectedDecision[]> {
    const affected: AffectedDecision[] = [];
    const allChangedFiles = [
      ...changedFiles.added,
      ...changedFiles.modified,
      ...changedFiles.deleted
    ];

    // Search for decisions mentioning these files
    for (const filePath of allChangedFiles) {
      const fileName = filePath.split('/').pop() || '';

      const result = await this.mcpClient.callTool('decision_search', {
        projectId,
        query: fileName,
        limit: 5
      });

      for (const decision of result.decisions) {
        // Check if decision text mentions this file
        if (decision.decision.includes(fileName) || decision.decision.includes(filePath)) {
          affected.push({
            decisionId: decision.id,
            summary: decision.decision.substring(0, 100),
            relatedFiles: [filePath],
            mightBeInvalidated: changedFiles.deleted.includes(filePath)
          });
        }
      }
    }

    return affected;
  }

  private async findRelatedContexts(
    projectId: string,
    changedFiles: { added: string[]; modified: string[]; deleted: string[] }
  ): Promise<any[]> {
    // Build a query from changed files
    const fileNames = [...changedFiles.added, ...changedFiles.modified]
      .map(f => f.split('/').pop())
      .filter(Boolean)
      .slice(0, 5);

    if (fileNames.length === 0) return [];

    const query = `code related to ${fileNames.join(', ')}`;

    const result = await this.mcpClient.callTool('context_query', {
      projectId,
      query,
      maxTokens: 2000
    });

    return result.items.slice(0, 5);
  }

  private assessRisk(
    changedFiles: any,
    affectedEntities: AffectedEntity[],
    affectedDecisions: AffectedDecision[]
  ): { riskLevel: 'low' | 'medium' | 'high'; reasons: string[] } {
    const reasons: string[] = [];
    let score = 0;

    // Deleted files increase risk
    if (changedFiles.deleted.length > 0) {
      score += changedFiles.deleted.length * 2;
      reasons.push(`${changedFiles.deleted.length} files deleted`);
    }

    // Many modified files increase risk
    if (changedFiles.modified.length > 10) {
      score += Math.floor(changedFiles.modified.length / 5);
      reasons.push(`${changedFiles.modified.length} files modified`);
    }

    // Widely-used entities increase risk
    const highUsageEntities = affectedEntities.filter(e => e.usageCount > 5);
    if (highUsageEntities.length > 0) {
      score += highUsageEntities.length * 3;
      reasons.push(`${highUsageEntities.length} widely-used entities affected`);
    }

    // Decisions that might be invalidated
    const invalidatedDecisions = affectedDecisions.filter(d => d.mightBeInvalidated);
    if (invalidatedDecisions.length > 0) {
      score += invalidatedDecisions.length * 2;
      reasons.push(`${invalidatedDecisions.length} decisions may be invalidated`);
    }

    // Calculate level
    let riskLevel: 'low' | 'medium' | 'high';
    if (score >= 10) riskLevel = 'high';
    else if (score >= 5) riskLevel = 'medium';
    else riskLevel = 'low';

    return { riskLevel, reasons };
  }

  private generateSuggestions(
    changedFiles: any,
    affectedEntities: AffectedEntity[],
    affectedDecisions: AffectedDecision[]
  ): string[] {
    const suggestions: string[] = [];

    // High-usage entities
    const criticalEntities = affectedEntities.filter(e => e.usageCount > 10);
    if (criticalEntities.length > 0) {
      suggestions.push(
        `Review usage of ${criticalEntities.map(e => e.name).join(', ')} (${criticalEntities.length} widely-used entities)`
      );
    }

    // Deleted entities
    const deletedEntities = affectedEntities.filter(e => e.changeType === 'deleted');
    if (deletedEntities.length > 0) {
      suggestions.push(
        `Verify ${deletedEntities.length} deleted entities are no longer referenced`
      );
    }

    // Invalidated decisions
    if (affectedDecisions.some(d => d.mightBeInvalidated)) {
      suggestions.push('Review decisions that may no longer apply');
    }

    // Large changesets
    const totalChanged = changedFiles.added.length +
                        changedFiles.modified.length +
                        changedFiles.deleted.length;
    if (totalChanged > 20) {
      suggestions.push('Consider splitting this large change into smaller PRs');
    }

    return suggestions;
  }
}
```

## MCP Tools

### Tool: `hooks_install`

```typescript
{
  name: 'hooks_install',
  description: 'Install ctx-sys git hooks in a repository',
  parameters: {
    projectId: { type: 'string', required: true },
    repositoryPath: { type: 'string', required: true },
    config: { type: 'object', required: false }
  },
  handler: async ({ projectId, repositoryPath, config }) => {
    const installer = new HookInstaller();
    const result = await installer.install(repositoryPath, {
      ...config,
      projectId
    });

    return {
      success: result.success,
      installed: result.installed,
      configPath: result.configPath,
      message: `Installed ${result.installed.length} hooks`
    };
  }
}
```

### Tool: `hooks_uninstall`

```typescript
{
  name: 'hooks_uninstall',
  description: 'Uninstall ctx-sys git hooks from a repository',
  parameters: {
    repositoryPath: { type: 'string', required: true }
  },
  handler: async ({ repositoryPath }) => {
    const installer = new HookInstaller();
    await installer.uninstall(repositoryPath);

    return {
      success: true,
      message: 'Hooks uninstalled successfully'
    };
  }
}
```

### Tool: `hooks_generate_impact_report`

```typescript
{
  name: 'hooks_generate_impact_report',
  description: 'Generate an impact analysis report for changes between branches',
  parameters: {
    projectId: { type: 'string', required: true },
    baseBranch: { type: 'string', default: 'main' },
    targetBranch: { type: 'string', default: 'HEAD' }
  },
  handler: async ({ projectId, baseBranch, targetBranch }) => {
    const analyzer = new ImpactAnalyzer(mcpClient);
    const report = await analyzer.analyze({
      projectId,
      baseBranch,
      targetBranch
    });

    return {
      generatedAt: report.generatedAt.toISOString(),
      riskLevel: report.riskLevel,
      summary: {
        filesChanged: report.filesAdded.length +
                     report.filesModified.length +
                     report.filesDeleted.length,
        entitiesAffected: report.affectedEntities.length,
        decisionsAffected: report.affectedDecisions.length
      },
      risks: report.reasons,
      suggestions: report.suggestions,
      details: {
        filesAdded: report.filesAdded,
        filesModified: report.filesModified,
        filesDeleted: report.filesDeleted,
        affectedEntities: report.affectedEntities.slice(0, 10),
        affectedDecisions: report.affectedDecisions.slice(0, 5)
      }
    };
  }
}
```

### Tool: `hooks_get_execution_history`

```typescript
{
  name: 'hooks_get_execution_history',
  description: 'Get recent git hook execution logs',
  parameters: {
    projectId: { type: 'string', required: true },
    hookType: { type: 'string', required: false },
    limit: { type: 'number', default: 20, max: 100 }
  },
  handler: async ({ projectId, hookType, limit }) => {
    const db = getDatabase();

    let query = `
      SELECT * FROM hook_executions
      WHERE project_id = ?
    `;
    const params = [projectId];

    if (hookType) {
      query += ` AND hook_type = ?`;
      params.push(hookType);
    }

    query += ` ORDER BY timestamp DESC LIMIT ?`;
    params.push(limit);

    const rows = await db.all(query, params);

    return {
      executions: rows.map(row => ({
        id: row.id,
        hookType: row.hook_type,
        timestamp: row.timestamp,
        branch: row.branch,
        commitHash: row.commit_hash,
        duration: row.duration_ms,
        success: row.success === 1,
        filesIndexed: row.files_indexed,
        entitiesUpdated: row.entities_updated,
        message: row.message,
        warnings: JSON.parse(row.warnings_json || '[]'),
        errors: JSON.parse(row.errors_json || '[]')
      }))
    };
  }
}
```

## CLI Integration

### Command: `ctx-sys hooks install`

```bash
# Install hooks with defaults
ctx-sys hooks install

# Install with custom config
ctx-sys hooks install --async --no-impact-reports

# Install in a different repository
ctx-sys hooks install --repo /path/to/repo
```

### Command: `ctx-sys hooks uninstall`

```bash
ctx-sys hooks uninstall
```

### Command: `ctx-sys hooks impact`

```bash
# Generate impact report for current branch vs main
ctx-sys hooks impact

# Compare specific branches
ctx-sys hooks impact --base main --target feature/new-auth

# Output as JSON
ctx-sys hooks impact --json > impact.json
```

## Testing

### Unit Tests

```typescript
describe('HookInstaller', () => {
  let installer: HookInstaller;
  let tempRepo: string;

  beforeEach(async () => {
    installer = new HookInstaller();
    tempRepo = await createTempGitRepo();
  });

  afterEach(async () => {
    await fs.rm(tempRepo, { recursive: true });
  });

  it('should install hooks successfully', async () => {
    const result = await installer.install(tempRepo, {
      enablePreCommit: true,
      enablePostMerge: true
    });

    expect(result.success).toBe(true);
    expect(result.installed).toContain('pre-commit');
    expect(result.installed).toContain('post-merge');

    // Verify hooks are executable
    const hookPath = path.join(tempRepo, '.git', 'hooks', 'pre-commit');
    const stats = await fs.stat(hookPath);
    expect(stats.mode & 0o111).toBeTruthy();
  });

  it('should backup existing hooks', async () => {
    const hookPath = path.join(tempRepo, '.git', 'hooks', 'pre-commit');
    await fs.writeFile(hookPath, '#!/bin/bash\necho "existing hook"');

    await installer.install(tempRepo);

    const backupPath = `${hookPath}.pre-ctx-sys`;
    const backup = await fs.readFile(backupPath, 'utf-8');
    expect(backup).toContain('existing hook');
  });

  it('should uninstall cleanly', async () => {
    await installer.install(tempRepo);
    await installer.uninstall(tempRepo);

    const hookPath = path.join(tempRepo, '.git', 'hooks', 'pre-commit');
    await expect(fs.access(hookPath)).rejects.toThrow();
  });
});

describe('ImpactAnalyzer', () => {
  let analyzer: ImpactAnalyzer;
  let mockMcpClient: jest.Mocked<MCPClient>;

  beforeEach(() => {
    mockMcpClient = {
      callTool: jest.fn()
    } as any;

    analyzer = new ImpactAnalyzer(mockMcpClient);
  });

  it('should detect affected entities', async () => {
    mockMcpClient.callTool
      .mockResolvedValueOnce({
        entities: [
          { id: 'e1', name: 'UserService', type: 'class', filePath: 'src/user.ts' }
        ]
      })
      .mockResolvedValueOnce({
        references: Array(15).fill({ filePath: 'src/app.ts' })
      });

    const report = await analyzer.analyze({
      projectId: 'proj1',
      baseBranch: 'main',
      targetBranch: 'feature'
    });

    expect(report.affectedEntities).toHaveLength(1);
    expect(report.affectedEntities[0].usageCount).toBe(15);
  });

  it('should calculate risk level correctly', async () => {
    mockMcpClient.callTool.mockResolvedValue({ entities: [], decisions: [] });

    // Mock git output for many deleted files
    jest.spyOn(require('child_process'), 'execSync').mockReturnValue(
      'D\tsrc/auth.ts\nD\tsrc/user.ts\nD\tsrc/api.ts'
    );

    const report = await analyzer.analyze({
      projectId: 'proj1',
      baseBranch: 'main',
      targetBranch: 'feature'
    });

    expect(report.riskLevel).toBe('medium');
    expect(report.reasons).toContainEqual(expect.stringContaining('deleted'));
  });

  it('should generate helpful suggestions', async () => {
    mockMcpClient.callTool
      .mockResolvedValueOnce({
        entities: [
          {
            id: 'e1',
            name: 'authenticate',
            type: 'function',
            filePath: 'src/auth.ts'
          }
        ]
      })
      .mockResolvedValueOnce({
        references: Array(20).fill({ filePath: 'test.ts' })
      })
      .mockResolvedValue({ decisions: [] });

    const report = await analyzer.analyze({
      projectId: 'proj1',
      baseBranch: 'main',
      targetBranch: 'feature'
    });

    expect(report.suggestions).toContainEqual(
      expect.stringContaining('widely-used')
    );
  });
});
```

### Integration Tests

```typescript
describe('Git Hooks Integration', () => {
  let testRepo: string;
  let hookHandler: HookHandler;

  beforeEach(async () => {
    testRepo = await createTestRepo();
    hookHandler = new HookHandler({
      ...defaultHookConfig,
      serverUrl: testMcpServerUrl
    });
  });

  it('should index files on commit', async () => {
    // Stage a file
    await fs.writeFile(path.join(testRepo, 'test.ts'), 'export const x = 1;');
    execSync('git add test.ts', { cwd: testRepo });

    // Trigger pre-commit hook
    const result = await hookHandler.handle({
      type: 'pre-commit',
      timestamp: new Date(),
      repository: testRepo,
      currentBranch: 'main',
      currentCommit: 'HEAD',
      stagedFiles: ['test.ts']
    });

    expect(result.success).toBe(true);
    expect(result.filesIndexed).toBe(1);
  });

  it('should generate impact report on merge', async () => {
    // Create feature branch and make changes
    execSync('git checkout -b feature', { cwd: testRepo });
    await fs.writeFile(path.join(testRepo, 'new.ts'), 'export const y = 2;');
    execSync('git add new.ts && git commit -m "add new file"', { cwd: testRepo });

    // Merge back to main
    execSync('git checkout main && git merge feature', { cwd: testRepo });

    // Trigger post-merge hook
    const result = await hookHandler.handle({
      type: 'post-merge',
      timestamp: new Date(),
      repository: testRepo,
      currentBranch: 'main',
      currentCommit: 'HEAD',
      previousCommit: 'HEAD~1',
      mergedFiles: ['new.ts']
    });

    expect(result.success).toBe(true);
    expect(result.impactReport).toBeDefined();
    expect(result.impactReport?.filesAdded).toContain('new.ts');
  });

  it('should handle timeout gracefully', async () => {
    const slowHandler = new HookHandler({
      ...defaultHookConfig,
      timeoutMs: 100
    });

    // Mock a slow MCP call
    jest.spyOn(MCPClient.prototype, 'callTool').mockImplementation(
      () => new Promise(resolve => setTimeout(resolve, 200))
    );

    const result = await slowHandler.handle({
      type: 'pre-commit',
      timestamp: new Date(),
      repository: testRepo,
      currentBranch: 'main',
      currentCommit: 'HEAD',
      stagedFiles: ['test.ts']
    });

    // Should not block git operation
    expect(result.success).toBe(false);
    expect(result.errors).toContainEqual(expect.stringContaining('timeout'));
  });
});
```

## Success Metrics

| Metric | Target | Measurement |
|--------|--------|-------------|
| Hook execution time | < 2s | 95th percentile for pre-commit |
| Index freshness | < 5min | Time since last index update |
| Error rate | < 1% | Failed hook executions |
| User adoption | 80%+ | Projects with hooks installed |
| False positive rate | < 5% | Impact reports flagging non-issues |
| Developer satisfaction | 4/5+ | Survey rating |

## Future Enhancements

1. **Webhook server for GitHub/GitLab**
   - Listen for PR events
   - Post impact reports as PR comments
   - Set commit status checks

2. **Incremental indexing optimization**
   - Index only changed functions/classes, not whole files
   - Faster commits on large files

3. **Smart hook skipping**
   - Skip indexing for trivial changes (docs, comments, tests)
   - Detect when hooks aren't needed

4. **Conflict resolution guidance**
   - Surface relevant context during merge conflicts
   - Show decisions about conflicting code

5. **Pre-receive hooks for servers**
   - Validate index completeness on push to shared repos
   - Enforce quality gates

6. **Interactive impact review**
   - TUI for reviewing impact before merging
   - Accept/reject suggestions

7. **Hook templates**
   - Pre-configured hook sets for different workflows
   - Monorepo-specific configurations

8. **Metrics dashboard**
   - Track hook performance over time
   - Identify slow operations
