# F9.1 VS Code Extension

**Phase**: 9 - Integrations & Analytics
**Priority**: High
**Dependencies**: F1.5 MCP Server, F6.3 Context Assembly, F9.2 Token Analytics

## Goal

Build a native VS Code extension that provides seamless integration with ctx-sys, reducing friction and surfacing relevant context directly in the editor.

## Overview

While ctx-sys exposes powerful MCP tools, developers must currently switch to a terminal or chat interface to access context. A VS Code extension brings ctx-sys directly into the development workflow:

- Sidebar panel showing relevant context for the current file
- Hover information showing related decisions and history
- Command palette integration for common operations
- Status bar showing connection status and token savings
- Automatic context injection into AI assistants (Copilot, Continue, etc.)

## Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                      VS Code Extension                       │
├─────────────────────────────────────────────────────────────┤
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐       │
│  │   Sidebar    │  │    Hover     │  │   Commands   │       │
│  │   Panel      │  │   Provider   │  │   Handler    │       │
│  └──────────────┘  └──────────────┘  └──────────────┘       │
│          │                │                 │                │
│          └────────────────┼─────────────────┘                │
│                           │                                  │
│                    ┌──────▼──────┐                           │
│                    │   Context   │                           │
│                    │   Service   │                           │
│                    └──────┬──────┘                           │
│                           │                                  │
│                    ┌──────▼──────┐                           │
│                    │  MCP Client │                           │
│                    └──────┬──────┘                           │
└───────────────────────────┼─────────────────────────────────┘
                            │
                     ┌──────▼──────┐
                     │  ctx-sys    │
                     │  MCP Server │
                     └─────────────┘
```

## Data Model

```typescript
interface ExtensionConfig {
  // Connection settings
  serverUrl: string;                    // MCP server URL (default: localhost:3000)
  projectPath: string;                  // Project to query (auto-detected)
  autoConnect: boolean;                 // Connect on startup
  
  // Feature toggles
  enableSidebar: boolean;
  enableHover: boolean;
  enableStatusBar: boolean;
  enableContextInjection: boolean;       // For Copilot/Continue
  
  // Display settings
  maxContextItems: number;              // Items to show in sidebar
  refreshInterval: number;              // Seconds between auto-refresh
  
  // Token settings
  showTokenSavings: boolean;
  tokenBudget: number;                  // Max tokens to suggest
}

interface ContextPanelState {
  currentFile: string | null;
  cursorPosition: { line: number; character: number } | null;
  
  // Grouped context items
  relatedCode: ContextItem[];
  decisions: DecisionItem[];
  recentChanges: ChangeItem[];
  documentation: DocItem[];
  
  // Status
  isLoading: boolean;
  lastUpdated: Date | null;
  error: string | null;
}

interface ContextItem {
  id: string;
  type: 'code' | 'decision' | 'change' | 'doc' | 'entity';
  title: string;
  summary: string;
  relevanceScore: number;
  
  // Navigation
  filePath?: string;
  lineRange?: { start: number; end: number };
  
  // Display
  icon: string;
  preview?: string;
  expandedContent?: string;
}

interface DecisionItem extends ContextItem {
  type: 'decision';
  sessionId: string;
  decidedAt: Date;
  participants?: string[];
  tags: string[];
}

interface ChangeItem extends ContextItem {
  type: 'change';
  commitHash: string;
  author: string;
  changedAt: Date;
  filesChanged: string[];
}

interface DocItem extends ContextItem {
  type: 'doc';
  documentPath: string;
  section?: string;
  lastUpdated: Date;
}

interface StatusBarState {
  connected: boolean;
  projectName: string | null;
  tokensSaved: number;               // Tokens saved this session
  queriesMade: number;
}

interface HoverContext {
  symbol: string;
  filePath: string;
  position: { line: number; character: number };
  
  // Retrieved context
  definition?: string;
  relatedDecisions: DecisionItem[];
  recentChanges: ChangeItem[];
  usage: string[];
}
```

## Extension Structure

```
ctx-sys-vscode/
├── package.json              # Extension manifest
├── src/
│   ├── extension.ts          # Entry point
│   ├── services/
│   │   ├── context-service.ts      # Core context retrieval
│   │   ├── mcp-client.ts           # MCP communication
│   │   └── cache-service.ts        # Local caching
│   ├── providers/
│   │   ├── sidebar-provider.ts     # Sidebar webview
│   │   ├── hover-provider.ts       # Hover information
│   │   └── completion-provider.ts  # Context for AI
│   ├── commands/
│   │   ├── index-project.ts
│   │   ├── query-context.ts
│   │   └── view-analytics.ts
│   ├── views/
│   │   ├── sidebar/                # Webview UI
│   │   │   ├── index.html
│   │   │   ├── sidebar.ts
│   │   │   └── sidebar.css
│   │   └── analytics/
│   │       └── dashboard.html
│   └── utils/
│       ├── config.ts
│       └── telemetry.ts
├── resources/
│   └── icons/
└── test/
```

## Implementation

### File: `src/extension.ts`

```typescript
import * as vscode from 'vscode';
import { ContextService } from './services/context-service';
import { MCPClient } from './services/mcp-client';
import { SidebarProvider } from './providers/sidebar-provider';
import { HoverProvider } from './providers/hover-provider';
import { registerCommands } from './commands';

let contextService: ContextService | null = null;

export async function activate(context: vscode.ExtensionContext) {
  console.log('ctx-sys extension activating...');
  
  // Load configuration
  const config = vscode.workspace.getConfiguration('ctx-sys');
  
  // Initialize MCP client
  const mcpClient = new MCPClient({
    serverUrl: config.get('serverUrl', 'http://localhost:3000'),
    projectPath: detectProjectPath()
  });
  
  // Initialize context service
  contextService = new ContextService(mcpClient);
  
  // Auto-connect if configured
  if (config.get('autoConnect', true)) {
    try {
      await contextService.connect();
      updateStatusBar('connected');
    } catch (error) {
      console.error('Failed to connect to ctx-sys:', error);
      updateStatusBar('disconnected');
    }
  }
  
  // Register sidebar provider
  if (config.get('enableSidebar', true)) {
    const sidebarProvider = new SidebarProvider(context.extensionUri, contextService);
    context.subscriptions.push(
      vscode.window.registerWebviewViewProvider('ctx-sys-sidebar', sidebarProvider)
    );
  }
  
  // Register hover provider
  if (config.get('enableHover', true)) {
    const hoverProvider = new HoverProvider(contextService);
    context.subscriptions.push(
      vscode.languages.registerHoverProvider(
        { scheme: 'file' },
        hoverProvider
      )
    );
  }
  
  // Register commands
  registerCommands(context, contextService);
  
  // Register status bar
  if (config.get('enableStatusBar', true)) {
    createStatusBar(context);
  }
  
  // Listen for active editor changes
  context.subscriptions.push(
    vscode.window.onDidChangeActiveTextEditor(editor => {
      if (editor) {
        contextService?.updateCurrentFile(editor.document.uri.fsPath);
      }
    })
  );
  
  // Listen for cursor position changes
  context.subscriptions.push(
    vscode.window.onDidChangeTextEditorSelection(event => {
      const position = event.selections[0]?.active;
      if (position) {
        contextService?.updateCursorPosition(position);
      }
    })
  );
  
  console.log('ctx-sys extension activated');
}

export function deactivate() {
  contextService?.disconnect();
}

function detectProjectPath(): string {
  const workspaceFolders = vscode.workspace.workspaceFolders;
  return workspaceFolders?.[0]?.uri.fsPath || process.cwd();
}

let statusBarItem: vscode.StatusBarItem;

function createStatusBar(context: vscode.ExtensionContext) {
  statusBarItem = vscode.window.createStatusBarItem(
    vscode.StatusBarAlignment.Right,
    100
  );
  statusBarItem.command = 'ctx-sys.showStatus';
  context.subscriptions.push(statusBarItem);
  updateStatusBar('connecting');
  statusBarItem.show();
}

function updateStatusBar(status: 'connected' | 'disconnected' | 'connecting') {
  if (!statusBarItem) return;
  
  switch (status) {
    case 'connected':
      statusBarItem.text = '$(database) ctx-sys';
      statusBarItem.tooltip = 'ctx-sys: Connected';
      statusBarItem.backgroundColor = undefined;
      break;
    case 'disconnected':
      statusBarItem.text = '$(database) ctx-sys $(warning)';
      statusBarItem.tooltip = 'ctx-sys: Disconnected';
      statusBarItem.backgroundColor = new vscode.ThemeColor(
        'statusBarItem.warningBackground'
      );
      break;
    case 'connecting':
      statusBarItem.text = '$(loading~spin) ctx-sys';
      statusBarItem.tooltip = 'ctx-sys: Connecting...';
      break;
  }
}
```

### File: `src/services/context-service.ts`

```typescript
import { MCPClient } from './mcp-client';
import { CacheService } from './cache-service';
import { ContextPanelState, ContextItem, DecisionItem } from '../types';

export class ContextService {
  private cache: CacheService;
  private currentFile: string | null = null;
  private cursorPosition: { line: number; character: number } | null = null;
  private listeners: Set<(state: ContextPanelState) => void> = new Set();
  private refreshTimer: NodeJS.Timer | null = null;
  
  constructor(private mcpClient: MCPClient) {
    this.cache = new CacheService();
  }
  
  async connect(): Promise<void> {
    await this.mcpClient.connect();
    this.startAutoRefresh();
  }
  
  disconnect(): void {
    this.stopAutoRefresh();
    this.mcpClient.disconnect();
  }
  
  updateCurrentFile(filePath: string): void {
    if (this.currentFile !== filePath) {
      this.currentFile = filePath;
      this.refreshContext();
    }
  }
  
  updateCursorPosition(position: { line: number; character: number }): void {
    this.cursorPosition = position;
    // Debounce cursor updates
    this.debouncedRefresh();
  }
  
  onStateChange(callback: (state: ContextPanelState) => void): () => void {
    this.listeners.add(callback);
    return () => this.listeners.delete(callback);
  }
  
  async refreshContext(): Promise<ContextPanelState> {
    if (!this.currentFile) {
      return this.emptyState();
    }
    
    this.notifyListeners({ ...this.emptyState(), isLoading: true });
    
    try {
      // Check cache first
      const cacheKey = `${this.currentFile}:${this.cursorPosition?.line || 0}`;
      const cached = this.cache.get(cacheKey);
      if (cached && !this.cache.isStale(cacheKey)) {
        return cached;
      }
      
      // Fetch fresh context
      const [related, decisions, changes, docs] = await Promise.all([
        this.fetchRelatedCode(),
        this.fetchDecisions(),
        this.fetchRecentChanges(),
        this.fetchDocumentation()
      ]);
      
      const state: ContextPanelState = {
        currentFile: this.currentFile,
        cursorPosition: this.cursorPosition,
        relatedCode: related,
        decisions,
        recentChanges: changes,
        documentation: docs,
        isLoading: false,
        lastUpdated: new Date(),
        error: null
      };
      
      this.cache.set(cacheKey, state);
      this.notifyListeners(state);
      
      return state;
    } catch (error) {
      const state: ContextPanelState = {
        ...this.emptyState(),
        error: error instanceof Error ? error.message : 'Unknown error'
      };
      this.notifyListeners(state);
      return state;
    }
  }
  
  private async fetchRelatedCode(): Promise<ContextItem[]> {
    const result = await this.mcpClient.callTool('context_query', {
      query: `code related to ${this.currentFile}`,
      maxTokens: 2000,
      includeTypes: ['code', 'entity']
    });
    
    return result.items.map(this.toContextItem);
  }
  
  private async fetchDecisions(): Promise<DecisionItem[]> {
    const result = await this.mcpClient.callTool('decision_search', {
      query: `decisions about ${this.getFilename()}`,
      limit: 5
    });
    
    return result.decisions.map((d: any) => ({
      id: d.id,
      type: 'decision' as const,
      title: d.title || d.decision.substring(0, 50),
      summary: d.decision,
      relevanceScore: d.score,
      sessionId: d.sessionId,
      decidedAt: new Date(d.createdAt),
      tags: d.tags || [],
      icon: '$(light-bulb)'
    }));
  }
  
  private async fetchRecentChanges(): Promise<ContextItem[]> {
    const result = await this.mcpClient.callTool('git_file_history', {
      filePath: this.currentFile,
      limit: 5
    });
    
    return result.commits.map((c: any) => ({
      id: c.hash,
      type: 'change' as const,
      title: c.message.split('\n')[0],
      summary: c.message,
      relevanceScore: 1.0,
      commitHash: c.hash,
      author: c.author,
      changedAt: new Date(c.date),
      filesChanged: c.files,
      icon: '$(git-commit)'
    }));
  }
  
  private async fetchDocumentation(): Promise<ContextItem[]> {
    const result = await this.mcpClient.callTool('context_query', {
      query: `documentation for ${this.getFilename()}`,
      maxTokens: 1000,
      includeTypes: ['document']
    });
    
    return result.items.map((item: any) => ({
      ...this.toContextItem(item),
      type: 'doc' as const,
      icon: '$(book)'
    }));
  }
  
  private toContextItem(item: any): ContextItem {
    return {
      id: item.id,
      type: item.type || 'code',
      title: item.title || item.name || 'Unknown',
      summary: item.summary || item.content?.substring(0, 200) || '',
      relevanceScore: item.score || 0.5,
      filePath: item.filePath,
      lineRange: item.lineRange,
      icon: this.getIconForType(item.type),
      preview: item.content?.substring(0, 500)
    };
  }
  
  private getIconForType(type: string): string {
    const icons: Record<string, string> = {
      code: '$(code)',
      decision: '$(light-bulb)',
      change: '$(git-commit)',
      doc: '$(book)',
      entity: '$(symbol-class)'
    };
    return icons[type] || '$(file)';
  }
  
  private getFilename(): string {
    if (!this.currentFile) return '';
    return this.currentFile.split('/').pop() || '';
  }
  
  private emptyState(): ContextPanelState {
    return {
      currentFile: this.currentFile,
      cursorPosition: this.cursorPosition,
      relatedCode: [],
      decisions: [],
      recentChanges: [],
      documentation: [],
      isLoading: false,
      lastUpdated: null,
      error: null
    };
  }
  
  private notifyListeners(state: ContextPanelState): void {
    this.listeners.forEach(callback => callback(state));
  }
  
  private refreshTimer: NodeJS.Timer | null = null;
  private debounceTimer: NodeJS.Timer | null = null;
  
  private startAutoRefresh(): void {
    const interval = 60000; // 1 minute
    this.refreshTimer = setInterval(() => this.refreshContext(), interval);
  }
  
  private stopAutoRefresh(): void {
    if (this.refreshTimer) {
      clearInterval(this.refreshTimer);
    }
  }
  
  private debouncedRefresh(): void {
    if (this.debounceTimer) {
      clearTimeout(this.debounceTimer);
    }
    this.debounceTimer = setTimeout(() => this.refreshContext(), 500);
  }
}
```

### File: `src/providers/sidebar-provider.ts`

```typescript
import * as vscode from 'vscode';
import { ContextService } from '../services/context-service';
import { ContextPanelState, ContextItem } from '../types';

export class SidebarProvider implements vscode.WebviewViewProvider {
  private view?: vscode.WebviewView;
  private unsubscribe?: () => void;
  
  constructor(
    private extensionUri: vscode.Uri,
    private contextService: ContextService
  ) {}
  
  resolveWebviewView(
    webviewView: vscode.WebviewView,
    context: vscode.WebviewViewResolveContext,
    token: vscode.CancellationToken
  ): void {
    this.view = webviewView;
    
    webviewView.webview.options = {
      enableScripts: true,
      localResourceRoots: [this.extensionUri]
    };
    
    webviewView.webview.html = this.getHtml(webviewView.webview);
    
    // Listen for messages from webview
    webviewView.webview.onDidReceiveMessage(message => {
      switch (message.type) {
        case 'navigate':
          this.navigateToItem(message.item);
          break;
        case 'refresh':
          this.contextService.refreshContext();
          break;
        case 'expand':
          this.expandItem(message.itemId);
          break;
      }
    });
    
    // Subscribe to context changes
    this.unsubscribe = this.contextService.onStateChange(state => {
      this.updateView(state);
    });
    
    // Initial fetch
    this.contextService.refreshContext();
  }
  
  private updateView(state: ContextPanelState): void {
    if (!this.view) return;
    
    this.view.webview.postMessage({
      type: 'update',
      state
    });
  }
  
  private navigateToItem(item: ContextItem): void {
    if (!item.filePath) return;
    
    const uri = vscode.Uri.file(item.filePath);
    const options: vscode.TextDocumentShowOptions = {};
    
    if (item.lineRange) {
      options.selection = new vscode.Range(
        item.lineRange.start - 1, 0,
        item.lineRange.end - 1, 0
      );
    }
    
    vscode.window.showTextDocument(uri, options);
  }
  
  private expandItem(itemId: string): void {
    // Fetch full content for the item
    // Implementation depends on MCP tools available
  }
  
  private getHtml(webview: vscode.Webview): string {
    const styleUri = webview.asWebviewUri(
      vscode.Uri.joinPath(this.extensionUri, 'resources', 'sidebar.css')
    );
    const scriptUri = webview.asWebviewUri(
      vscode.Uri.joinPath(this.extensionUri, 'resources', 'sidebar.js')
    );
    
    return `<!DOCTYPE html>
    <html>
    <head>
      <link rel="stylesheet" href="${styleUri}">
    </head>
    <body>
      <div id="root">
        <div class="header">
          <h3>Context</h3>
          <button id="refresh-btn" class="icon-btn" title="Refresh">
            <span class="codicon codicon-refresh"></span>
          </button>
        </div>
        
        <div id="loading" class="loading hidden">
          <span class="codicon codicon-loading spin"></span>
          Loading context...
        </div>
        
        <div id="error" class="error hidden"></div>
        
        <div id="content">
          <section id="decisions-section" class="section">
            <h4><span class="codicon codicon-light-bulb"></span> Decisions</h4>
            <ul id="decisions-list" class="item-list"></ul>
          </section>
          
          <section id="code-section" class="section">
            <h4><span class="codicon codicon-code"></span> Related Code</h4>
            <ul id="code-list" class="item-list"></ul>
          </section>
          
          <section id="changes-section" class="section">
            <h4><span class="codicon codicon-git-commit"></span> Recent Changes</h4>
            <ul id="changes-list" class="item-list"></ul>
          </section>
          
          <section id="docs-section" class="section">
            <h4><span class="codicon codicon-book"></span> Documentation</h4>
            <ul id="docs-list" class="item-list"></ul>
          </section>
        </div>
        
        <div id="empty" class="empty hidden">
          <p>Open a file to see related context</p>
        </div>
      </div>
      <script src="${scriptUri}"></script>
    </body>
    </html>`;
  }
}
```

### File: `src/providers/hover-provider.ts`

```typescript
import * as vscode from 'vscode';
import { ContextService } from '../services/context-service';

export class HoverProvider implements vscode.HoverProvider {
  constructor(private contextService: ContextService) {}
  
  async provideHover(
    document: vscode.TextDocument,
    position: vscode.Position,
    token: vscode.CancellationToken
  ): Promise<vscode.Hover | null> {
    // Get word at position
    const wordRange = document.getWordRangeAtPosition(position);
    if (!wordRange) return null;
    
    const word = document.getText(wordRange);
    if (word.length < 3) return null;
    
    // Check if this looks like a symbol
    if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(word)) return null;
    
    try {
      // Fetch context for this symbol
      const context = await this.contextService.getSymbolContext(
        word,
        document.uri.fsPath,
        position
      );
      
      if (!context || !context.hasRelevantInfo) {
        return null;
      }
      
      // Build hover content
      const contents = new vscode.MarkdownString();
      contents.isTrusted = true;
      
      // Related decisions
      if (context.decisions.length > 0) {
        contents.appendMarkdown('**Related Decisions:**\n\n');
        for (const decision of context.decisions.slice(0, 3)) {
          contents.appendMarkdown(`- ${decision.summary}\n`);
          contents.appendMarkdown(`  *${this.formatDate(decision.decidedAt)}*\n\n`);
        }
      }
      
      // Recent changes
      if (context.recentChanges.length > 0) {
        contents.appendMarkdown('**Recent Changes:**\n\n');
        for (const change of context.recentChanges.slice(0, 2)) {
          contents.appendMarkdown(`- ${change.title}\n`);
          contents.appendMarkdown(`  *by ${change.author}, ${this.formatDate(change.changedAt)}*\n\n`);
        }
      }
      
      // Link to full context
      const commandUri = vscode.Uri.parse(
        `command:ctx-sys.showSymbolContext?${encodeURIComponent(JSON.stringify({ symbol: word }))}`
      );
      contents.appendMarkdown(`[View full context](${commandUri})`);
      
      return new vscode.Hover(contents, wordRange);
    } catch (error) {
      console.error('Error fetching hover context:', error);
      return null;
    }
  }
  
  private formatDate(date: Date): string {
    const now = new Date();
    const diff = now.getTime() - date.getTime();
    const days = Math.floor(diff / (1000 * 60 * 60 * 24));
    
    if (days === 0) return 'today';
    if (days === 1) return 'yesterday';
    if (days < 7) return `${days} days ago`;
    if (days < 30) return `${Math.floor(days / 7)} weeks ago`;
    return date.toLocaleDateString();
  }
}
```

### File: `src/commands/index.ts`

```typescript
import * as vscode from 'vscode';
import { ContextService } from '../services/context-service';

export function registerCommands(
  context: vscode.ExtensionContext,
  contextService: ContextService
): void {
  // Index project
  context.subscriptions.push(
    vscode.commands.registerCommand('ctx-sys.indexProject', async () => {
      const result = await vscode.window.withProgress(
        {
          location: vscode.ProgressLocation.Notification,
          title: 'Indexing project...',
          cancellable: false
        },
        async (progress) => {
          progress.report({ increment: 0 });
          
          try {
            const result = await contextService.indexProject();
            progress.report({ increment: 100 });
            return result;
          } catch (error) {
            throw error;
          }
        }
      );
      
      vscode.window.showInformationMessage(
        `Indexed ${result.filesIndexed} files, ${result.entitiesFound} entities found`
      );
    })
  );
  
  // Query context
  context.subscriptions.push(
    vscode.commands.registerCommand('ctx-sys.queryContext', async () => {
      const query = await vscode.window.showInputBox({
        prompt: 'Enter your context query',
        placeHolder: 'e.g., "How does the auth system work?"'
      });
      
      if (!query) return;
      
      const panel = vscode.window.createWebviewPanel(
        'ctx-sys-query',
        'Context Query Results',
        vscode.ViewColumn.Two,
        { enableScripts: true }
      );
      
      panel.webview.html = '<body>Loading...</body>';
      
      try {
        const results = await contextService.query(query);
        panel.webview.html = formatQueryResults(results);
      } catch (error) {
        panel.webview.html = `<body>Error: ${error}</body>`;
      }
    })
  );
  
  // View analytics
  context.subscriptions.push(
    vscode.commands.registerCommand('ctx-sys.viewAnalytics', async () => {
      const panel = vscode.window.createWebviewPanel(
        'ctx-sys-analytics',
        'Token Analytics',
        vscode.ViewColumn.One,
        { enableScripts: true }
      );
      
      try {
        const analytics = await contextService.getAnalytics();
        panel.webview.html = formatAnalyticsDashboard(analytics);
      } catch (error) {
        panel.webview.html = `<body>Error loading analytics: ${error}</body>`;
      }
    })
  );
  
  // Show status
  context.subscriptions.push(
    vscode.commands.registerCommand('ctx-sys.showStatus', async () => {
      const status = contextService.getStatus();
      
      const items: vscode.QuickPickItem[] = [
        {
          label: status.connected ? '$(check) Connected' : '$(x) Disconnected',
          description: status.connected ? status.projectName : 'Not connected'
        },
        {
          label: `$(graph) ${status.tokensSaved.toLocaleString()} tokens saved`,
          description: 'this session'
        },
        {
          label: `$(search) ${status.queriesMade} queries made`,
          description: 'this session'
        }
      ];
      
      if (!status.connected) {
        items.push({
          label: '$(plug) Connect to ctx-sys',
          description: 'Establish connection'
        });
      }
      
      const selected = await vscode.window.showQuickPick(items, {
        title: 'ctx-sys Status'
      });
      
      if (selected?.label.includes('Connect')) {
        await contextService.connect();
      }
    })
  );
  
  // Copy context to clipboard
  context.subscriptions.push(
    vscode.commands.registerCommand('ctx-sys.copyContext', async () => {
      const state = await contextService.refreshContext();
      const contextText = formatContextAsText(state);
      
      await vscode.env.clipboard.writeText(contextText);
      vscode.window.showInformationMessage('Context copied to clipboard');
    })
  );
}

function formatQueryResults(results: any): string {
  // Implementation for HTML formatting
  return `<!DOCTYPE html>
  <html>
  <head>
    <style>
      body { font-family: var(--vscode-font-family); padding: 20px; }
      .result { margin: 10px 0; padding: 10px; border: 1px solid var(--vscode-panel-border); }
      .score { color: var(--vscode-descriptionForeground); }
    </style>
  </head>
  <body>
    <h2>Query Results</h2>
    ${results.items.map((item: any) => `
      <div class="result">
        <strong>${item.title}</strong>
        <span class="score">(${(item.score * 100).toFixed(0)}%)</span>
        <p>${item.summary}</p>
      </div>
    `).join('')}
  </body>
  </html>`;
}

function formatAnalyticsDashboard(analytics: any): string {
  // Implementation for analytics dashboard HTML
  return `<!DOCTYPE html>...`;
}

function formatContextAsText(state: any): string {
  const parts: string[] = [];
  
  if (state.decisions.length > 0) {
    parts.push('## Decisions\n');
    state.decisions.forEach((d: any) => {
      parts.push(`- ${d.summary}\n`);
    });
  }
  
  if (state.relatedCode.length > 0) {
    parts.push('\n## Related Code\n');
    state.relatedCode.forEach((c: any) => {
      parts.push(`- ${c.title}: ${c.summary}\n`);
    });
  }
  
  return parts.join('');
}
```

## Package.json Manifest

```json
{
  "name": "ctx-sys-vscode",
  "displayName": "ctx-sys Context Intelligence",
  "description": "Intelligent context retrieval for your codebase",
  "version": "0.1.0",
  "publisher": "ctx-sys",
  "engines": {
    "vscode": "^1.85.0"
  },
  "categories": ["Other"],
  "activationEvents": [
    "onStartupFinished"
  ],
  "main": "./out/extension.js",
  "contributes": {
    "viewsContainers": {
      "activitybar": [
        {
          "id": "ctx-sys",
          "title": "ctx-sys",
          "icon": "resources/icon.svg"
        }
      ]
    },
    "views": {
      "ctx-sys": [
        {
          "type": "webview",
          "id": "ctx-sys-sidebar",
          "name": "Context"
        }
      ]
    },
    "commands": [
      {
        "command": "ctx-sys.indexProject",
        "title": "ctx-sys: Index Project"
      },
      {
        "command": "ctx-sys.queryContext",
        "title": "ctx-sys: Query Context"
      },
      {
        "command": "ctx-sys.viewAnalytics",
        "title": "ctx-sys: View Token Analytics"
      },
      {
        "command": "ctx-sys.showStatus",
        "title": "ctx-sys: Show Status"
      },
      {
        "command": "ctx-sys.copyContext",
        "title": "ctx-sys: Copy Context to Clipboard"
      }
    ],
    "configuration": {
      "title": "ctx-sys",
      "properties": {
        "ctx-sys.serverUrl": {
          "type": "string",
          "default": "http://localhost:3000",
          "description": "URL of the ctx-sys MCP server"
        },
        "ctx-sys.autoConnect": {
          "type": "boolean",
          "default": true,
          "description": "Automatically connect to ctx-sys on startup"
        },
        "ctx-sys.enableSidebar": {
          "type": "boolean",
          "default": true,
          "description": "Enable the context sidebar panel"
        },
        "ctx-sys.enableHover": {
          "type": "boolean",
          "default": true,
          "description": "Enable context information on hover"
        },
        "ctx-sys.enableStatusBar": {
          "type": "boolean",
          "default": true,
          "description": "Show ctx-sys status in the status bar"
        },
        "ctx-sys.maxContextItems": {
          "type": "number",
          "default": 10,
          "description": "Maximum context items to show in sidebar"
        },
        "ctx-sys.refreshInterval": {
          "type": "number",
          "default": 60,
          "description": "Seconds between automatic context refresh"
        }
      }
    }
  },
  "scripts": {
    "vscode:prepublish": "npm run compile",
    "compile": "tsc -p ./",
    "watch": "tsc -watch -p ./",
    "test": "node ./out/test/runTest.js"
  },
  "devDependencies": {
    "@types/vscode": "^1.85.0",
    "@types/node": "^20.0.0",
    "typescript": "^5.0.0"
  }
}
```

## Testing

### Unit Tests

```typescript
describe('ContextService', () => {
  let service: ContextService;
  let mockMcpClient: jest.Mocked<MCPClient>;
  
  beforeEach(() => {
    mockMcpClient = {
      connect: jest.fn(),
      disconnect: jest.fn(),
      callTool: jest.fn()
    } as any;
    
    service = new ContextService(mockMcpClient);
  });
  
  it('should fetch context for current file', async () => {
    mockMcpClient.callTool.mockResolvedValue({
      items: [{ id: '1', title: 'Test', type: 'code' }]
    });
    
    service.updateCurrentFile('/test/file.ts');
    const state = await service.refreshContext();
    
    expect(state.relatedCode).toHaveLength(1);
    expect(state.isLoading).toBe(false);
  });
  
  it('should cache results', async () => {
    mockMcpClient.callTool.mockResolvedValue({ items: [] });
    
    service.updateCurrentFile('/test/file.ts');
    await service.refreshContext();
    await service.refreshContext();
    
    // Should only call once due to caching
    expect(mockMcpClient.callTool).toHaveBeenCalledTimes(4); // 4 types of context
  });
  
  it('should debounce cursor position updates', async () => {
    jest.useFakeTimers();
    
    service.updateCurrentFile('/test/file.ts');
    service.updateCursorPosition({ line: 1, character: 0 });
    service.updateCursorPosition({ line: 2, character: 0 });
    service.updateCursorPosition({ line: 3, character: 0 });
    
    jest.advanceTimersByTime(500);
    
    // Should only trigger one refresh
    expect(mockMcpClient.callTool).toHaveBeenCalledTimes(4);
    
    jest.useRealTimers();
  });
});

describe('HoverProvider', () => {
  it('should return null for short words', async () => {
    const provider = new HoverProvider(mockContextService);
    const document = createMockDocument('ab');
    
    const hover = await provider.provideHover(
      document,
      new vscode.Position(0, 0),
      new vscode.CancellationToken()
    );
    
    expect(hover).toBeNull();
  });
  
  it('should show decisions in hover', async () => {
    mockContextService.getSymbolContext.mockResolvedValue({
      hasRelevantInfo: true,
      decisions: [{ summary: 'Use factory pattern', decidedAt: new Date() }],
      recentChanges: []
    });
    
    const hover = await provider.provideHover(
      createMockDocument('UserFactory'),
      new vscode.Position(0, 5),
      new vscode.CancellationToken()
    );
    
    expect(hover).not.toBeNull();
    expect(hover?.contents[0]).toContain('factory pattern');
  });
});
```

### Integration Tests

```typescript
describe('Extension Integration', () => {
  it('should activate without errors', async () => {
    const extension = vscode.extensions.getExtension('ctx-sys.ctx-sys-vscode');
    await extension?.activate();
    
    expect(extension?.isActive).toBe(true);
  });
  
  it('should register all commands', async () => {
    const commands = await vscode.commands.getCommands(true);
    
    expect(commands).toContain('ctx-sys.indexProject');
    expect(commands).toContain('ctx-sys.queryContext');
    expect(commands).toContain('ctx-sys.viewAnalytics');
  });
  
  it('should show sidebar when view container clicked', async () => {
    await vscode.commands.executeCommand('ctx-sys-sidebar.focus');
    
    // Verify sidebar is visible
    const view = vscode.window.visibleWebviewViews.find(
      v => v.viewType === 'ctx-sys-sidebar'
    );
    expect(view).toBeDefined();
  });
});
```

## Success Metrics

| Metric | Target | Measurement |
|--------|--------|-------------|
| Activation time | < 500ms | Extension load to ready |
| Context fetch | < 2s | Time to display context |
| Memory usage | < 50MB | Extension process memory |
| Hover latency | < 200ms | Time to show hover info |
| User adoption | 50%+ | Active users with extension |
| Context accuracy | 80%+ | Relevant items in top 5 |

## Future Enhancements

1. **Context injection for Copilot/Continue**
   - Inject relevant context into AI assistant prompts
   - Requires investigation of extension APIs

2. **Inline code annotations**
   - Show decision indicators in gutter
   - Click to see related decisions

3. **Diff view integration**
   - Show related decisions in PR review
   - Highlight areas with relevant history

4. **Multi-project support**
   - Switch between indexed projects
   - Aggregate context from monorepo

5. **Offline mode**
   - Cache recent context locally
   - Sync when connection restored
