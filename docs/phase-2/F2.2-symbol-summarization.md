# F2.2 Symbol Summarization

**Phase**: 2 - Code Intelligence
**Priority**: High
**Dependencies**: F2.1 AST Parsing, F1.4 Embedding Pipeline

## Goal

Generate concise, 1-line AI summaries for each code symbol (functions, classes, methods) using local Ollama or cloud models.

## Overview

After extracting symbols via AST parsing, we need human-readable summaries that describe *what* each symbol does. These summaries:
- Enable semantic search ("find the function that validates user input")
- Provide quick understanding without reading code
- Feed into the context retrieval system

## Design Principles

1. **Concise**: Max 15 words, one sentence
2. **Action-oriented**: Start with a verb (Returns, Validates, Creates, etc.)
3. **What, not How**: Describe purpose, not implementation
4. **Context-aware**: Use surrounding code for better understanding

## Data Model

```typescript
interface SummarizationProvider {
  readonly name: string;
  readonly modelId: string;

  summarize(content: string, context?: SummarizationContext): Promise<string>;
  summarizeBatch(
    items: Array<{ content: string; context?: SummarizationContext }>,
    options?: BatchOptions
  ): Promise<string[]>;
  isAvailable(): Promise<boolean>;
}

interface SummarizationContext {
  fileName?: string;
  language?: string;
  symbolType?: string;
  parentClass?: string;
  docstring?: string;
}

interface BatchOptions {
  batchSize?: number;
  concurrency?: number;
  onProgress?: (completed: number, total: number) => void;
}
```

## Prompt Engineering

### Base Prompt Template

```
Summarize this {symbolType} in ONE short sentence (max 15 words).
Focus on WHAT it does, not HOW it's implemented.
Start with a verb (Returns, Validates, Creates, Handles, etc.).

{signature}

{bodyPreview}

{docstringIfAvailable}

Summary:
```

### Examples

**Input (TypeScript function)**:
```typescript
async function validateUserCredentials(
  username: string,
  password: string
): Promise<AuthResult> {
  const user = await db.users.findByUsername(username);
  if (!user) {
    return { success: false, error: 'User not found' };
  }
  const valid = await bcrypt.compare(password, user.passwordHash);
  return { success: valid, user: valid ? user : undefined };
}
```

**Output**: "Validates username and password against stored credentials."

**Input (Python method)**:
```python
def calculate_shipping_cost(self, weight: float, destination: str) -> Decimal:
    """Calculate shipping cost based on weight and destination zone."""
    zone = self._get_shipping_zone(destination)
    base_rate = self.rates[zone]
    return Decimal(base_rate) * Decimal(weight) * self.markup
```

**Output**: "Calculates shipping cost based on package weight and destination zone."

## Implementation

### File: `src/summarization/provider.ts`

```typescript
export interface SummarizationProvider {
  readonly name: string;
  readonly modelId: string;

  summarize(content: string, context?: SummarizationContext): Promise<string>;
  summarizeBatch(
    items: Array<{ content: string; context?: SummarizationContext }>,
    options?: BatchOptions
  ): Promise<string[]>;
  isAvailable(): Promise<boolean>;
}

export interface SummarizationContext {
  fileName?: string;
  language?: string;
  symbolType?: string;
  parentClass?: string;
  docstring?: string;
}
```

### File: `src/summarization/ollama.ts`

```typescript
import { SummarizationProvider, SummarizationContext, BatchOptions } from './provider';

interface OllamaConfig {
  baseUrl: string;
  model: string;
}

export class OllamaSummarizationProvider implements SummarizationProvider {
  readonly name = 'ollama';
  readonly modelId: string;

  constructor(private config: OllamaConfig) {
    this.modelId = `ollama:${config.model}`;
  }

  async summarize(content: string, context?: SummarizationContext): Promise<string> {
    const prompt = this.buildPrompt(content, context);

    const response = await fetch(`${this.config.baseUrl}/api/generate`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        model: this.config.model,
        prompt,
        stream: false,
        options: {
          temperature: 0.3,      // Low temperature for consistency
          num_predict: 50,       // Limit output length
          stop: ['\n', '.']      // Stop at end of sentence
        }
      })
    });

    if (!response.ok) {
      throw new Error(`Ollama summarization failed: ${response.statusText}`);
    }

    const data = await response.json();
    return this.cleanSummary(data.response);
  }

  async summarizeBatch(
    items: Array<{ content: string; context?: SummarizationContext }>,
    options?: BatchOptions
  ): Promise<string[]> {
    const concurrency = options?.concurrency || 5;
    const results: string[] = [];
    let completed = 0;

    // Process with concurrency limit
    const queue = [...items];
    const workers = Array(concurrency).fill(null).map(async () => {
      while (queue.length > 0) {
        const item = queue.shift();
        if (!item) break;

        const summary = await this.summarize(item.content, item.context);
        results.push(summary);
        completed++;
        options?.onProgress?.(completed, items.length);
      }
    });

    await Promise.all(workers);
    return results;
  }

  async isAvailable(): Promise<boolean> {
    try {
      const response = await fetch(`${this.config.baseUrl}/api/tags`);
      if (!response.ok) return false;

      const data = await response.json();
      return data.models?.some((m: { name: string }) =>
        m.name.startsWith(this.config.model)
      );
    } catch {
      return false;
    }
  }

  private buildPrompt(content: string, context?: SummarizationContext): string {
    const symbolType = context?.symbolType || 'code';
    const parts: string[] = [];

    parts.push(`Summarize this ${symbolType} in ONE short sentence (max 15 words).`);
    parts.push(`Focus on WHAT it does, not HOW.`);
    parts.push(`Start with a verb (Returns, Validates, Creates, Handles, etc.).`);
    parts.push('');

    if (context?.parentClass) {
      parts.push(`Class: ${context.parentClass}`);
    }

    parts.push(content.slice(0, 1000)); // Limit content length

    if (context?.docstring) {
      parts.push('');
      parts.push(`Docstring: ${context.docstring}`);
    }

    parts.push('');
    parts.push('Summary:');

    return parts.join('\n');
  }

  private cleanSummary(raw: string): string {
    return raw
      .trim()
      .replace(/^["']|["']$/g, '')  // Remove quotes
      .replace(/^Summary:\s*/i, '') // Remove prefix if echoed
      .replace(/\.$/, '')           // Remove trailing period
      .trim() + '.';                // Add period back consistently
  }
}
```

### File: `src/summarization/openai.ts`

```typescript
import { SummarizationProvider, SummarizationContext, BatchOptions } from './provider';

interface OpenAIConfig {
  apiKey: string;
  model: string;
}

export class OpenAISummarizationProvider implements SummarizationProvider {
  readonly name = 'openai';
  readonly modelId: string;

  constructor(private config: OpenAIConfig) {
    this.modelId = `openai:${config.model}`;
  }

  async summarize(content: string, context?: SummarizationContext): Promise<string> {
    const messages = this.buildMessages(content, context);

    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.config.apiKey}`
      },
      body: JSON.stringify({
        model: this.config.model,
        messages,
        temperature: 0.3,
        max_tokens: 50
      })
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(`OpenAI summarization failed: ${error.error?.message}`);
    }

    const data = await response.json();
    return this.cleanSummary(data.choices[0].message.content);
  }

  async summarizeBatch(
    items: Array<{ content: string; context?: SummarizationContext }>,
    options?: BatchOptions
  ): Promise<string[]> {
    // OpenAI doesn't have native batch for chat completions
    // Use parallel requests with concurrency limit
    const concurrency = options?.concurrency || 10;
    const results: string[] = new Array(items.length);
    let completed = 0;

    const processItem = async (index: number) => {
      const item = items[index];
      results[index] = await this.summarize(item.content, item.context);
      completed++;
      options?.onProgress?.(completed, items.length);
    };

    // Process in batches
    for (let i = 0; i < items.length; i += concurrency) {
      const batch = items.slice(i, i + concurrency).map((_, j) => processItem(i + j));
      await Promise.all(batch);
    }

    return results;
  }

  async isAvailable(): Promise<boolean> {
    try {
      const response = await fetch('https://api.openai.com/v1/models', {
        headers: { 'Authorization': `Bearer ${this.config.apiKey}` }
      });
      return response.ok;
    } catch {
      return false;
    }
  }

  private buildMessages(
    content: string,
    context?: SummarizationContext
  ): Array<{ role: string; content: string }> {
    const symbolType = context?.symbolType || 'code';

    const systemPrompt = `You are a code documentation assistant. Your task is to write concise, one-line summaries of code symbols.

Rules:
- Maximum 15 words
- Start with a verb (Returns, Validates, Creates, Handles, etc.)
- Focus on WHAT the code does, not HOW it's implemented
- Be specific but concise`;

    let userContent = `Summarize this ${symbolType}:\n\n${content.slice(0, 1500)}`;

    if (context?.docstring) {
      userContent += `\n\nExisting docstring: ${context.docstring}`;
    }

    return [
      { role: 'system', content: systemPrompt },
      { role: 'user', content: userContent }
    ];
  }

  private cleanSummary(raw: string): string {
    return raw
      .trim()
      .replace(/^["']|["']$/g, '')
      .replace(/\.$/, '')
      .trim() + '.';
  }
}
```

### File: `src/summarization/code-summarizer.ts`

```typescript
import { SummarizationProvider, SummarizationContext } from './provider';
import { Symbol } from '../ast/parser';
import { EntityStore } from '../entities/store';

interface SummarizeOptions {
  onProgress?: (completed: number, total: number) => void;
  skipExisting?: boolean;
}

export class CodeSummarizer {
  constructor(
    private provider: SummarizationProvider,
    private entityStore: EntityStore
  ) {}

  async summarizeSymbol(
    symbol: Symbol,
    fileContent?: string
  ): Promise<string> {
    // Use existing docstring if available and good
    if (symbol.docstring && this.isGoodDocstring(symbol.docstring)) {
      return this.extractFirstSentence(symbol.docstring);
    }

    const content = this.buildSymbolContent(symbol, fileContent);
    const context: SummarizationContext = {
      symbolType: symbol.type,
      language: this.detectLanguage(symbol),
      parentClass: this.getParentClass(symbol)
    };

    if (symbol.docstring) {
      context.docstring = symbol.docstring;
    }

    return this.provider.summarize(content, context);
  }

  async summarizeFile(
    filePath: string,
    symbols: Symbol[],
    fileContent: string,
    options?: SummarizeOptions
  ): Promise<Map<string, string>> {
    const summaries = new Map<string, string>();
    const toSummarize: Array<{ symbol: Symbol; content: string }> = [];

    // Collect symbols needing summarization
    for (const symbol of this.flattenSymbols(symbols)) {
      if (options?.skipExisting) {
        const existing = await this.entityStore.getByQualifiedName(symbol.qualifiedName);
        if (existing?.summary) {
          summaries.set(symbol.qualifiedName, existing.summary);
          continue;
        }
      }

      // Use docstring if good
      if (symbol.docstring && this.isGoodDocstring(symbol.docstring)) {
        summaries.set(symbol.qualifiedName, this.extractFirstSentence(symbol.docstring));
        continue;
      }

      toSummarize.push({
        symbol,
        content: this.buildSymbolContent(symbol, fileContent)
      });
    }

    if (toSummarize.length === 0) {
      return summaries;
    }

    // Batch summarize
    const items = toSummarize.map(({ symbol, content }) => ({
      content,
      context: {
        symbolType: symbol.type,
        parentClass: this.getParentClass(symbol),
        docstring: symbol.docstring
      }
    }));

    const results = await this.provider.summarizeBatch(items, {
      onProgress: options?.onProgress
    });

    // Map results back to symbols
    for (let i = 0; i < toSummarize.length; i++) {
      summaries.set(toSummarize[i].symbol.qualifiedName, results[i]);
    }

    return summaries;
  }

  private buildSymbolContent(symbol: Symbol, fileContent?: string): string {
    // For functions/methods, include signature + limited body
    if (symbol.signature) {
      if (fileContent && symbol.startLine && symbol.endLine) {
        const lines = fileContent.split('\n');
        const body = lines.slice(symbol.startLine - 1, symbol.endLine).join('\n');
        // Limit to first 500 chars of body
        return body.slice(0, 500);
      }
      return symbol.signature;
    }

    // For classes, include name + method signatures
    if (symbol.type === 'class' && symbol.children) {
      const methodSigs = symbol.children
        .filter(c => c.type === 'method')
        .map(m => m.signature || m.name)
        .slice(0, 5)  // Limit to first 5 methods
        .join('\n  ');
      return `class ${symbol.name} {\n  ${methodSigs}\n}`;
    }

    return symbol.name;
  }

  private flattenSymbols(symbols: Symbol[]): Symbol[] {
    const result: Symbol[] = [];
    for (const symbol of symbols) {
      result.push(symbol);
      if (symbol.children) {
        result.push(...symbol.children);
      }
    }
    return result;
  }

  private isGoodDocstring(docstring: string): boolean {
    // Check if docstring is actually useful
    const clean = docstring.trim().toLowerCase();
    if (clean.length < 10) return false;
    if (clean.startsWith('todo')) return false;
    if (clean.startsWith('fixme')) return false;
    if (clean === 'constructor') return false;
    return true;
  }

  private extractFirstSentence(text: string): string {
    const match = text.match(/^[^.!?]+[.!?]/);
    if (match) {
      return match[0].trim();
    }
    // No sentence end found, take first 100 chars
    return text.slice(0, 100).trim() + (text.length > 100 ? '...' : '');
  }

  private detectLanguage(symbol: Symbol): string {
    if (symbol.qualifiedName.includes('.ts')) return 'typescript';
    if (symbol.qualifiedName.includes('.py')) return 'python';
    if (symbol.qualifiedName.includes('.go')) return 'go';
    return 'unknown';
  }

  private getParentClass(symbol: Symbol): string | undefined {
    // Extract from qualified name: file::Class::method -> Class
    const parts = symbol.qualifiedName.split('::');
    if (parts.length >= 3 && symbol.type === 'method') {
      return parts[parts.length - 2];
    }
    return undefined;
  }
}
```

### File: `src/summarization/factory.ts`

```typescript
import { SummarizationProvider } from './provider';
import { OllamaSummarizationProvider } from './ollama';
import { OpenAISummarizationProvider } from './openai';

interface ProviderConfig {
  provider: 'ollama' | 'openai' | 'anthropic';
  model: string;
  baseUrl?: string;
  apiKey?: string;
}

export class SummarizationProviderFactory {
  static create(config: ProviderConfig): SummarizationProvider {
    switch (config.provider) {
      case 'ollama':
        return new OllamaSummarizationProvider({
          baseUrl: config.baseUrl || 'http://localhost:11434',
          model: config.model
        });
      case 'openai':
        if (!config.apiKey) {
          throw new Error('OpenAI API key required');
        }
        return new OpenAISummarizationProvider({
          apiKey: config.apiKey,
          model: config.model
        });
      default:
        throw new Error(`Unknown provider: ${config.provider}`);
    }
  }

  static async createWithFallback(
    primary: ProviderConfig,
    fallback: ProviderConfig
  ): Promise<SummarizationProvider> {
    const primaryProvider = this.create(primary);
    if (await primaryProvider.isAvailable()) {
      return primaryProvider;
    }

    console.warn(`Primary summarization provider unavailable, using fallback`);
    return this.create(fallback);
  }
}
```

## Recommended Models

| Use Case | Provider | Model | Notes |
|----------|----------|-------|-------|
| Local (fast) | Ollama | qwen2.5-coder:7b | Good code understanding |
| Local (quality) | Ollama | codellama:13b | Better accuracy |
| Cloud (cheap) | OpenAI | gpt-4o-mini | Fast, inexpensive |
| Cloud (quality) | OpenAI | gpt-4o | Best accuracy |

## Tasks

- [ ] Implement SummarizationProvider interface
- [ ] Implement OllamaSummarizationProvider
- [ ] Implement OpenAISummarizationProvider
- [ ] Implement CodeSummarizer
- [ ] Implement SummarizationProviderFactory
- [ ] Tune prompts for quality
- [ ] Add rate limiting for cloud providers
- [ ] Add caching for repeated summarizations
- [ ] Write unit tests
- [ ] Evaluate summary quality

## Testing

```typescript
describe('OllamaSummarizationProvider', () => {
  it('should generate concise summary');
  it('should handle batch summarization');
  it('should respect concurrency limits');
  it('should detect availability');
});

describe('CodeSummarizer', () => {
  it('should use existing docstring if good');
  it('should skip already summarized symbols');
  it('should flatten nested symbols');
  it('should extract first sentence from docstring');
});
```

## Notes

- Low temperature (0.3) ensures consistent, deterministic summaries
- Limit content length to avoid context overflow
- Good docstrings should be reused rather than regenerated
- Consider caching summaries by content hash to avoid re-summarizing unchanged code
