# F2.1 AST Parsing

**Phase**: 2 - Code Intelligence
**Priority**: High
**Dependencies**: F1.3 Entity Storage

## Goal

Extract code structure using tree-sitter for multi-language support, capturing symbols up to method-level detail.

## Overview

AST parsing is the foundation of code intelligence. Using tree-sitter, we can parse code from multiple languages into a uniform AST, then extract:
- Classes, interfaces, types
- Functions and methods
- Parameters and return types
- Decorators/annotations
- Docstrings
- Import/export statements

## Data Model

```typescript
interface Symbol {
  type: SymbolType;
  name: string;
  qualifiedName: string;          // Full path: file::class::method
  signature?: string;             // Full signature for functions
  parameters?: Parameter[];
  returnType?: string;
  decorators?: string[];
  visibility?: 'public' | 'private' | 'protected';
  isStatic?: boolean;
  isAsync?: boolean;
  isExported?: boolean;
  startLine: number;
  endLine: number;
  docstring?: string;
  children?: Symbol[];            // For classes containing methods
}

type SymbolType =
  | 'class'
  | 'interface'
  | 'type'
  | 'function'
  | 'method'
  | 'property'
  | 'variable'
  | 'enum'
  | 'namespace'
  | 'module';

interface Parameter {
  name: string;
  type?: string;
  defaultValue?: string;
  isOptional?: boolean;
  isRest?: boolean;
}

interface ImportStatement {
  source: string;                 // Module path
  specifiers: ImportSpecifier[];
  isDefault?: boolean;
  isNamespace?: boolean;
  startLine: number;
}

interface ImportSpecifier {
  name: string;
  alias?: string;
}

interface ParseResult {
  filePath: string;
  language: string;
  symbols: Symbol[];
  imports: ImportStatement[];
  exports: string[];
  errors: ParseError[];
}
```

## Supported Languages

| Language | File Extensions | tree-sitter Grammar |
|----------|----------------|---------------------|
| TypeScript | .ts, .tsx | tree-sitter-typescript |
| JavaScript | .js, .jsx, .mjs | tree-sitter-javascript |
| Python | .py | tree-sitter-python |
| Go | .go | tree-sitter-go |
| Rust | .rs | tree-sitter-rust |
| Java | .java | tree-sitter-java |
| C | .c, .h | tree-sitter-c |
| C++ | .cpp, .hpp, .cc | tree-sitter-cpp |

## Implementation

### File: `src/ast/parser.ts`

```typescript
import Parser from 'tree-sitter';
import { readFile } from 'fs/promises';
import { extname } from 'path';

export class ASTParser {
  private parsers: Map<string, Parser> = new Map();
  private languageMap: Map<string, string> = new Map([
    ['.ts', 'typescript'],
    ['.tsx', 'typescript'],
    ['.js', 'javascript'],
    ['.jsx', 'javascript'],
    ['.mjs', 'javascript'],
    ['.py', 'python'],
    ['.go', 'go'],
    ['.rs', 'rust'],
    ['.java', 'java'],
    ['.c', 'c'],
    ['.h', 'c'],
    ['.cpp', 'cpp'],
    ['.hpp', 'cpp'],
    ['.cc', 'cpp']
  ]);

  constructor() {
    this.initializeParsers();
  }

  private async initializeParsers(): Promise<void> {
    // Lazy-load parsers as needed
  }

  private async getParser(language: string): Promise<Parser> {
    if (!this.parsers.has(language)) {
      const parser = new Parser();
      const lang = await this.loadLanguage(language);
      parser.setLanguage(lang);
      this.parsers.set(language, parser);
    }
    return this.parsers.get(language)!;
  }

  private async loadLanguage(language: string): Promise<unknown> {
    switch (language) {
      case 'typescript':
        return require('tree-sitter-typescript').typescript;
      case 'javascript':
        return require('tree-sitter-javascript');
      case 'python':
        return require('tree-sitter-python');
      case 'go':
        return require('tree-sitter-go');
      case 'rust':
        return require('tree-sitter-rust');
      case 'java':
        return require('tree-sitter-java');
      case 'c':
        return require('tree-sitter-c');
      case 'cpp':
        return require('tree-sitter-cpp');
      default:
        throw new Error(`Unsupported language: ${language}`);
    }
  }

  getLanguage(filePath: string): string | null {
    const ext = extname(filePath).toLowerCase();
    return this.languageMap.get(ext) || null;
  }

  async parseFile(filePath: string): Promise<ParseResult> {
    const language = this.getLanguage(filePath);
    if (!language) {
      throw new Error(`Unsupported file type: ${filePath}`);
    }

    const content = await readFile(filePath, 'utf-8');
    return this.parseContent(content, language, filePath);
  }

  async parseContent(
    content: string,
    language: string,
    filePath?: string
  ): Promise<ParseResult> {
    const parser = await this.getParser(language);
    const tree = parser.parse(content);

    const extractor = this.getExtractor(language);
    const symbols = extractor.extractSymbols(tree.rootNode, filePath);
    const imports = extractor.extractImports(tree.rootNode);
    const exports = extractor.extractExports(tree.rootNode);
    const errors = this.extractErrors(tree);

    return {
      filePath: filePath || '<inline>',
      language,
      symbols,
      imports,
      exports,
      errors
    };
  }

  private getExtractor(language: string): LanguageExtractor {
    switch (language) {
      case 'typescript':
      case 'javascript':
        return new TypeScriptExtractor();
      case 'python':
        return new PythonExtractor();
      case 'go':
        return new GoExtractor();
      default:
        return new GenericExtractor();
    }
  }

  private extractErrors(tree: Parser.Tree): ParseError[] {
    const errors: ParseError[] = [];
    const cursor = tree.walk();

    const visit = (): void => {
      if (cursor.nodeType === 'ERROR') {
        errors.push({
          message: 'Parse error',
          startLine: cursor.startPosition.row + 1,
          endLine: cursor.endPosition.row + 1
        });
      }
      if (cursor.gotoFirstChild()) {
        do {
          visit();
        } while (cursor.gotoNextSibling());
        cursor.gotoParent();
      }
    };

    visit();
    return errors;
  }
}
```

### File: `src/ast/extractors/base.ts`

```typescript
import Parser from 'tree-sitter';

export interface LanguageExtractor {
  extractSymbols(node: Parser.SyntaxNode, filePath?: string): Symbol[];
  extractImports(node: Parser.SyntaxNode): ImportStatement[];
  extractExports(node: Parser.SyntaxNode): string[];
}

export abstract class BaseExtractor implements LanguageExtractor {
  abstract extractSymbols(node: Parser.SyntaxNode, filePath?: string): Symbol[];
  abstract extractImports(node: Parser.SyntaxNode): ImportStatement[];
  abstract extractExports(node: Parser.SyntaxNode): string[];

  protected getNodeText(node: Parser.SyntaxNode): string {
    return node.text;
  }

  protected findChild(
    node: Parser.SyntaxNode,
    type: string
  ): Parser.SyntaxNode | null {
    return node.children.find(c => c.type === type) || null;
  }

  protected findChildren(
    node: Parser.SyntaxNode,
    type: string
  ): Parser.SyntaxNode[] {
    return node.children.filter(c => c.type === type);
  }

  protected getDocstring(node: Parser.SyntaxNode): string | undefined {
    // Look for comment node immediately before
    const parent = node.parent;
    if (!parent) return undefined;

    const index = parent.children.indexOf(node);
    if (index > 0) {
      const prev = parent.children[index - 1];
      if (prev.type === 'comment' || prev.type === 'block_comment') {
        return this.cleanDocstring(prev.text);
      }
    }
    return undefined;
  }

  protected cleanDocstring(text: string): string {
    return text
      .replace(/^\/\*\*?|\*\/$/g, '')  // Remove /* */ or /** */
      .replace(/^\/\/\s?/gm, '')        // Remove //
      .replace(/^\s*\*\s?/gm, '')       // Remove leading *
      .trim();
  }

  protected buildQualifiedName(
    filePath: string | undefined,
    ...parts: string[]
  ): string {
    const base = filePath || '<inline>';
    return [base, ...parts.filter(Boolean)].join('::');
  }
}
```

### File: `src/ast/extractors/typescript.ts`

```typescript
import Parser from 'tree-sitter';
import { BaseExtractor } from './base';

export class TypeScriptExtractor extends BaseExtractor {
  extractSymbols(node: Parser.SyntaxNode, filePath?: string): Symbol[] {
    const symbols: Symbol[] = [];
    this.visitNode(node, symbols, filePath, []);
    return symbols;
  }

  private visitNode(
    node: Parser.SyntaxNode,
    symbols: Symbol[],
    filePath: string | undefined,
    context: string[]
  ): void {
    switch (node.type) {
      case 'class_declaration':
      case 'abstract_class_declaration':
        this.extractClass(node, symbols, filePath, context);
        break;
      case 'interface_declaration':
        this.extractInterface(node, symbols, filePath, context);
        break;
      case 'type_alias_declaration':
        this.extractTypeAlias(node, symbols, filePath, context);
        break;
      case 'function_declaration':
        this.extractFunction(node, symbols, filePath, context);
        break;
      case 'lexical_declaration':
      case 'variable_declaration':
        this.extractVariables(node, symbols, filePath, context);
        break;
      case 'enum_declaration':
        this.extractEnum(node, symbols, filePath, context);
        break;
    }

    // Recurse into children
    for (const child of node.children) {
      this.visitNode(child, symbols, filePath, context);
    }
  }

  private extractClass(
    node: Parser.SyntaxNode,
    symbols: Symbol[],
    filePath: string | undefined,
    context: string[]
  ): void {
    const nameNode = this.findChild(node, 'type_identifier');
    if (!nameNode) return;

    const name = nameNode.text;
    const qualifiedName = this.buildQualifiedName(filePath, ...context, name);
    const docstring = this.getDocstring(node);

    const methods: Symbol[] = [];
    const properties: Symbol[] = [];

    // Extract class body
    const body = this.findChild(node, 'class_body');
    if (body) {
      for (const member of body.children) {
        if (member.type === 'method_definition') {
          const method = this.extractMethod(member, filePath, [...context, name]);
          if (method) methods.push(method);
        } else if (member.type === 'public_field_definition') {
          const prop = this.extractProperty(member, filePath, [...context, name]);
          if (prop) properties.push(prop);
        }
      }
    }

    // Check for decorators
    const decorators = this.extractDecorators(node);

    // Check if exported
    const isExported = this.isExported(node);

    symbols.push({
      type: 'class',
      name,
      qualifiedName,
      docstring,
      decorators,
      isExported,
      startLine: node.startPosition.row + 1,
      endLine: node.endPosition.row + 1,
      children: [...methods, ...properties]
    });
  }

  private extractMethod(
    node: Parser.SyntaxNode,
    filePath: string | undefined,
    context: string[]
  ): Symbol | null {
    const nameNode = this.findChild(node, 'property_identifier');
    if (!nameNode) return null;

    const name = nameNode.text;
    const qualifiedName = this.buildQualifiedName(filePath, ...context, name);
    const parameters = this.extractParameters(node);
    const returnType = this.extractReturnType(node);
    const signature = this.buildSignature(name, parameters, returnType);
    const docstring = this.getDocstring(node);

    // Check modifiers
    const isStatic = node.children.some(c => c.type === 'static');
    const isAsync = node.children.some(c => c.type === 'async');
    const visibility = this.extractVisibility(node);

    return {
      type: 'method',
      name,
      qualifiedName,
      signature,
      parameters,
      returnType,
      docstring,
      isStatic,
      isAsync,
      visibility,
      startLine: node.startPosition.row + 1,
      endLine: node.endPosition.row + 1
    };
  }

  private extractFunction(
    node: Parser.SyntaxNode,
    symbols: Symbol[],
    filePath: string | undefined,
    context: string[]
  ): void {
    const nameNode = this.findChild(node, 'identifier');
    if (!nameNode) return;

    const name = nameNode.text;
    const qualifiedName = this.buildQualifiedName(filePath, ...context, name);
    const parameters = this.extractParameters(node);
    const returnType = this.extractReturnType(node);
    const signature = this.buildSignature(name, parameters, returnType);
    const docstring = this.getDocstring(node);
    const isAsync = node.children.some(c => c.type === 'async');
    const isExported = this.isExported(node);

    symbols.push({
      type: 'function',
      name,
      qualifiedName,
      signature,
      parameters,
      returnType,
      docstring,
      isAsync,
      isExported,
      startLine: node.startPosition.row + 1,
      endLine: node.endPosition.row + 1
    });
  }

  private extractParameters(node: Parser.SyntaxNode): Parameter[] {
    const params: Parameter[] = [];
    const paramsNode = this.findChild(node, 'formal_parameters');
    if (!paramsNode) return params;

    for (const child of paramsNode.children) {
      if (child.type === 'required_parameter' || child.type === 'optional_parameter') {
        const nameNode = this.findChild(child, 'identifier');
        const typeNode = this.findChild(child, 'type_annotation');

        params.push({
          name: nameNode?.text || 'unknown',
          type: typeNode ? this.extractTypeText(typeNode) : undefined,
          isOptional: child.type === 'optional_parameter'
        });
      } else if (child.type === 'rest_parameter') {
        const nameNode = this.findChild(child, 'identifier');
        params.push({
          name: nameNode?.text || 'args',
          isRest: true
        });
      }
    }

    return params;
  }

  private extractReturnType(node: Parser.SyntaxNode): string | undefined {
    const typeAnnotation = node.children.find(
      c => c.type === 'type_annotation' && c.previousSibling?.type === ')'
    );
    return typeAnnotation ? this.extractTypeText(typeAnnotation) : undefined;
  }

  private extractTypeText(node: Parser.SyntaxNode): string {
    // Skip the ': ' prefix
    const typeNode = node.children.find(c => c.type !== ':');
    return typeNode?.text || node.text.replace(/^:\s*/, '');
  }

  private buildSignature(
    name: string,
    params: Parameter[],
    returnType?: string
  ): string {
    const paramStr = params
      .map(p => {
        let s = p.name;
        if (p.isOptional) s += '?';
        if (p.isRest) s = '...' + s;
        if (p.type) s += ': ' + p.type;
        return s;
      })
      .join(', ');

    let sig = `${name}(${paramStr})`;
    if (returnType) sig += `: ${returnType}`;
    return sig;
  }

  private extractDecorators(node: Parser.SyntaxNode): string[] {
    const decorators: string[] = [];
    let prev = node.previousSibling;
    while (prev && prev.type === 'decorator') {
      decorators.unshift(prev.text);
      prev = prev.previousSibling;
    }
    return decorators;
  }

  private extractVisibility(
    node: Parser.SyntaxNode
  ): 'public' | 'private' | 'protected' | undefined {
    for (const child of node.children) {
      if (child.type === 'accessibility_modifier') {
        return child.text as 'public' | 'private' | 'protected';
      }
    }
    return undefined;
  }

  private isExported(node: Parser.SyntaxNode): boolean {
    return node.parent?.type === 'export_statement' ||
           node.children.some(c => c.type === 'export');
  }

  extractImports(node: Parser.SyntaxNode): ImportStatement[] {
    const imports: ImportStatement[] = [];

    const visit = (n: Parser.SyntaxNode): void => {
      if (n.type === 'import_statement') {
        const imp = this.parseImport(n);
        if (imp) imports.push(imp);
      }
      for (const child of n.children) {
        visit(child);
      }
    };

    visit(node);
    return imports;
  }

  private parseImport(node: Parser.SyntaxNode): ImportStatement | null {
    const sourceNode = this.findChild(node, 'string');
    if (!sourceNode) return null;

    const source = sourceNode.text.replace(/['"]/g, '');
    const specifiers: ImportSpecifier[] = [];
    let isDefault = false;
    let isNamespace = false;

    const clause = this.findChild(node, 'import_clause');
    if (clause) {
      for (const child of clause.children) {
        if (child.type === 'identifier') {
          // Default import
          specifiers.push({ name: child.text });
          isDefault = true;
        } else if (child.type === 'namespace_import') {
          // import * as X
          const asNode = this.findChild(child, 'identifier');
          if (asNode) {
            specifiers.push({ name: '*', alias: asNode.text });
            isNamespace = true;
          }
        } else if (child.type === 'named_imports') {
          // import { X, Y as Z }
          for (const spec of child.children) {
            if (spec.type === 'import_specifier') {
              const name = spec.children[0]?.text;
              const alias = spec.children.find(c => c.type === 'identifier' && c !== spec.children[0])?.text;
              if (name) specifiers.push({ name, alias });
            }
          }
        }
      }
    }

    return {
      source,
      specifiers,
      isDefault,
      isNamespace,
      startLine: node.startPosition.row + 1
    };
  }

  extractExports(node: Parser.SyntaxNode): string[] {
    const exports: string[] = [];

    const visit = (n: Parser.SyntaxNode): void => {
      if (n.type === 'export_statement') {
        // Named export
        const decl = n.children.find(c =>
          ['class_declaration', 'function_declaration', 'lexical_declaration'].includes(c.type)
        );
        if (decl) {
          const nameNode = this.findChild(decl, 'identifier') ||
                          this.findChild(decl, 'type_identifier');
          if (nameNode) exports.push(nameNode.text);
        }

        // Export clause: export { X, Y }
        const clause = this.findChild(n, 'export_clause');
        if (clause) {
          for (const spec of clause.children) {
            if (spec.type === 'export_specifier') {
              const name = spec.children[0]?.text;
              if (name) exports.push(name);
            }
          }
        }
      }
      for (const child of n.children) {
        visit(child);
      }
    };

    visit(node);
    return exports;
  }
}
```

### File: `src/ast/extractors/python.ts`

```typescript
import Parser from 'tree-sitter';
import { BaseExtractor } from './base';

export class PythonExtractor extends BaseExtractor {
  extractSymbols(node: Parser.SyntaxNode, filePath?: string): Symbol[] {
    const symbols: Symbol[] = [];
    this.visitNode(node, symbols, filePath, []);
    return symbols;
  }

  private visitNode(
    node: Parser.SyntaxNode,
    symbols: Symbol[],
    filePath: string | undefined,
    context: string[]
  ): void {
    switch (node.type) {
      case 'class_definition':
        this.extractClass(node, symbols, filePath, context);
        break;
      case 'function_definition':
        if (context.length === 0) {
          // Top-level function
          this.extractFunction(node, symbols, filePath, context);
        }
        break;
    }

    // Only recurse at module level
    if (context.length === 0) {
      for (const child of node.children) {
        this.visitNode(child, symbols, filePath, context);
      }
    }
  }

  private extractClass(
    node: Parser.SyntaxNode,
    symbols: Symbol[],
    filePath: string | undefined,
    context: string[]
  ): void {
    const nameNode = this.findChild(node, 'identifier');
    if (!nameNode) return;

    const name = nameNode.text;
    const qualifiedName = this.buildQualifiedName(filePath, ...context, name);
    const docstring = this.extractPythonDocstring(node);
    const decorators = this.extractPythonDecorators(node);

    const methods: Symbol[] = [];
    const body = this.findChild(node, 'block');
    if (body) {
      for (const child of body.children) {
        if (child.type === 'function_definition') {
          const method = this.extractMethod(child, filePath, [...context, name]);
          if (method) methods.push(method);
        }
      }
    }

    symbols.push({
      type: 'class',
      name,
      qualifiedName,
      docstring,
      decorators,
      startLine: node.startPosition.row + 1,
      endLine: node.endPosition.row + 1,
      children: methods
    });
  }

  private extractMethod(
    node: Parser.SyntaxNode,
    filePath: string | undefined,
    context: string[]
  ): Symbol | null {
    const nameNode = this.findChild(node, 'identifier');
    if (!nameNode) return null;

    const name = nameNode.text;
    const qualifiedName = this.buildQualifiedName(filePath, ...context, name);
    const parameters = this.extractPythonParameters(node);
    const returnType = this.extractPythonReturnType(node);
    const signature = this.buildPythonSignature(name, parameters, returnType);
    const docstring = this.extractPythonDocstring(node);
    const decorators = this.extractPythonDecorators(node);

    const isStatic = decorators.includes('@staticmethod');
    const isAsync = node.children.some(c => c.type === 'async');

    // Determine visibility from name convention
    const visibility = name.startsWith('__') && !name.endsWith('__')
      ? 'private'
      : name.startsWith('_')
        ? 'protected'
        : 'public';

    return {
      type: 'method',
      name,
      qualifiedName,
      signature,
      parameters,
      returnType,
      docstring,
      decorators,
      isStatic,
      isAsync,
      visibility,
      startLine: node.startPosition.row + 1,
      endLine: node.endPosition.row + 1
    };
  }

  private extractFunction(
    node: Parser.SyntaxNode,
    symbols: Symbol[],
    filePath: string | undefined,
    context: string[]
  ): void {
    const nameNode = this.findChild(node, 'identifier');
    if (!nameNode) return;

    const name = nameNode.text;
    const qualifiedName = this.buildQualifiedName(filePath, ...context, name);
    const parameters = this.extractPythonParameters(node);
    const returnType = this.extractPythonReturnType(node);
    const signature = this.buildPythonSignature(name, parameters, returnType);
    const docstring = this.extractPythonDocstring(node);
    const decorators = this.extractPythonDecorators(node);
    const isAsync = node.children.some(c => c.type === 'async');

    symbols.push({
      type: 'function',
      name,
      qualifiedName,
      signature,
      parameters,
      returnType,
      docstring,
      decorators,
      isAsync,
      startLine: node.startPosition.row + 1,
      endLine: node.endPosition.row + 1
    });
  }

  private extractPythonParameters(node: Parser.SyntaxNode): Parameter[] {
    const params: Parameter[] = [];
    const paramsNode = this.findChild(node, 'parameters');
    if (!paramsNode) return params;

    for (const child of paramsNode.children) {
      if (child.type === 'identifier') {
        params.push({ name: child.text });
      } else if (child.type === 'typed_parameter') {
        const nameNode = this.findChild(child, 'identifier');
        const typeNode = this.findChild(child, 'type');
        params.push({
          name: nameNode?.text || 'unknown',
          type: typeNode?.text
        });
      } else if (child.type === 'default_parameter') {
        const nameNode = this.findChild(child, 'identifier');
        params.push({
          name: nameNode?.text || 'unknown',
          isOptional: true
        });
      } else if (child.type === 'list_splat_pattern') {
        params.push({ name: child.text, isRest: true });
      }
    }

    return params;
  }

  private extractPythonReturnType(node: Parser.SyntaxNode): string | undefined {
    const returnType = node.children.find(c => c.type === 'type');
    return returnType?.text;
  }

  private extractPythonDocstring(node: Parser.SyntaxNode): string | undefined {
    const body = this.findChild(node, 'block');
    if (!body) return undefined;

    const firstStmt = body.children.find(c => c.type === 'expression_statement');
    if (firstStmt) {
      const strNode = this.findChild(firstStmt, 'string');
      if (strNode) {
        return strNode.text.replace(/^['\"]{1,3}|['\"]{1,3}$/g, '').trim();
      }
    }
    return undefined;
  }

  private extractPythonDecorators(node: Parser.SyntaxNode): string[] {
    const decorators: string[] = [];
    let prev = node.previousSibling;
    while (prev && prev.type === 'decorator') {
      decorators.unshift(prev.text);
      prev = prev.previousSibling;
    }
    return decorators;
  }

  private buildPythonSignature(
    name: string,
    params: Parameter[],
    returnType?: string
  ): string {
    const paramStr = params
      .map(p => {
        let s = p.name;
        if (p.isRest) s = '*' + s;
        if (p.type) s += ': ' + p.type;
        return s;
      })
      .join(', ');

    let sig = `def ${name}(${paramStr})`;
    if (returnType) sig += ` -> ${returnType}`;
    return sig;
  }

  extractImports(node: Parser.SyntaxNode): ImportStatement[] {
    const imports: ImportStatement[] = [];

    const visit = (n: Parser.SyntaxNode): void => {
      if (n.type === 'import_statement' || n.type === 'import_from_statement') {
        const imp = this.parsePythonImport(n);
        if (imp) imports.push(imp);
      }
      for (const child of n.children) {
        visit(child);
      }
    };

    visit(node);
    return imports;
  }

  private parsePythonImport(node: Parser.SyntaxNode): ImportStatement | null {
    if (node.type === 'import_statement') {
      // import X, Y
      const names = this.findChildren(node, 'dotted_name');
      return {
        source: names[0]?.text || '',
        specifiers: names.map(n => ({ name: n.text })),
        startLine: node.startPosition.row + 1
      };
    } else {
      // from X import Y, Z
      const moduleNode = this.findChild(node, 'dotted_name') ||
                        this.findChild(node, 'relative_import');
      const source = moduleNode?.text || '';
      const specifiers: ImportSpecifier[] = [];

      for (const child of node.children) {
        if (child.type === 'dotted_name' && child !== moduleNode) {
          specifiers.push({ name: child.text });
        } else if (child.type === 'aliased_import') {
          const name = this.findChild(child, 'dotted_name')?.text;
          const alias = this.findChild(child, 'identifier')?.text;
          if (name) specifiers.push({ name, alias });
        }
      }

      return {
        source,
        specifiers,
        startLine: node.startPosition.row + 1
      };
    }
  }

  extractExports(node: Parser.SyntaxNode): string[] {
    // Python doesn't have explicit exports; __all__ is convention
    const exports: string[] = [];

    const visit = (n: Parser.SyntaxNode): void => {
      if (n.type === 'assignment') {
        const left = n.children[0];
        if (left?.text === '__all__') {
          const list = this.findChild(n, 'list');
          if (list) {
            for (const child of list.children) {
              if (child.type === 'string') {
                exports.push(child.text.replace(/['"]/g, ''));
              }
            }
          }
        }
      }
      for (const child of n.children) {
        visit(child);
      }
    };

    visit(node);
    return exports;
  }
}
```

## Dependencies

```json
{
  "tree-sitter": "^0.20.0",
  "tree-sitter-typescript": "^0.20.0",
  "tree-sitter-javascript": "^0.20.0",
  "tree-sitter-python": "^0.20.0",
  "tree-sitter-go": "^0.20.0",
  "tree-sitter-rust": "^0.20.0",
  "tree-sitter-java": "^0.20.0",
  "tree-sitter-c": "^0.20.0",
  "tree-sitter-cpp": "^0.20.0"
}
```

## Tasks

- [ ] Install tree-sitter and language grammars
- [ ] Implement base ASTParser class
- [ ] Implement TypeScriptExtractor
- [ ] Implement PythonExtractor
- [ ] Implement GoExtractor
- [ ] Implement GenericExtractor (fallback)
- [ ] Add support for remaining languages
- [ ] Handle edge cases (decorators, generics, etc.)
- [ ] Write unit tests for each language
- [ ] Test with real codebases

## Testing

```typescript
describe('ASTParser', () => {
  describe('TypeScript', () => {
    it('should extract classes with methods');
    it('should extract interfaces');
    it('should extract functions with parameters');
    it('should extract type annotations');
    it('should extract decorators');
    it('should extract imports');
    it('should extract exports');
  });

  describe('Python', () => {
    it('should extract classes with methods');
    it('should extract functions');
    it('should extract docstrings');
    it('should extract decorators');
    it('should extract type hints');
    it('should extract imports');
  });
});
```

## Notes

- tree-sitter grammars need to be compiled for the target platform
- Consider using web-tree-sitter for cross-platform compatibility
- Parser initialization is lazy to avoid loading unused languages
- Docstring extraction varies by language convention
