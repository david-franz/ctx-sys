# F2.4 Relationship Extraction

**Phase**: 2 - Code Intelligence
**Priority**: High
**Dependencies**: F2.1 AST Parsing, F1.3 Entity Storage

## Goal

Extract code relationships (calls, imports, inheritance) from AST to build the knowledge graph.

## Overview

Relationship extraction analyzes parsed code to identify connections between entities:
- **Import relationships**: Which files depend on which
- **Call relationships**: Which functions call which
- **Inheritance**: Class hierarchies
- **Type usage**: What types functions use

These relationships enable graph-based context retrieval.

## Relationship Types

| Relationship | Source | Target | Description |
|-------------|--------|--------|-------------|
| `IMPORTS` | File | File | File imports another file/module |
| `CALLS` | Function/Method | Function/Method | Function calls another |
| `EXTENDS` | Class | Class | Class inheritance |
| `IMPLEMENTS` | Class | Interface | Interface implementation |
| `USES_TYPE` | Function | Type/Interface | Function uses a type |
| `CONTAINS` | File/Class | Symbol | Containment hierarchy |
| `EXPORTS` | File | Symbol | File exports symbol |
| `INSTANTIATES` | Function | Class | Creates instance of class |

## Data Model

```typescript
interface Relationship {
  id: string;
  sourceId: string;
  targetId: string;
  relationship: RelationshipType;
  weight: number;              // Strength/importance
  metadata?: {
    line?: number;             // Where the relationship occurs
    isDirectImport?: boolean;  // vs re-export
    callCount?: number;        // How many times called
  };
  createdAt: Date;
}

type RelationshipType =
  | 'IMPORTS'
  | 'CALLS'
  | 'EXTENDS'
  | 'IMPLEMENTS'
  | 'USES_TYPE'
  | 'CONTAINS'
  | 'EXPORTS'
  | 'INSTANTIATES';

interface RelationshipQuery {
  entityId: string;
  direction: 'in' | 'out' | 'both';
  types?: RelationshipType[];
  depth?: number;
}
```

## Implementation

### File: `src/relationships/store.ts`

```typescript
import { DatabaseConnection } from '../db/connection';
import { generateId } from '../utils/id';

export class RelationshipStore {
  private tableName: string;

  constructor(
    private db: DatabaseConnection,
    private projectId: string
  ) {
    this.tableName = `${projectId}_relationships`;
  }

  async create(rel: Omit<Relationship, 'id' | 'createdAt'>): Promise<Relationship> {
    const id = generateId();

    this.db.run(
      `INSERT INTO ${this.tableName}
       (id, source_id, target_id, relationship, weight, metadata)
       VALUES (?, ?, ?, ?, ?, ?)`,
      [
        id,
        rel.sourceId,
        rel.targetId,
        rel.relationship,
        rel.weight || 1.0,
        JSON.stringify(rel.metadata || {})
      ]
    );

    return this.get(id)!;
  }

  async createMany(rels: Array<Omit<Relationship, 'id' | 'createdAt'>>): Promise<number> {
    return this.db.transaction(() => {
      for (const rel of rels) {
        this.db.run(
          `INSERT OR IGNORE INTO ${this.tableName}
           (id, source_id, target_id, relationship, weight, metadata)
           VALUES (?, ?, ?, ?, ?, ?)`,
          [
            generateId(),
            rel.sourceId,
            rel.targetId,
            rel.relationship,
            rel.weight || 1.0,
            JSON.stringify(rel.metadata || {})
          ]
        );
      }
      return rels.length;
    });
  }

  async get(id: string): Promise<Relationship | null> {
    const row = this.db.get<RelationshipRow>(
      `SELECT * FROM ${this.tableName} WHERE id = ?`,
      [id]
    );
    return row ? this.rowToRelationship(row) : null;
  }

  async getForEntity(
    entityId: string,
    direction: 'in' | 'out' | 'both' = 'both',
    types?: RelationshipType[]
  ): Promise<Relationship[]> {
    let sql: string;
    const params: unknown[] = [];

    if (direction === 'out') {
      sql = `SELECT * FROM ${this.tableName} WHERE source_id = ?`;
      params.push(entityId);
    } else if (direction === 'in') {
      sql = `SELECT * FROM ${this.tableName} WHERE target_id = ?`;
      params.push(entityId);
    } else {
      sql = `SELECT * FROM ${this.tableName} WHERE source_id = ? OR target_id = ?`;
      params.push(entityId, entityId);
    }

    if (types?.length) {
      const placeholders = types.map(() => '?').join(', ');
      sql += ` AND relationship IN (${placeholders})`;
      params.push(...types);
    }

    const rows = this.db.all<RelationshipRow>(sql, params);
    return rows.map(this.rowToRelationship);
  }

  async getByType(type: RelationshipType): Promise<Relationship[]> {
    const rows = this.db.all<RelationshipRow>(
      `SELECT * FROM ${this.tableName} WHERE relationship = ?`,
      [type]
    );
    return rows.map(this.rowToRelationship);
  }

  async traverse(
    startId: string,
    depth: number = 2,
    options?: {
      direction?: 'in' | 'out' | 'both';
      types?: RelationshipType[];
    }
  ): Promise<TraversalResult> {
    const direction = options?.direction || 'both';
    const types = options?.types;

    // Build recursive CTE based on direction
    let joinCondition: string;
    if (direction === 'out') {
      joinCondition = 'r.source_id = t.target_id';
    } else if (direction === 'in') {
      joinCondition = 'r.target_id = t.source_id';
    } else {
      joinCondition = 'r.source_id = t.target_id OR r.target_id = t.source_id';
    }

    let typeFilter = '';
    const params: unknown[] = [startId, startId, depth];
    if (types?.length) {
      const placeholders = types.map(() => '?').join(', ');
      typeFilter = `AND relationship IN (${placeholders})`;
      params.push(...types, ...types);
    }

    const sql = `
      WITH RECURSIVE traversal AS (
        -- Base case: direct relationships from start
        SELECT
          id, source_id, target_id, relationship, weight,
          1 as depth,
          source_id || ',' || target_id as path
        FROM ${this.tableName}
        WHERE (source_id = ? OR target_id = ?) ${typeFilter}

        UNION ALL

        -- Recursive case
        SELECT
          r.id, r.source_id, r.target_id, r.relationship, r.weight,
          t.depth + 1,
          t.path || ',' || r.target_id
        FROM ${this.tableName} r
        JOIN traversal t ON ${joinCondition}
        WHERE t.depth < ?
          AND t.path NOT LIKE '%' || r.target_id || '%'
          ${typeFilter}
      )
      SELECT DISTINCT
        id, source_id, target_id, relationship, weight, depth
      FROM traversal
      ORDER BY depth, relationship
    `;

    const rows = this.db.all<TraversalRow>(sql, params);

    // Collect unique entity IDs
    const entityIds = new Set<string>();
    entityIds.add(startId);
    for (const row of rows) {
      entityIds.add(row.source_id);
      entityIds.add(row.target_id);
    }

    return {
      startId,
      relationships: rows.map(r => ({
        id: r.id,
        sourceId: r.source_id,
        targetId: r.target_id,
        relationship: r.relationship as RelationshipType,
        weight: r.weight,
        depth: r.depth
      })),
      entityIds: Array.from(entityIds)
    };
  }

  async delete(id: string): Promise<void> {
    this.db.run(`DELETE FROM ${this.tableName} WHERE id = ?`, [id]);
  }

  async deleteForEntity(entityId: string): Promise<number> {
    const result = this.db.run(
      `DELETE FROM ${this.tableName} WHERE source_id = ? OR target_id = ?`,
      [entityId, entityId]
    );
    return result.changes;
  }

  async deleteBySourceFile(filePath: string): Promise<number> {
    // Delete relationships where source is in the file
    const result = this.db.run(
      `DELETE FROM ${this.tableName}
       WHERE source_id IN (
         SELECT id FROM ${this.projectId}_entities WHERE file_path = ?
       )`,
      [filePath]
    );
    return result.changes;
  }

  private rowToRelationship(row: RelationshipRow): Relationship {
    return {
      id: row.id,
      sourceId: row.source_id,
      targetId: row.target_id,
      relationship: row.relationship as RelationshipType,
      weight: row.weight,
      metadata: JSON.parse(row.metadata || '{}'),
      createdAt: new Date(row.created_at)
    };
  }
}

interface TraversalResult {
  startId: string;
  relationships: Array<Relationship & { depth: number }>;
  entityIds: string[];
}
```

### File: `src/relationships/extractor.ts`

```typescript
import { ASTParser, ParseResult, Symbol, ImportStatement } from '../ast/parser';
import { EntityStore } from '../entities/store';
import { RelationshipStore, Relationship, RelationshipType } from './store';
import { resolve, dirname, relative } from 'path';

export class RelationshipExtractor {
  constructor(
    private projectPath: string,
    private astParser: ASTParser,
    private entityStore: EntityStore,
    private relationshipStore: RelationshipStore
  ) {}

  async extractAll(projectPath?: string): Promise<Relationship[]> {
    const basePath = projectPath || this.projectPath;
    const relationships: Relationship[] = [];

    // Get all file entities
    const files = await this.entityStore.getByType(['file']);

    for (const file of files) {
      const fileRels = await this.extractFromFile(file.filePath!);
      relationships.push(...fileRels);
    }

    return relationships;
  }

  async extractFromFile(filePath: string): Promise<Relationship[]> {
    const relationships: Array<Omit<Relationship, 'id' | 'createdAt'>> = [];

    // Get file entity
    const fileEntity = await this.entityStore.getByQualifiedName(filePath);
    if (!fileEntity) return [];

    // Extract CONTAINS relationships
    const symbols = await this.entityStore.getByFile(filePath);
    for (const symbol of symbols) {
      if (symbol.type !== 'file') {
        relationships.push({
          sourceId: fileEntity.id,
          targetId: symbol.id,
          relationship: 'CONTAINS',
          weight: 1.0
        });
      }
    }

    // Extract IMPORTS from file metadata
    const imports = fileEntity.metadata?.imports as ImportStatement[] | undefined;
    if (imports) {
      for (const imp of imports) {
        const targetRels = await this.resolveImport(filePath, imp);
        relationships.push(...targetRels.map(r => ({
          ...r,
          sourceId: fileEntity.id
        })));
      }
    }

    // Parse file to extract call relationships
    try {
      const parseResult = await this.astParser.parseFile(
        resolve(this.projectPath, filePath)
      );
      const callRels = await this.extractCallRelationships(filePath, parseResult);
      relationships.push(...callRels);

      const inheritanceRels = await this.extractInheritanceRelationships(filePath, parseResult);
      relationships.push(...inheritanceRels);
    } catch {
      // File might have been deleted or moved
    }

    // Store relationships
    await this.relationshipStore.createMany(relationships);

    return relationships as Relationship[];
  }

  private async resolveImport(
    sourcePath: string,
    imp: ImportStatement
  ): Promise<Array<{ targetId: string; relationship: RelationshipType; weight: number }>> {
    const results: Array<{ targetId: string; relationship: RelationshipType; weight: number }> = [];

    // Resolve the import source to a file path
    const targetPath = await this.resolveModulePath(sourcePath, imp.source);
    if (!targetPath) return results;

    // Find target file entity
    const targetFile = await this.entityStore.getByQualifiedName(targetPath);
    if (targetFile) {
      results.push({
        targetId: targetFile.id,
        relationship: 'IMPORTS',
        weight: 1.0
      });
    }

    // Resolve specific imports to symbols
    for (const spec of imp.specifiers) {
      const symbolName = spec.name === '*' ? null : spec.name;
      if (symbolName) {
        // Try to find the symbol in the target file
        const targetSymbol = await this.entityStore.getByQualifiedName(
          `${targetPath}::${symbolName}`
        );
        if (targetSymbol) {
          results.push({
            targetId: targetSymbol.id,
            relationship: 'IMPORTS',
            weight: 0.8
          });
        }
      }
    }

    return results;
  }

  private async resolveModulePath(
    sourcePath: string,
    modulePath: string
  ): Promise<string | null> {
    // Handle relative imports
    if (modulePath.startsWith('.')) {
      const sourceDir = dirname(sourcePath);
      let resolved = resolve(sourceDir, modulePath);

      // Try with extensions
      const extensions = ['.ts', '.tsx', '.js', '.jsx', '.py', '.go'];
      for (const ext of extensions) {
        const withExt = resolved + ext;
        const entity = await this.entityStore.getByQualifiedName(withExt);
        if (entity) return withExt;
      }

      // Try index file
      for (const ext of extensions) {
        const indexPath = resolve(resolved, `index${ext}`);
        const entity = await this.entityStore.getByQualifiedName(indexPath);
        if (entity) return indexPath;
      }
    }

    // Handle absolute/package imports (not resolved to file)
    return null;
  }

  private async extractCallRelationships(
    filePath: string,
    parseResult: ParseResult
  ): Promise<Array<Omit<Relationship, 'id' | 'createdAt'>>> {
    const relationships: Array<Omit<Relationship, 'id' | 'createdAt'>> = [];

    // This would require deeper AST analysis
    // For now, we extract based on known patterns

    const analyzeSymbol = async (symbol: Symbol, parentId?: string) => {
      const sourceEntity = await this.entityStore.getByQualifiedName(symbol.qualifiedName);
      if (!sourceEntity) return;

      // If this is a method, create CONTAINS from class
      if (parentId && (symbol.type === 'method' || symbol.type === 'property')) {
        relationships.push({
          sourceId: parentId,
          targetId: sourceEntity.id,
          relationship: 'CONTAINS',
          weight: 1.0
        });
      }

      // Analyze children
      if (symbol.children) {
        for (const child of symbol.children) {
          await analyzeSymbol(child, sourceEntity.id);
        }
      }
    };

    for (const symbol of parseResult.symbols) {
      await analyzeSymbol(symbol);
    }

    return relationships;
  }

  private async extractInheritanceRelationships(
    filePath: string,
    parseResult: ParseResult
  ): Promise<Array<Omit<Relationship, 'id' | 'createdAt'>>> {
    const relationships: Array<Omit<Relationship, 'id' | 'createdAt'>> = [];

    for (const symbol of parseResult.symbols) {
      if (symbol.type !== 'class') continue;

      const sourceEntity = await this.entityStore.getByQualifiedName(symbol.qualifiedName);
      if (!sourceEntity) continue;

      // Check metadata for extends/implements
      const metadata = sourceEntity.metadata as {
        extends?: string;
        implements?: string[];
      };

      if (metadata.extends) {
        const parentEntity = await this.findClassByName(metadata.extends, filePath);
        if (parentEntity) {
          relationships.push({
            sourceId: sourceEntity.id,
            targetId: parentEntity.id,
            relationship: 'EXTENDS',
            weight: 1.0
          });
        }
      }

      if (metadata.implements) {
        for (const interfaceName of metadata.implements) {
          const interfaceEntity = await this.findClassByName(interfaceName, filePath);
          if (interfaceEntity) {
            relationships.push({
              sourceId: sourceEntity.id,
              targetId: interfaceEntity.id,
              relationship: 'IMPLEMENTS',
              weight: 1.0
            });
          }
        }
      }
    }

    return relationships;
  }

  private async findClassByName(
    name: string,
    contextFile: string
  ): Promise<{ id: string } | null> {
    // First try in same file
    const sameFile = await this.entityStore.getByQualifiedName(`${contextFile}::${name}`);
    if (sameFile) return sameFile;

    // Try by name across project
    const byName = await this.entityStore.getByName(name, 'class');
    if (byName) return byName;

    const byInterface = await this.entityStore.getByName(name, 'interface');
    if (byInterface) return byInterface;

    return null;
  }
}
```

## Tasks

- [ ] Implement RelationshipStore
- [ ] Implement RelationshipExtractor
- [ ] Implement import resolution
- [ ] Implement call site analysis (basic)
- [ ] Implement inheritance extraction
- [ ] Add graph traversal with recursive CTEs
- [ ] Handle circular dependencies
- [ ] Write unit tests
- [ ] Test with complex codebases

## Testing

```typescript
describe('RelationshipStore', () => {
  it('should create relationship');
  it('should get relationships for entity');
  it('should traverse graph with depth limit');
  it('should filter by relationship type');
  it('should handle direction (in/out/both)');
});

describe('RelationshipExtractor', () => {
  it('should extract import relationships');
  it('should resolve relative imports');
  it('should extract inheritance relationships');
  it('should create CONTAINS relationships');
});
```

## Notes

- Import resolution is language-specific and complex
- Call analysis requires deeper AST traversal
- Consider using Language Server Protocol for more accurate analysis
- Graph traversal uses recursive CTEs for efficiency
- Circular dependencies are handled by path tracking
