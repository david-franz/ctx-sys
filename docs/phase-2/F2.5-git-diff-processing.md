# F2.5 Git Diff Processing

**Phase**: 2 - Code Intelligence
**Priority**: Medium
**Dependencies**: F2.3 Codebase Indexing

## Goal

Incrementally update the knowledge base based on git commits, avoiding full re-indexing.

## Overview

Git diff processing enables efficient incremental updates:
1. Detect which files changed since last sync
2. Re-index only changed files
3. Remove entities for deleted files
4. Handle renamed files (preserve history)
5. Track commit references for traceability

## Data Model

```typescript
interface DiffResult {
  added: string[];               // New files
  modified: string[];            // Changed files
  deleted: string[];             // Removed files
  renamed: Array<{               // Renamed/moved files
    from: string;
    to: string;
  }>;
  commits: CommitInfo[];         // Commits in range
}

interface CommitInfo {
  sha: string;
  message: string;
  author: string;
  date: Date;
  files: string[];
}

interface SyncResult {
  commitsSynced: number;
  filesAdded: number;
  filesModified: number;
  filesDeleted: number;
  filesRenamed: number;
  entitiesCreated: number;
  entitiesUpdated: number;
  entitiesDeleted: number;
  errors: SyncError[];
}

interface SyncError {
  file: string;
  error: string;
}
```

## Implementation

### File: `src/git/diff-processor.ts`

```typescript
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

export class GitDiffProcessor {
  constructor(private projectPath: string) {}

  async getChangesSince(commitSha: string): Promise<DiffResult> {
    const result: DiffResult = {
      added: [],
      modified: [],
      deleted: [],
      renamed: [],
      commits: []
    };

    // Get the diff summary
    const diffOutput = await this.execGit(
      `diff --name-status ${commitSha}..HEAD`
    );

    for (const line of diffOutput.split('\n').filter(Boolean)) {
      const [status, ...paths] = line.split('\t');

      switch (status[0]) {
        case 'A':
          result.added.push(paths[0]);
          break;
        case 'M':
          result.modified.push(paths[0]);
          break;
        case 'D':
          result.deleted.push(paths[0]);
          break;
        case 'R':
          // Renamed: R100 old_path new_path
          result.renamed.push({
            from: paths[0],
            to: paths[1]
          });
          break;
        case 'C':
          // Copied: treat as added
          result.added.push(paths[1]);
          break;
      }
    }

    // Get commit info
    result.commits = await this.getCommitsSince(commitSha);

    return result;
  }

  async getLatestCommit(): Promise<string> {
    const output = await this.execGit('rev-parse HEAD');
    return output.trim();
  }

  async getCommitsSince(commitSha: string): Promise<CommitInfo[]> {
    const format = '%H|%s|%an|%aI';
    const output = await this.execGit(
      `log ${commitSha}..HEAD --format="${format}"`
    );

    const commits: CommitInfo[] = [];

    for (const line of output.split('\n').filter(Boolean)) {
      const [sha, message, author, dateStr] = line.split('|');

      // Get files for this commit
      const filesOutput = await this.execGit(
        `diff-tree --no-commit-id --name-only -r ${sha}`
      );
      const files = filesOutput.split('\n').filter(Boolean);

      commits.push({
        sha,
        message,
        author,
        date: new Date(dateStr),
        files
      });
    }

    return commits;
  }

  async parseCommit(commitSha: string): Promise<CommitInfo> {
    const format = '%H|%s|%an|%aI';
    const output = await this.execGit(`show -s --format="${format}" ${commitSha}`);
    const [sha, message, author, dateStr] = output.trim().split('|');

    const filesOutput = await this.execGit(
      `diff-tree --no-commit-id --name-only -r ${commitSha}`
    );
    const files = filesOutput.split('\n').filter(Boolean);

    return {
      sha,
      message,
      author,
      date: new Date(dateStr),
      files
    };
  }

  async getCurrentBranch(): Promise<string> {
    const output = await this.execGit('rev-parse --abbrev-ref HEAD');
    return output.trim();
  }

  async hasUncommittedChanges(): Promise<boolean> {
    const output = await this.execGit('status --porcelain');
    return output.trim().length > 0;
  }

  async getUncommittedFiles(): Promise<{ staged: string[]; unstaged: string[] }> {
    const output = await this.execGit('status --porcelain');
    const staged: string[] = [];
    const unstaged: string[] = [];

    for (const line of output.split('\n').filter(Boolean)) {
      const indexStatus = line[0];
      const workStatus = line[1];
      const file = line.slice(3);

      if (indexStatus !== ' ' && indexStatus !== '?') {
        staged.push(file);
      }
      if (workStatus !== ' ') {
        unstaged.push(file);
      }
    }

    return { staged, unstaged };
  }

  private async execGit(command: string): Promise<string> {
    try {
      const { stdout } = await execAsync(`git ${command}`, {
        cwd: this.projectPath,
        maxBuffer: 10 * 1024 * 1024  // 10MB buffer for large repos
      });
      return stdout;
    } catch (error) {
      if (error instanceof Error) {
        throw new Error(`Git command failed: ${error.message}`);
      }
      throw error;
    }
  }
}
```

### File: `src/git/sync-manager.ts`

```typescript
import { GitDiffProcessor, DiffResult, CommitInfo } from './diff-processor';
import { CodebaseIndexer } from '../indexing/codebase-indexer';
import { EntityStore } from '../entities/store';
import { RelationshipStore } from '../relationships/store';
import { EmbeddingManager } from '../embeddings/manager';
import { ProjectManager, Project } from '../project/manager';

interface SyncOptions {
  since?: string;              // Commit SHA or 'last_sync'
  includeUncommitted?: boolean;
  onProgress?: (message: string) => void;
}

export class GitSyncManager {
  constructor(
    private projectPath: string,
    private diffProcessor: GitDiffProcessor,
    private indexer: CodebaseIndexer,
    private entityStore: EntityStore,
    private relationshipStore: RelationshipStore,
    private embeddingManager: EmbeddingManager,
    private projectManager: ProjectManager,
    private projectId: string
  ) {}

  async sync(options: SyncOptions = {}): Promise<SyncResult> {
    const project = await this.projectManager.get(this.projectId);
    if (!project) {
      throw new Error('Project not found');
    }

    // Determine starting point
    let sinceSha = options.since;
    if (!sinceSha || sinceSha === 'last_sync') {
      sinceSha = project.lastSyncCommit;
    }

    if (!sinceSha) {
      // No previous sync, need full index
      throw new Error('No previous sync found. Run full index first.');
    }

    const result: SyncResult = {
      commitsSynced: 0,
      filesAdded: 0,
      filesModified: 0,
      filesDeleted: 0,
      filesRenamed: 0,
      entitiesCreated: 0,
      entitiesUpdated: 0,
      entitiesDeleted: 0,
      errors: []
    };

    try {
      // Get changes since last sync
      options.onProgress?.('Analyzing git changes...');
      const diff = await this.diffProcessor.getChangesSince(sinceSha);
      result.commitsSynced = diff.commits.length;

      // Handle deleted files first
      options.onProgress?.(`Processing ${diff.deleted.length} deleted files...`);
      for (const file of diff.deleted) {
        const deleted = await this.handleDeletedFile(file);
        result.entitiesDeleted += deleted;
      }
      result.filesDeleted = diff.deleted.length;

      // Handle renamed files (preserve entity IDs)
      options.onProgress?.(`Processing ${diff.renamed.length} renamed files...`);
      for (const { from, to } of diff.renamed) {
        await this.handleRenamedFile(from, to);
      }
      result.filesRenamed = diff.renamed.length;

      // Handle added files
      options.onProgress?.(`Indexing ${diff.added.length} new files...`);
      for (const file of diff.added) {
        try {
          const indexResult = await this.indexer.indexFile(file, { summarize: true });
          result.entitiesCreated += indexResult.created;
        } catch (error) {
          result.errors.push({
            file,
            error: error instanceof Error ? error.message : String(error)
          });
        }
      }
      result.filesAdded = diff.added.length;

      // Handle modified files
      options.onProgress?.(`Re-indexing ${diff.modified.length} modified files...`);
      for (const file of diff.modified) {
        try {
          // Delete existing entities for file
          await this.handleDeletedFile(file);
          // Re-index
          const indexResult = await this.indexer.indexFile(file, { summarize: true });
          result.entitiesCreated += indexResult.created;
        } catch (error) {
          result.errors.push({
            file,
            error: error instanceof Error ? error.message : String(error)
          });
        }
      }
      result.filesModified = diff.modified.length;

      // Handle uncommitted changes if requested
      if (options.includeUncommitted) {
        options.onProgress?.('Processing uncommitted changes...');
        const uncommitted = await this.diffProcessor.getUncommittedFiles();
        for (const file of [...uncommitted.staged, ...uncommitted.unstaged]) {
          try {
            await this.handleDeletedFile(file);
            const indexResult = await this.indexer.indexFile(file, { summarize: true });
            result.entitiesCreated += indexResult.created;
          } catch {
            // File might not exist (deleted but not committed)
          }
        }
      }

      // Update last sync commit
      const latestCommit = await this.diffProcessor.getLatestCommit();
      await this.projectManager.update(this.projectId, {
        lastSyncCommit: latestCommit
      });

      options.onProgress?.('Sync complete.');
    } catch (error) {
      result.errors.push({
        file: 'sync',
        error: error instanceof Error ? error.message : String(error)
      });
    }

    return result;
  }

  private async handleDeletedFile(filePath: string): Promise<number> {
    // Get all entities for this file
    const entities = await this.entityStore.getByFile(filePath);
    let deleted = 0;

    for (const entity of entities) {
      // Delete relationships
      await this.relationshipStore.deleteForEntity(entity.id);
      // Delete embeddings
      await this.embeddingManager.deleteForEntity(entity.id);
      // Delete entity
      await this.entityStore.delete(entity.id);
      deleted++;
    }

    return deleted;
  }

  private async handleRenamedFile(fromPath: string, toPath: string): Promise<void> {
    // Get all entities for the old path
    const entities = await this.entityStore.getByFile(fromPath);

    for (const entity of entities) {
      // Update file path
      const newQualifiedName = entity.qualifiedName?.replace(fromPath, toPath);

      await this.entityStore.update(entity.id, {
        metadata: {
          ...entity.metadata,
          filePath: toPath,
          previousPath: fromPath
        }
      });

      // Note: qualifiedName update would require a different approach
      // since it's used as a key. For now, we re-index renamed files.
    }

    // For simplicity, re-index the renamed file
    await this.handleDeletedFile(fromPath);
    await this.indexer.indexFile(toPath, { summarize: true });
  }
}
```

### File: `src/mcp/tools/sync-from-git.ts`

```typescript
import { Tool } from '@modelcontextprotocol/sdk/types.js';
import { AppContext } from '../../context';

export const syncFromGitTool: Tool = {
  name: 'sync_from_git',
  description: 'Incrementally update the knowledge base from git changes since last sync.',
  inputSchema: {
    type: 'object',
    properties: {
      project: {
        type: 'string',
        description: 'Target project (default: active project)'
      },
      since: {
        type: 'string',
        description: 'Commit SHA to sync from (default: last sync point)'
      },
      include_uncommitted: {
        type: 'boolean',
        description: 'Include uncommitted changes (default: false)'
      }
    }
  }
};

export async function handleSyncFromGit(
  context: AppContext,
  args: Record<string, unknown>
): Promise<unknown> {
  const project = await context.resolveProject(args.project as string | undefined);
  const syncManager = context.getGitSyncManager(project.id);

  const result = await syncManager.sync({
    since: args.since as string | undefined,
    includeUncommitted: args.include_uncommitted as boolean | undefined,
    onProgress: (message) => {
      console.error(`[sync] ${message}`);
    }
  });

  return {
    success: result.errors.length === 0,
    result: {
      commitsSynced: result.commitsSynced,
      filesAdded: result.filesAdded,
      filesModified: result.filesModified,
      filesDeleted: result.filesDeleted,
      filesRenamed: result.filesRenamed,
      entitiesCreated: result.entitiesCreated,
      entitiesUpdated: result.entitiesUpdated,
      entitiesDeleted: result.entitiesDeleted,
      errors: result.errors.length > 0 ? result.errors : undefined
    }
  };
}
```

## CLI Command

```bash
ctx-sys sync [options]

Options:
  --project <name>     Target project
  --since <sha>        Sync from specific commit
  --include-uncommitted Include staged/unstaged changes
  --watch              Continue watching for changes

Examples:
  ctx-sys sync
  ctx-sys sync --since abc123
  ctx-sys sync --include-uncommitted
```

## Git Hooks Integration (Optional)

### Post-commit Hook

```bash
#!/bin/sh
# .git/hooks/post-commit

# Sync ctx-sys after each commit
ctx-sys sync --project my-project 2>/dev/null &
```

### Setup Script

```typescript
// src/git/hooks.ts

export async function installHooks(projectPath: string): Promise<void> {
  const hookContent = `#!/bin/sh
ctx-sys sync 2>/dev/null &
`;

  const hookPath = join(projectPath, '.git/hooks/post-commit');
  await writeFile(hookPath, hookContent, { mode: 0o755 });
}
```

## Tasks

- [ ] Implement GitDiffProcessor
- [ ] Implement GitSyncManager
- [ ] Handle file deletions (cascade delete)
- [ ] Handle file renames (preserve IDs)
- [ ] Add MCP tool handler
- [ ] Add CLI command
- [ ] Add git hooks integration (optional)
- [ ] Handle merge commits
- [ ] Write unit tests
- [ ] Test with complex git histories

## Testing

```typescript
describe('GitDiffProcessor', () => {
  it('should detect added files');
  it('should detect modified files');
  it('should detect deleted files');
  it('should detect renamed files');
  it('should get commit info');
  it('should detect uncommitted changes');
});

describe('GitSyncManager', () => {
  it('should sync changes since last commit');
  it('should handle deleted files');
  it('should handle renamed files');
  it('should update last sync commit');
  it('should include uncommitted when requested');
});
```

## Notes

- Git operations use child_process for reliability
- Large repos may need increased buffer size
- Renamed files are re-indexed for simplicity (could optimize)
- Watch mode could use git hooks or file watcher
- Consider debouncing for rapid commits
