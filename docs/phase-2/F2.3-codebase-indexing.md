# F2.3 Codebase Indexing

**Phase**: 2 - Code Intelligence
**Priority**: High
**Dependencies**: F2.1 AST Parsing, F2.2 Symbol Summarization, F1.3 Entity Storage, F1.4 Embedding Pipeline

## Goal

Full project scan that extracts symbols, generates summaries, creates entities, and builds embeddings.

## Overview

Codebase indexing is the primary way to populate the knowledge base. It:
1. Scans project files (respecting .gitignore)
2. Parses each file to extract symbols
3. Generates AI summaries for each symbol
4. Creates entities in the database
5. Generates embeddings for semantic search
6. Extracts relationships between symbols

## Data Model

```typescript
interface IndexOptions {
  depth: 'full' | 'signatures' | 'selective';
  ignore?: string[];              // Additional patterns to ignore
  include?: string[];             // Only include these patterns
  languages?: string[];           // Limit to specific languages
  summarize?: boolean;            // Generate AI summaries
  embeddings?: boolean;           // Generate embeddings
  relationships?: boolean;        // Extract relationships
  onProgress?: (progress: IndexProgress) => void;
}

interface IndexProgress {
  phase: 'scanning' | 'parsing' | 'summarizing' | 'embedding' | 'linking';
  current: number;
  total: number;
  currentFile?: string;
  message?: string;
}

interface IndexResult {
  filesScanned: number;
  filesIndexed: number;
  filesSkipped: number;
  entitiesCreated: number;
  entitiesUpdated: number;
  embeddingsGenerated: number;
  relationshipsCreated: number;
  errors: IndexError[];
  duration: number;
}

interface IndexError {
  file: string;
  error: string;
  phase: string;
}
```

## Implementation

### File: `src/indexing/file-scanner.ts`

```typescript
import { glob } from 'glob';
import { readFile } from 'fs/promises';
import { join, relative } from 'path';
import ignore, { Ignore } from 'ignore';

interface ScanOptions {
  ignore?: string[];
  include?: string[];
  languages?: string[];
}

interface ScanResult {
  files: string[];
  skipped: string[];
}

export class FileScanner {
  private ig: Ignore;

  constructor(private projectPath: string) {
    this.ig = ignore();
  }

  async scan(options: ScanOptions = {}): Promise<ScanResult> {
    // Load .gitignore
    await this.loadGitignore();

    // Add additional ignore patterns
    if (options.ignore) {
      this.ig.add(options.ignore);
    }

    // Default ignores
    this.ig.add([
      'node_modules',
      '.git',
      'dist',
      'build',
      '__pycache__',
      '*.min.js',
      '*.map',
      '*.lock',
      'package-lock.json',
      'yarn.lock'
    ]);

    // Build glob patterns
    let patterns: string[];
    if (options.include?.length) {
      patterns = options.include;
    } else if (options.languages?.length) {
      patterns = this.getLanguagePatterns(options.languages);
    } else {
      patterns = ['**/*'];
    }

    // Scan files
    const allFiles: string[] = [];
    for (const pattern of patterns) {
      const matches = await glob(pattern, {
        cwd: this.projectPath,
        nodir: true,
        absolute: false
      });
      allFiles.push(...matches);
    }

    // Filter by ignore rules
    const files: string[] = [];
    const skipped: string[] = [];

    for (const file of [...new Set(allFiles)]) {
      if (this.ig.ignores(file)) {
        skipped.push(file);
      } else if (this.isSupportedFile(file)) {
        files.push(join(this.projectPath, file));
      } else {
        skipped.push(file);
      }
    }

    return { files, skipped };
  }

  private async loadGitignore(): Promise<void> {
    try {
      const gitignorePath = join(this.projectPath, '.gitignore');
      const content = await readFile(gitignorePath, 'utf-8');
      this.ig.add(content);
    } catch {
      // No .gitignore, that's fine
    }
  }

  private getLanguagePatterns(languages: string[]): string[] {
    const extensionMap: Record<string, string[]> = {
      typescript: ['**/*.ts', '**/*.tsx'],
      javascript: ['**/*.js', '**/*.jsx', '**/*.mjs'],
      python: ['**/*.py'],
      go: ['**/*.go'],
      rust: ['**/*.rs'],
      java: ['**/*.java'],
      c: ['**/*.c', '**/*.h'],
      cpp: ['**/*.cpp', '**/*.hpp', '**/*.cc']
    };

    const patterns: string[] = [];
    for (const lang of languages) {
      if (extensionMap[lang]) {
        patterns.push(...extensionMap[lang]);
      }
    }
    return patterns;
  }

  private isSupportedFile(file: string): boolean {
    const supportedExtensions = [
      '.ts', '.tsx', '.js', '.jsx', '.mjs',
      '.py', '.go', '.rs', '.java', '.c', '.h', '.cpp', '.hpp', '.cc'
    ];
    return supportedExtensions.some(ext => file.endsWith(ext));
  }
}
```

### File: `src/indexing/codebase-indexer.ts`

```typescript
import { readFile } from 'fs/promises';
import { relative } from 'path';
import { ASTParser, ParseResult, Symbol } from '../ast/parser';
import { CodeSummarizer } from '../summarization/code-summarizer';
import { EntityStore } from '../entities/store';
import { EmbeddingManager } from '../embeddings/manager';
import { RelationshipExtractor } from '../relationships/extractor';
import { FileScanner } from './file-scanner';
import { hashContent } from '../utils/hash';

export class CodebaseIndexer {
  constructor(
    private projectPath: string,
    private astParser: ASTParser,
    private summarizer: CodeSummarizer,
    private entityStore: EntityStore,
    private embeddingManager: EmbeddingManager,
    private relationshipExtractor: RelationshipExtractor
  ) {}

  async index(options: IndexOptions = {}): Promise<IndexResult> {
    const startTime = Date.now();
    const errors: IndexError[] = [];
    const stats = {
      filesScanned: 0,
      filesIndexed: 0,
      filesSkipped: 0,
      entitiesCreated: 0,
      entitiesUpdated: 0,
      embeddingsGenerated: 0,
      relationshipsCreated: 0
    };

    // Phase 1: Scan files
    this.reportProgress(options, {
      phase: 'scanning',
      current: 0,
      total: 0,
      message: 'Scanning project files...'
    });

    const scanner = new FileScanner(this.projectPath);
    const { files, skipped } = await scanner.scan({
      ignore: options.ignore,
      include: options.include,
      languages: options.languages
    });

    stats.filesScanned = files.length;
    stats.filesSkipped = skipped.length;

    // Phase 2: Parse and index each file
    const allSymbols: Map<string, { symbol: Symbol; fileContent: string }> = new Map();

    for (let i = 0; i < files.length; i++) {
      const file = files[i];
      const relativePath = relative(this.projectPath, file);

      this.reportProgress(options, {
        phase: 'parsing',
        current: i + 1,
        total: files.length,
        currentFile: relativePath
      });

      try {
        const result = await this.indexFile(file, options);
        stats.filesIndexed++;
        stats.entitiesCreated += result.created;
        stats.entitiesUpdated += result.updated;

        // Collect symbols for later processing
        for (const [qn, data] of result.symbols) {
          allSymbols.set(qn, data);
        }
      } catch (error) {
        errors.push({
          file: relativePath,
          error: error instanceof Error ? error.message : String(error),
          phase: 'parsing'
        });
      }
    }

    // Phase 3: Generate summaries
    if (options.summarize !== false) {
      const symbolsToSummarize = Array.from(allSymbols.entries())
        .filter(([_, data]) => !data.symbol.docstring);

      for (let i = 0; i < symbolsToSummarize.length; i++) {
        const [qualifiedName, { symbol, fileContent }] = symbolsToSummarize[i];

        this.reportProgress(options, {
          phase: 'summarizing',
          current: i + 1,
          total: symbolsToSummarize.length,
          currentFile: symbol.name
        });

        try {
          const summary = await this.summarizer.summarizeSymbol(symbol, fileContent);
          const entity = await this.entityStore.getByQualifiedName(qualifiedName);
          if (entity) {
            await this.entityStore.update(entity.id, { summary });
          }
        } catch (error) {
          errors.push({
            file: qualifiedName,
            error: error instanceof Error ? error.message : String(error),
            phase: 'summarizing'
          });
        }
      }
    }

    // Phase 4: Generate embeddings
    if (options.embeddings !== false) {
      const entitiesToEmbed = await this.entityStore.getByType([
        'function', 'method', 'class', 'interface'
      ]);

      for (let i = 0; i < entitiesToEmbed.length; i++) {
        const entity = entitiesToEmbed[i];

        this.reportProgress(options, {
          phase: 'embedding',
          current: i + 1,
          total: entitiesToEmbed.length,
          currentFile: entity.name
        });

        try {
          // Embed the summary or name if no summary
          const content = entity.summary || entity.name;
          await this.embeddingManager.embed(entity.id, content);
          stats.embeddingsGenerated++;
        } catch (error) {
          errors.push({
            file: entity.qualifiedName || entity.name,
            error: error instanceof Error ? error.message : String(error),
            phase: 'embedding'
          });
        }
      }
    }

    // Phase 5: Extract relationships
    if (options.relationships !== false) {
      this.reportProgress(options, {
        phase: 'linking',
        current: 0,
        total: files.length,
        message: 'Extracting relationships...'
      });

      try {
        const relationships = await this.relationshipExtractor.extractAll(this.projectPath);
        stats.relationshipsCreated = relationships.length;
      } catch (error) {
        errors.push({
          file: 'relationships',
          error: error instanceof Error ? error.message : String(error),
          phase: 'linking'
        });
      }
    }

    return {
      ...stats,
      errors,
      duration: Date.now() - startTime
    };
  }

  async indexFile(
    filePath: string,
    options: IndexOptions = {}
  ): Promise<{
    created: number;
    updated: number;
    symbols: Map<string, { symbol: Symbol; fileContent: string }>;
  }> {
    const fileContent = await readFile(filePath, 'utf-8');
    const fileHash = hashContent(fileContent);
    const relativePath = relative(this.projectPath, filePath);

    // Check if file is unchanged (via AST cache)
    const cached = await this.checkCache(relativePath, fileHash);
    if (cached && options.depth !== 'full') {
      return { created: 0, updated: 0, symbols: new Map() };
    }

    // Parse file
    const parseResult = await this.astParser.parseFile(filePath);

    // Create file entity
    await this.createOrUpdateEntity({
      type: 'file',
      name: relativePath,
      qualifiedName: relativePath,
      filePath: relativePath,
      metadata: {
        language: parseResult.language,
        imports: parseResult.imports,
        exports: parseResult.exports
      }
    }, fileHash);

    // Process symbols
    let created = 0;
    let updated = 0;
    const symbols = new Map<string, { symbol: Symbol; fileContent: string }>();

    const processSymbol = async (symbol: Symbol) => {
      const result = await this.createOrUpdateEntity({
        type: symbol.type as any,
        name: symbol.name,
        qualifiedName: symbol.qualifiedName,
        content: symbol.signature,
        summary: symbol.docstring ? this.extractFirstSentence(symbol.docstring) : undefined,
        filePath: relativePath,
        startLine: symbol.startLine,
        endLine: symbol.endLine,
        metadata: {
          parameters: symbol.parameters,
          returnType: symbol.returnType,
          decorators: symbol.decorators,
          visibility: symbol.visibility,
          isStatic: symbol.isStatic,
          isAsync: symbol.isAsync,
          isExported: symbol.isExported
        }
      }, hashContent(symbol.signature || symbol.name));

      if (result.created) created++;
      else updated++;

      symbols.set(symbol.qualifiedName, { symbol, fileContent });

      // Process children (methods)
      if (symbol.children) {
        for (const child of symbol.children) {
          await processSymbol(child);
        }
      }
    };

    for (const symbol of parseResult.symbols) {
      await processSymbol(symbol);
    }

    // Update cache
    await this.updateCache(relativePath, fileHash, parseResult);

    return { created, updated, symbols };
  }

  private async createOrUpdateEntity(
    input: Parameters<EntityStore['create']>[0],
    hash: string
  ): Promise<{ created: boolean }> {
    const existing = await this.entityStore.getByQualifiedName(input.qualifiedName!);

    if (existing) {
      if (existing.hash !== hash) {
        await this.entityStore.update(existing.id, {
          ...input,
          metadata: { ...existing.metadata, ...input.metadata }
        });
      }
      return { created: false };
    }

    await this.entityStore.create(input);
    return { created: true };
  }

  private async checkCache(filePath: string, hash: string): Promise<boolean> {
    // Check AST cache table
    const cached = this.entityStore['db'].get<{ file_hash: string }>(
      `SELECT file_hash FROM ${this.entityStore['projectId']}_ast_cache WHERE file_path = ?`,
      [filePath]
    );
    return cached?.file_hash === hash;
  }

  private async updateCache(
    filePath: string,
    hash: string,
    parseResult: ParseResult
  ): Promise<void> {
    const db = this.entityStore['db'];
    const projectId = this.entityStore['projectId'];

    db.run(
      `INSERT OR REPLACE INTO ${projectId}_ast_cache (file_path, file_hash, symbols, parsed_at)
       VALUES (?, ?, ?, CURRENT_TIMESTAMP)`,
      [filePath, hash, JSON.stringify(parseResult.symbols)]
    );
  }

  private extractFirstSentence(text: string): string {
    const match = text.match(/^[^.!?]+[.!?]/);
    return match ? match[0].trim() : text.slice(0, 100).trim();
  }

  private reportProgress(options: IndexOptions, progress: IndexProgress): void {
    options.onProgress?.(progress);
  }
}
```

### File: `src/mcp/tools/index-codebase.ts`

```typescript
import { Tool } from '@modelcontextprotocol/sdk/types.js';
import { AppContext } from '../../context';

export const indexCodebaseTool: Tool = {
  name: 'index_codebase',
  description: 'Index a codebase to build the knowledge base. Extracts code structure, generates summaries, and creates embeddings for semantic search.',
  inputSchema: {
    type: 'object',
    properties: {
      path: {
        type: 'string',
        description: 'Path to the codebase (default: project path)'
      },
      project: {
        type: 'string',
        description: 'Target project (default: active project)'
      },
      depth: {
        type: 'string',
        enum: ['full', 'signatures', 'selective'],
        description: 'Indexing depth: full (everything), signatures (no body), selective (important only)'
      },
      summarize: {
        type: 'boolean',
        description: 'Generate AI summaries for symbols (default: true)'
      },
      languages: {
        type: 'array',
        items: { type: 'string' },
        description: 'Limit to specific languages (e.g., ["typescript", "python"])'
      }
    }
  }
};

export async function handleIndexCodebase(
  context: AppContext,
  args: Record<string, unknown>
): Promise<unknown> {
  const project = await context.resolveProject(args.project as string | undefined);
  const indexer = context.getCodebaseIndexer(project.id);

  const result = await indexer.index({
    depth: (args.depth as 'full' | 'signatures' | 'selective') || 'full',
    summarize: args.summarize !== false,
    languages: args.languages as string[] | undefined,
    onProgress: (progress) => {
      // Log progress for visibility
      console.error(`[${progress.phase}] ${progress.current}/${progress.total} ${progress.currentFile || ''}`);
    }
  });

  // Update project metadata
  await context.projectManager.update(project.id, {
    lastIndexedAt: new Date()
  });

  return {
    success: true,
    result: {
      filesIndexed: result.filesIndexed,
      entitiesCreated: result.entitiesCreated,
      embeddingsGenerated: result.embeddingsGenerated,
      duration: `${(result.duration / 1000).toFixed(1)}s`,
      errors: result.errors.length > 0 ? result.errors : undefined
    }
  };
}
```

## CLI Command

```bash
ctx-sys index [options]

Options:
  --path <path>        Project path (default: current directory)
  --project <name>     Target project
  --depth <level>      Indexing depth: full, signatures, selective
  --no-summarize       Skip AI summarization
  --no-embeddings      Skip embedding generation
  --languages <langs>  Comma-separated list of languages
  --watch              Watch for changes after indexing

Examples:
  ctx-sys index
  ctx-sys index --depth signatures --no-summarize
  ctx-sys index --languages typescript,python
```

## Tasks

- [ ] Implement FileScanner
- [ ] Implement CodebaseIndexer
- [ ] Implement AST caching
- [ ] Implement incremental indexing (skip unchanged files)
- [ ] Add MCP tool handler
- [ ] Add CLI command
- [ ] Add progress reporting
- [ ] Add error recovery
- [ ] Write unit tests
- [ ] Test with large codebases (performance)

## Testing

```typescript
describe('FileScanner', () => {
  it('should scan project respecting .gitignore');
  it('should filter by language');
  it('should apply additional ignore patterns');
});

describe('CodebaseIndexer', () => {
  it('should index all files in project');
  it('should skip unchanged files via cache');
  it('should create entities for all symbols');
  it('should generate summaries when enabled');
  it('should generate embeddings when enabled');
  it('should report progress');
  it('should handle parse errors gracefully');
});
```

## Performance Considerations

- Use AST cache to skip unchanged files
- Batch embedding generation
- Parallel file parsing (with concurrency limit)
- Stream large files instead of loading entirely
- Consider chunking for very large codebases

## Notes

- .gitignore is always respected
- Default behavior includes summarization and embeddings
- Progress callbacks allow UI integration
- Errors are collected but don't stop indexing
