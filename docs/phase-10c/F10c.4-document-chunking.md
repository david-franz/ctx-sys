# F10c.4 Document Chunking Improvements

**Phase**: 10c - Retrieval Quality Improvements
**Priority**: High
**Dependencies**: None

## Problem

Document indexing uses heading-based chunking which creates sections of wildly varying sizes. A top-level heading might span 500 lines while a sub-heading contains 2 lines. Long sections exceed embedding model context windows and produce diluted embeddings. Short sections lack context. There's no overlap between chunks, so information at section boundaries is lost.

### Observed Behavior

```
index_document({ path: "README.md" })
→ 45 sections created, but section sizes range from 1 line to 200+ lines
→ Large sections produce poor embeddings (truncated at 80 lines in content-hasher)
→ No overlap between adjacent sections
```

### Root Cause

In `src/documents/document-indexer.ts` (lines 142-172), sections are split purely by heading level with no size constraints. The `buildEmbeddingContent()` function in `content-hasher.ts` truncates at 80 lines, losing content silently.

## Implementation Plan

### Step 1: Add Chunk Size Constraints

**File**: `src/documents/document-indexer.ts`

```typescript
interface ChunkingOptions {
  /** Target chunk size in characters */
  targetSize?: number;       // Default: 1500 chars (~375 tokens)
  /** Maximum chunk size before forced split */
  maxSize?: number;          // Default: 3000 chars (~750 tokens)
  /** Minimum chunk size (merge with neighbors) */
  minSize?: number;          // Default: 200 chars (~50 tokens)
  /** Overlap between adjacent chunks in characters */
  overlap?: number;          // Default: 200 chars (~50 tokens)
  /** Preserve heading hierarchy */
  preserveStructure?: boolean; // Default: true
}

const DEFAULT_CHUNKING: Required<ChunkingOptions> = {
  targetSize: 1500,
  maxSize: 3000,
  minSize: 200,
  overlap: 200,
  preserveStructure: true
};
```

### Step 2: Implement Semantic-Aware Chunking

Split large sections while respecting paragraph boundaries:

```typescript
private chunkSection(
  content: string,
  options: Required<ChunkingOptions>
): string[] {
  if (content.length <= options.maxSize) {
    return [content];
  }

  const chunks: string[] = [];
  const paragraphs = content.split(/\n\n+/);
  let currentChunk = '';

  for (const para of paragraphs) {
    if (currentChunk.length + para.length > options.targetSize && currentChunk.length > 0) {
      chunks.push(currentChunk.trim());

      // Add overlap from end of previous chunk
      if (options.overlap > 0) {
        const overlapText = currentChunk.slice(-options.overlap);
        currentChunk = overlapText + '\n\n' + para;
      } else {
        currentChunk = para;
      }
    } else {
      currentChunk += (currentChunk ? '\n\n' : '') + para;
    }
  }

  if (currentChunk.trim()) {
    chunks.push(currentChunk.trim());
  }

  return chunks;
}
```

### Step 3: Merge Small Sections

```typescript
private mergeSections(
  sections: DocumentSection[],
  options: Required<ChunkingOptions>
): DocumentSection[] {
  const merged: DocumentSection[] = [];

  for (const section of sections) {
    const last = merged[merged.length - 1];

    if (last &&
        last.content.length < options.minSize &&
        last.level >= section.level) {
      // Merge small section with previous
      last.content += '\n\n' + section.content;
      last.endLine = section.endLine;
    } else {
      merged.push({ ...section });
    }
  }

  return merged;
}
```

### Step 4: Add Chunk Metadata

Track chunk provenance for better source attribution:

```typescript
interface ChunkMetadata {
  chunkIndex: number;      // Position within parent section
  totalChunks: number;     // Total chunks for this section
  hasOverlap: boolean;     // Whether this chunk overlaps with neighbors
  parentSection: string;   // Parent section heading
  charRange: [number, number]; // Character range in original document
}
```

### Step 5: Support Multiple Document Formats

Extend chunking to work well with different document types:

```typescript
// Markdown: Split by headings, then by paragraphs within sections
// Plain text: Split by paragraph, then by sentence count
// YAML/JSON: Split by top-level keys
// Code comments: Extract and chunk doc blocks separately

private getChunker(docType: DocumentType): ChunkFunction {
  switch (docType) {
    case 'markdown': return this.chunkMarkdown.bind(this);
    case 'text': return this.chunkPlainText.bind(this);
    case 'yaml': return this.chunkStructured.bind(this);
    case 'json': return this.chunkStructured.bind(this);
    default: return this.chunkPlainText.bind(this);
  }
}
```

## Testing

```typescript
describe('Document chunking', () => {
  it('should split large sections', async () => {
    const longDoc = '# Title\n\n' + 'Paragraph. '.repeat(500);
    const result = await indexer.indexContent(longDoc, 'markdown');
    const sections = result.entities.filter(e => e.type === 'section');
    expect(sections.every(s => (s.content?.length || 0) <= 3000)).toBe(true);
  });

  it('should merge tiny sections', async () => {
    const doc = '# Title\n## A\nSmall.\n## B\nAlso small.\n## C\nMore content here.';
    const result = await indexer.indexContent(doc, 'markdown');
    // Sections A and B should be merged
  });

  it('should add overlap between chunks', async () => {
    const longDoc = '# Title\n\n' + Array.from({length: 20}, (_, i) =>
      `Paragraph ${i} with distinct content.`
    ).join('\n\n');
    const result = await indexer.indexContent(doc, 'markdown');
    const chunks = result.entities.filter(e => e.type === 'section');
    // Verify overlap exists between adjacent chunks
    if (chunks.length > 1) {
      const end1 = chunks[0].content!.slice(-100);
      const start2 = chunks[1].content!.slice(0, 100);
      expect(start2).toContain(end1.slice(-50));
    }
  });

  it('should respect paragraph boundaries', async () => {
    const result = await indexer.indexContent(longDoc, 'markdown');
    const sections = result.entities.filter(e => e.type === 'section');
    for (const section of sections) {
      // Content should not end mid-sentence
      expect(section.content).not.toMatch(/\w$/);
    }
  });
});
```

## Success Criteria

- No section exceeds 3000 characters (~750 tokens)
- Sections under 200 characters are merged with neighbors
- 200-character overlap between adjacent chunks
- Paragraph boundaries preserved (no mid-sentence splits)
- Heading hierarchy maintained in metadata
- Document search quality improves (measured by benchmark)
