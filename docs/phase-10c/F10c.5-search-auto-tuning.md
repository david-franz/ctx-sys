# F10c.5 Search Strategy Auto-Tuning

**Phase**: 10c - Retrieval Quality Improvements
**Priority**: Medium
**Dependencies**: F10c.1, F10c.2, F10c.3

## Problem

Search strategy weights are hardcoded (`keyword: 0.6, semantic: 1.0, graph: 0.8`) and the default strategies are fixed to `['keyword', 'semantic']`. Different query types benefit from different strategies — a specific function name should prioritize keyword search, while a conceptual question should prioritize semantic search. There's no adaptation based on query characteristics or historical performance.

### Observed Behavior

```
# Exact name query - should prioritize keyword, but semantic weight is higher
context_query({ query: "EntityStore" })
→ Semantic weight 1.0 dominates, but semantic search returns noisy matches
→ FTS keyword match (weight 0.6) is more precise here but gets less weight

# Conceptual query - semantic should dominate (and does)
context_query({ query: "how does the search pipeline work" })
→ Semantic search is appropriate here
```

### Root Cause

In `src/retrieval/multi-strategy-search.ts` (lines 50-63), strategy configuration is static. The `QueryParser` already detects entity mentions and query intent, but this information isn't used to adjust strategy weights.

## Implementation Plan

### Step 1: Query-Adaptive Strategy Selection

**File**: `src/retrieval/multi-strategy-search.ts`

Use the parsed query to automatically adjust weights:

```typescript
private adaptWeights(parsed: ParsedQuery, baseWeights: StrategyWeights): StrategyWeights {
  const weights = { ...baseWeights };

  // Entity mention detected → boost keyword, add graph
  if (parsed.entityMentions.length > 0) {
    weights.keyword = (weights.keyword || 0.6) * 1.5;
    weights.graph = (weights.graph || 0.8) * 1.3;
  }

  // Short query (1-2 words) → likely a name lookup
  if (parsed.keywords.length <= 2 && parsed.entityMentions.length > 0) {
    weights.keyword = (weights.keyword || 0.6) * 2.0;
    weights.semantic = (weights.semantic || 1.0) * 0.5;
  }

  // Question format → boost semantic
  if (parsed.normalizedQuery.match(/^(how|what|why|where|when|which)/i)) {
    weights.semantic = (weights.semantic || 1.0) * 1.5;
    weights.keyword = (weights.keyword || 0.6) * 0.7;
  }

  // File path pattern → pure keyword
  if (parsed.normalizedQuery.match(/\.(ts|js|py|go|rs|java)$/)) {
    weights.keyword = 3.0;
    weights.semantic = 0.2;
  }

  return weights;
}
```

### Step 2: Auto-Enable Graph Strategy

**File**: `src/retrieval/multi-strategy-search.ts`

Automatically include graph strategy when entity mentions are detected:

```typescript
private selectStrategies(
  parsed: ParsedQuery,
  requestedStrategies: SearchStrategy[]
): SearchStrategy[] {
  const strategies = [...requestedStrategies];

  // Auto-enable graph when entities are mentioned and graph is available
  if (parsed.entityMentions.length > 0 &&
      this.graphTraversal &&
      !strategies.includes('graph')) {
    strategies.push('graph');
  }

  return strategies;
}
```

### Step 3: Feedback-Based Weight Adjustment

Use analytics feedback to adjust weights over time:

```typescript
export class AdaptiveWeightManager {
  private weights: StrategyWeights;
  private feedback: Array<{ strategy: SearchStrategy; wasUseful: boolean }> = [];

  updateFromFeedback(queryLog: QueryLog): void {
    if (queryLog.wasUseful === undefined) return;

    for (const strategy of queryLog.retrievalStrategies) {
      this.feedback.push({
        strategy: strategy as SearchStrategy,
        wasUseful: queryLog.wasUseful
      });
    }

    // Recalculate weights based on usefulness rate per strategy
    this.recalculateWeights();
  }

  private recalculateWeights(): void {
    const byStrategy = new Map<SearchStrategy, { useful: number; total: number }>();

    for (const fb of this.feedback.slice(-100)) { // Last 100 entries
      const stats = byStrategy.get(fb.strategy) || { useful: 0, total: 0 };
      stats.total++;
      if (fb.wasUseful) stats.useful++;
      byStrategy.set(fb.strategy, stats);
    }

    for (const [strategy, stats] of byStrategy) {
      if (stats.total >= 10) {
        const rate = stats.useful / stats.total;
        this.weights[strategy] = 0.2 + rate * 1.6; // Scale 0.2-1.8
      }
    }
  }
}
```

### Step 4: Strategy Performance Tracking

Log which strategy contributed the top result:

```typescript
// In MultiStrategySearch.search(), track strategy contribution
const strategyContribution = new Map<SearchStrategy, number>();
for (const result of finalResults) {
  const count = strategyContribution.get(result.source) || 0;
  strategyContribution.set(result.source, count + 1);
}
```

## Testing

```typescript
describe('Search auto-tuning', () => {
  it('should boost keyword weight for name queries', async () => {
    const parsed = queryParser.parse('EntityStore');
    const weights = search.adaptWeights(parsed, DEFAULT_WEIGHTS);
    expect(weights.keyword).toBeGreaterThan(DEFAULT_WEIGHTS.keyword);
  });

  it('should boost semantic weight for question queries', async () => {
    const parsed = queryParser.parse('how does the indexer work');
    const weights = search.adaptWeights(parsed, DEFAULT_WEIGHTS);
    expect(weights.semantic).toBeGreaterThan(DEFAULT_WEIGHTS.semantic);
  });

  it('should auto-enable graph for entity mentions', async () => {
    const parsed = queryParser.parse('EntityStore');
    parsed.entityMentions = [{ text: 'EntityStore', type: 'code' }];
    const strategies = search.selectStrategies(parsed, ['keyword', 'semantic']);
    expect(strategies).toContain('graph');
  });

  it('should adapt weights from feedback', async () => {
    const manager = new AdaptiveWeightManager();
    // Simulate keyword strategy being consistently useful
    for (let i = 0; i < 20; i++) {
      manager.updateFromFeedback({
        retrievalStrategies: ['keyword'],
        wasUseful: true
      } as any);
    }
    const weights = manager.getWeights();
    expect(weights.keyword).toBeGreaterThan(1.0);
  });
});
```

## Success Criteria

- Name queries automatically prioritize keyword strategy
- Conceptual queries automatically prioritize semantic strategy
- Graph strategy auto-enabled when entity mentions detected
- Feedback loop adjusts weights over 100+ queries
- No degradation for queries without adaptation signals
