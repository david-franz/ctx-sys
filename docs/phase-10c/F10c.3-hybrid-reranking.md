# F10c.3 Hybrid Reranking Pipeline

**Phase**: 10c - Retrieval Quality Improvements
**Priority**: High
**Dependencies**: F10c.1, F10c.2

## Problem

The current RRF (Reciprocal Rank Fusion) is a simple rank-based merge that doesn't consider the actual content of results. After initial retrieval, there's no reranking step to filter out irrelevant results or boost highly relevant ones. This leads to noisy results where FTS substring matches rank alongside genuine semantic matches.

### Observed Behavior

```
context_query({ query: "how does entity search work" })
→ Returns: types.ts, context-expander.ts, AppContext (via FTS substring)
→ Expected: EntityStore.search(), MultiStrategySearch, search flow
```

### Root Cause

1. RRF only considers rank position, not content relevance
2. No cross-encoder or content-based reranking after retrieval
3. FTS results can have high rank from incidental keyword matches
4. No query-result relevance scoring after fusion

## Implementation Plan

### Step 1: Add Lightweight Reranker Interface

**File**: `src/retrieval/reranker.ts` (new)

```typescript
export interface RerankerResult {
  entityId: string;
  originalScore: number;
  rerankedScore: number;
  source: SearchStrategy;
}

export interface Reranker {
  rerank(
    query: string,
    candidates: SearchResult[],
    options?: { limit?: number }
  ): Promise<RerankerResult[]>;
}
```

### Step 2: Implement Heuristic Reranker

A fast, no-model reranker that uses content signals:

```typescript
export class HeuristicReranker implements Reranker {
  async rerank(query: string, candidates: SearchResult[]): Promise<RerankerResult[]> {
    const queryTerms = this.extractTerms(query);

    return candidates.map(candidate => {
      let boost = 0;

      // Exact name match boost
      if (candidate.entity.name.toLowerCase() === query.toLowerCase()) {
        boost += 2.0;
      }

      // Name contains query terms
      const nameLower = candidate.entity.name.toLowerCase();
      for (const term of queryTerms) {
        if (nameLower.includes(term)) boost += 0.5;
      }

      // Summary relevance
      if (candidate.entity.summary) {
        const summaryLower = candidate.entity.summary.toLowerCase();
        const termHits = queryTerms.filter(t => summaryLower.includes(t)).length;
        boost += (termHits / queryTerms.length) * 0.3;
      }

      // Penalize very short content (likely stubs)
      if (candidate.entity.content && candidate.entity.content.length < 50) {
        boost -= 0.3;
      }

      // Boost entities with more connections (higher importance)
      const connectionCount = candidate.entity.metadata?.connectionCount || 0;
      if (connectionCount > 5) boost += 0.2;

      return {
        entityId: candidate.entity.id,
        originalScore: candidate.score,
        rerankedScore: candidate.score + boost,
        source: candidate.source
      };
    }).sort((a, b) => b.rerankedScore - a.rerankedScore);
  }

  private extractTerms(query: string): string[] {
    return query.toLowerCase()
      .split(/\s+/)
      .filter(t => t.length > 2)
      .filter(t => !STOP_WORDS.has(t));
  }
}
```

### Step 3: Optional LLM-Based Reranker

For higher quality when an LLM is available:

```typescript
export class LLMReranker implements Reranker {
  constructor(private provider: SummarizationProvider) {}

  async rerank(query: string, candidates: SearchResult[]): Promise<RerankerResult[]> {
    // Score each candidate's relevance to query using LLM
    const prompt = `Rate relevance 0-10 of each result to query "${query}":\n` +
      candidates.map((c, i) => `${i+1}. ${c.entity.name} (${c.entity.type}): ${c.entity.summary || ''}`).join('\n') +
      '\nRespond with JSON: [{"index": 1, "score": 8}, ...]';

    const response = await this.provider.summarize(prompt, {
      entityType: 'reranking', name: 'rerank',
      maxTokens: 200, temperature: 0
    });

    // Parse scores and merge with original scores
    const scores = JSON.parse(response);
    return candidates.map((c, i) => ({
      entityId: c.entity.id,
      originalScore: c.score,
      rerankedScore: (scores[i]?.score || 5) / 10,
      source: c.source
    })).sort((a, b) => b.rerankedScore - a.rerankedScore);
  }
}
```

### Step 4: Integrate into MultiStrategySearch

**File**: `src/retrieval/multi-strategy-search.ts`

```typescript
export class MultiStrategySearch {
  constructor(
    private entityStore: EntityStore,
    private embeddingManager: EmbeddingManager,
    private graphTraversal?: GraphTraversal,
    queryParser?: QueryParser,
    private reranker?: Reranker  // Add reranker
  ) { ... }

  async search(query: string, options?: MultiSearchOptions): Promise<SearchResult[]> {
    // ... existing retrieval and fusion ...

    // Hydrate results
    const hydrated = await this.hydrateResults(limited);

    // Rerank if available
    if (this.reranker && hydrated.length > 1) {
      const reranked = await this.reranker.rerank(query, hydrated);
      return reranked.map(r => {
        const original = hydrated.find(h => h.entity.id === r.entityId)!;
        return { ...original, score: r.rerankedScore };
      });
    }

    return hydrated;
  }
}
```

## Testing

```typescript
describe('Hybrid reranking', () => {
  it('should boost exact name matches', async () => {
    const reranker = new HeuristicReranker();
    const results = await reranker.rerank('EntityStore', candidates);
    expect(results[0].entityId).toBe(entityStoreId);
  });

  it('should boost results with query terms in summary', async () => {
    const results = await reranker.rerank('database connection', candidates);
    const dbResult = results.find(r => r.entityId === dbConnectionId);
    expect(dbResult!.rerankedScore).toBeGreaterThan(dbResult!.originalScore);
  });

  it('should penalize stub entities', async () => {
    const results = await reranker.rerank('store', candidates);
    const stub = results.find(r => r.entityId === stubEntityId);
    expect(stub!.rerankedScore).toBeLessThan(stub!.originalScore);
  });
});
```

## Success Criteria

- Exact name matches always rank first
- Query term matches in name/summary boost relevance
- Stub/empty entities are deprioritized
- Heuristic reranker adds < 5ms latency
- Optional LLM reranker available for high-quality mode
