# F10c.2 Embedding Model Quality & Selection

**Phase**: 10c - Retrieval Quality Improvements
**Priority**: High
**Dependencies**: None

## Problem

The default embedding model `nomic-embed-text` (768 dims) produces low-quality matches for code and documentation queries. Semantic search results have relevance scores of ~0.006, indicating the embeddings don't capture code semantics well. The system has no way to benchmark or compare embedding models.

### Observed Behavior

```
context_query({ query: "entity store search" })
→ confidence: 0.006812 (extremely low)
→ Returns retrieval/types.ts as top result instead of EntityStore class
```

### Root Cause

1. `nomic-embed-text` is optimized for natural language, not code
2. No model benchmarking infrastructure exists
3. The embedding content (`type: name\n\nsummary\n\nstripped_code`) may not be optimal for all models
4. No model-specific prompt prefixes (some models like nomic require `search_query:` / `search_document:` prefixes)

## Implementation Plan

### Step 1: Add Model-Specific Prompt Prefixes

**File**: `src/embeddings/ollama.ts`

Nomic-embed-text specifically benefits from task-specific prefixes:

```typescript
// Model-specific prefix configurations
const MODEL_PREFIXES: Record<string, { query: string; document: string }> = {
  'nomic-embed-text': {
    query: 'search_query: ',
    document: 'search_document: '
  },
  'mxbai-embed-large': {
    query: 'Represent this sentence for searching relevant passages: ',
    document: ''
  }
};

async embed(texts: string[], options?: { isQuery?: boolean }): Promise<number[][]> {
  const prefixes = MODEL_PREFIXES[this.model];
  const prefix = options?.isQuery ? prefixes?.query || '' : prefixes?.document || '';
  const prefixedTexts = texts.map(t => prefix + t);
  // ... existing embed logic
}
```

### Step 2: Differentiate Query vs Document Embeddings

**File**: `src/embeddings/manager.ts`

```typescript
async findSimilar(query: string, options?: FindSimilarOptions): Promise<SimilarityResult[]> {
  // Embed with query prefix
  const queryEmbedding = await this.provider.embed([query], { isQuery: true });
  // ... rest of similarity search
}

async embedEntities(entities: Entity[]): Promise<void> {
  // Embed with document prefix
  const contents = entities.map(e => buildEmbeddingContent(e));
  const embeddings = await this.provider.embed(contents, { isQuery: false });
  // ...
}
```

### Step 3: Improve Embedding Content for Code

**File**: `src/embeddings/content-hasher.ts`

Improve what gets embedded for better semantic matching:

```typescript
export function buildEmbeddingContent(entity: Entity): string {
  const parts: string[] = [];

  // Include type and split name for better matching
  parts.push(`${entity.type}: ${splitIdentifier(entity.name)}`);

  // Include file context for code entities
  if (entity.filePath) {
    const pathParts = entity.filePath.split('/').slice(-2);
    parts.push(`in ${pathParts.join('/')}`);
  }

  // Include summary
  if (entity.summary) {
    parts.push(entity.summary);
  }

  // Include code with better formatting
  if (entity.content) {
    // Keep signatures and doc comments, strip implementation details
    const meaningful = extractMeaningfulCode(entity.content);
    parts.push(meaningful);
  }

  return parts.join('\n\n');
}

function extractMeaningfulCode(code: string): string {
  const lines = code.split('\n');
  const meaningful: string[] = [];
  let inDocComment = false;

  for (const line of lines) {
    const trimmed = line.trim();
    // Keep doc comments
    if (trimmed.startsWith('/**')) inDocComment = true;
    if (inDocComment || trimmed.startsWith('//') || trimmed.startsWith('*')) {
      meaningful.push(trimmed);
      if (trimmed.endsWith('*/')) inDocComment = false;
      continue;
    }
    // Keep signatures (function, class, interface, type, export)
    if (/^(export|async|function|class|interface|type|const|let|var|import)\b/.test(trimmed)) {
      meaningful.push(trimmed);
    }
  }

  return meaningful.slice(0, 60).join('\n');
}
```

### Step 4: Add Embedding Benchmark Tool

**File**: `src/embeddings/benchmark.ts` (new)

```typescript
export interface BenchmarkResult {
  model: string;
  dimensions: number;
  queries: Array<{
    query: string;
    expectedEntity: string;
    rank: number;         // Position in results (-1 if not found)
    score: number;        // Similarity score
  }>;
  avgRank: number;
  recall_at_5: number;   // % of expected entities found in top 5
  recall_at_10: number;
  embedTimeMs: number;
  searchTimeMs: number;
}

export class EmbeddingBenchmark {
  // Standard benchmark queries with expected results
  private static BENCHMARK_QUERIES = [
    { query: 'entity storage and retrieval', expected: 'EntityStore' },
    { query: 'embedding vector search', expected: 'EmbeddingManager' },
    { query: 'parse source code', expected: 'CodebaseIndexer' },
    { query: 'database connection', expected: 'DatabaseConnection' },
    { query: 'search across multiple strategies', expected: 'MultiStrategySearch' },
  ];

  async run(provider: EmbeddingProvider, entityStore: EntityStore): Promise<BenchmarkResult> {
    // Embed all entities, run benchmark queries, measure recall@k
  }
}
```

## Testing

```typescript
describe('Embedding model quality', () => {
  it('should use query prefix for nomic-embed-text', async () => {
    const provider = new OllamaEmbeddingProvider({ model: 'nomic-embed-text' });
    // Verify prefix is applied
  });

  it('should produce higher relevance with improved content', async () => {
    const result = await search.search('entity store');
    expect(result[0].score).toBeGreaterThan(0.3);
  });

  it('should rank exact conceptual matches higher', async () => {
    const results = await search.search('database storage');
    const storeIdx = results.findIndex(r => r.entity.name === 'EntityStore');
    expect(storeIdx).toBeLessThan(5);
  });
});
```

## Success Criteria

- Relevance scores for matching queries > 0.3 (up from 0.006)
- Benchmark recall@5 > 60% for standard queries
- Model-specific prefixes applied correctly
- No regression for non-code document search
