# F10c.1 FTS5 CamelCase/PascalCase Tokenizer

**Phase**: 10c - Retrieval Quality Improvements
**Priority**: Critical
**Dependencies**: None

## Problem

FTS5 uses the default tokenizer which treats `EntityStore` as a single token. Searching for "Entity" or "Store" alone won't match it. This is the most common naming convention in code (PascalCase, camelCase, snake_case) and FTS5's default tokenizer handles none of them well.

### Observed Behavior

```
search_entities({ query: "EntityStore", type: "class" })
→ Returns 10 results, none of which are EntityStore
  (FTS5 matches fragments in content, not the name itself)

search_entities({ query: "Entity" })
→ Misses EntityStore, EntityResolver, EntityType, etc.
```

### Root Cause

In `src/db/schema.ts` (line 274), the FTS5 table is created with no custom tokenizer:

```sql
CREATE VIRTUAL TABLE IF NOT EXISTS ${prefix}_entities_fts USING fts5(
  name, content, summary,
  content=${prefix}_entities,
  content_rowid=rowid
);
```

FTS5's default `unicode61` tokenizer splits on Unicode word boundaries only, which doesn't split `camelCase` or `PascalCase` identifiers.

## Implementation Plan

### Step 1: Add Pre-Processing to FTS5 Content

**File**: `src/db/schema.ts`

Since FTS5 doesn't support custom tokenizers in better-sqlite3, pre-process entity names before indexing by splitting compound identifiers into separate tokens while preserving the original.

```sql
-- Modify the FTS5 trigger to include split tokens
CREATE TRIGGER IF NOT EXISTS ${prefix}_entities_ai AFTER INSERT ON ${prefix}_entities BEGIN
  INSERT INTO ${prefix}_entities_fts(rowid, name, content, summary)
  VALUES (
    new.rowid,
    new.name,  -- Will be pre-processed in application layer
    new.content,
    new.summary
  );
END;
```

### Step 2: Create Identifier Splitter Utility

**File**: `src/utils/identifier-splitter.ts` (new)

```typescript
/**
 * Split compound identifiers into searchable tokens.
 *
 * Examples:
 *   "EntityStore" → "EntityStore Entity Store entity store"
 *   "getByName" → "getByName get By Name getbyname"
 *   "file_path" → "file_path file path"
 *   "XMLParser" → "XMLParser XML Parser xmlparser"
 */
export function splitIdentifier(name: string): string {
  const parts: string[] = [name];

  // PascalCase / camelCase splitting
  const camelParts = name
    .replace(/([a-z])([A-Z])/g, '$1 $2')    // camelCase
    .replace(/([A-Z]+)([A-Z][a-z])/g, '$1 $2') // XMLParser → XML Parser
    .split(/\s+/);

  if (camelParts.length > 1) {
    parts.push(...camelParts);
  }

  // snake_case splitting
  if (name.includes('_')) {
    parts.push(...name.split('_').filter(Boolean));
  }

  // kebab-case splitting
  if (name.includes('-')) {
    parts.push(...name.split('-').filter(Boolean));
  }

  // Add lowercase version for case-insensitive matching
  parts.push(name.toLowerCase());

  return [...new Set(parts)].join(' ');
}
```

### Step 3: Apply Splitting During Entity Indexing

**File**: `src/entities/store.ts`

Modify `create()`, `upsert()`, and `createMany()` to store split tokens in a searchable field, or modify the FTS5 sync triggers to use a generated column.

**Approach**: Add a `search_name` column to entities that contains the split tokens, and include it in the FTS5 index.

```typescript
// In create() and upsert():
const searchName = splitIdentifier(input.name);

this.db.run(
  `INSERT INTO ${this.tableName}
   (id, type, name, qualified_name, search_name, content, summary, ...)
   VALUES (?, ?, ?, ?, ?, ?, ?, ...)`,
  [id, input.type, input.name, qualifiedName, searchName, ...]
);
```

### Step 4: Update FTS5 Index to Use Split Names

**File**: `src/db/schema.ts`

```sql
CREATE VIRTUAL TABLE IF NOT EXISTS ${prefix}_entities_fts USING fts5(
  name, search_name, content, summary,
  content=${prefix}_entities,
  content_rowid=rowid
);
```

### Step 5: Rebuild FTS5 Index Command

Add a CLI command or service method to rebuild the FTS5 index after schema migration:

```typescript
async rebuildFTSIndex(projectId: string): Promise<void> {
  const prefix = sanitizeProjectId(projectId);
  this.db.exec(`INSERT INTO ${prefix}_entities_fts(${prefix}_entities_fts) VALUES('rebuild')`);
}
```

## Testing

```typescript
describe('FTS5 camelCase tokenizer', () => {
  it('should find PascalCase entities by partial name', async () => {
    await entityStore.create({ type: 'class', name: 'EntityStore', content: '...' });
    const results = await entityStore.search('Entity');
    expect(results.some(r => r.name === 'EntityStore')).toBe(true);
  });

  it('should find camelCase entities by word', async () => {
    await entityStore.create({ type: 'function', name: 'getByName', content: '...' });
    const results = await entityStore.search('Name');
    expect(results.some(r => r.name === 'getByName')).toBe(true);
  });

  it('should find snake_case entities by segment', async () => {
    await entityStore.create({ type: 'variable', name: 'file_path', content: '...' });
    const results = await entityStore.search('file');
    expect(results.some(r => r.name === 'file_path')).toBe(true);
  });

  it('should handle acronyms correctly', async () => {
    await entityStore.create({ type: 'class', name: 'XMLParser', content: '...' });
    const results = await entityStore.search('XML');
    expect(results.some(r => r.name === 'XMLParser')).toBe(true);
  });
});
```

## Success Criteria

- Searching "Entity" finds EntityStore, EntityResolver, EntityType
- Searching "Store" finds EntityStore, RelationshipStore, etc.
- Searching "get" finds getByName, getByFile, etc.
- PascalCase, camelCase, snake_case, and kebab-case all split correctly
- Original exact name match still works (highest priority)
- No performance regression on FTS5 queries
