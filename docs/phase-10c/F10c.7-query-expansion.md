# F10c.7 Query Understanding & Expansion

**Phase**: 10c - Retrieval Quality Improvements
**Priority**: Medium
**Dependencies**: F10c.1

## Problem

The current `QueryParser` extracts keywords and detects entity mentions, but doesn't expand queries with synonyms, related terms, or domain-specific aliases. A query for "database" won't find entities about "SQLite", "persistence", or "storage". The `expandedTerms` field exists in `ParsedQuery` but is never populated.

### Observed Behavior

```
context_query({ query: "database storage" })
→ Misses: DatabaseConnection, EntityStore, better-sqlite3 references
→ The query parser strips "database" and "storage" but doesn't expand
  to "SQLite", "persistence", "db", "SQL", etc.
```

### Root Cause

In `src/retrieval/query-parser.ts`, the `parse()` method extracts keywords and entity mentions but `expandedTerms` is always `[]`. The semantic search handles some of this via embedding similarity, but keyword search misses related terms entirely.

## Implementation Plan

### Step 1: Build Domain-Aware Synonym Map

**File**: `src/retrieval/query-expander.ts` (new)

```typescript
/**
 * Domain-specific synonym and alias expansions.
 */
const PROGRAMMING_SYNONYMS: Record<string, string[]> = {
  // Data storage
  'database': ['db', 'sqlite', 'sql', 'persistence', 'storage', 'store'],
  'storage': ['store', 'persistence', 'cache', 'repository'],
  'cache': ['memoize', 'memo', 'cached', 'store'],

  // Code structure
  'function': ['method', 'fn', 'handler', 'callback', 'procedure'],
  'class': ['type', 'interface', 'struct', 'model', 'entity'],
  'variable': ['const', 'let', 'var', 'constant', 'field', 'property'],
  'module': ['package', 'library', 'dependency', 'import'],

  // Operations
  'search': ['find', 'query', 'lookup', 'filter', 'match', 'retrieve'],
  'create': ['add', 'insert', 'new', 'make', 'build', 'generate'],
  'update': ['modify', 'edit', 'change', 'patch', 'set'],
  'delete': ['remove', 'drop', 'destroy', 'clear', 'purge'],

  // Architecture
  'api': ['endpoint', 'route', 'handler', 'controller', 'rest'],
  'test': ['spec', 'assertion', 'mock', 'stub', 'fixture'],
  'config': ['configuration', 'settings', 'options', 'preferences'],
  'error': ['exception', 'failure', 'fault', 'bug', 'issue'],

  // Patterns
  'index': ['indexer', 'indexing', 'catalog', 'scan'],
  'embed': ['embedding', 'vector', 'encode', 'represent'],
  'graph': ['network', 'relationship', 'edge', 'node', 'link'],
  'parse': ['parser', 'tokenize', 'lex', 'analyze', 'ast'],
};

export class QueryExpander {
  private synonyms: Map<string, Set<string>>;

  constructor(customSynonyms?: Record<string, string[]>) {
    this.synonyms = new Map();
    // Build bidirectional synonym map
    const all = { ...PROGRAMMING_SYNONYMS, ...customSynonyms };
    for (const [key, values] of Object.entries(all)) {
      const allTerms = [key, ...values];
      for (const term of allTerms) {
        const existing = this.synonyms.get(term.toLowerCase()) || new Set();
        for (const other of allTerms) {
          if (other.toLowerCase() !== term.toLowerCase()) {
            existing.add(other.toLowerCase());
          }
        }
        this.synonyms.set(term.toLowerCase(), existing);
      }
    }
  }

  expand(keywords: string[]): string[] {
    const expanded = new Set<string>();
    for (const keyword of keywords) {
      const synonyms = this.synonyms.get(keyword.toLowerCase());
      if (synonyms) {
        for (const syn of synonyms) {
          expanded.add(syn);
        }
      }
    }
    // Don't include original keywords (already in search)
    return [...expanded].filter(t => !keywords.map(k => k.toLowerCase()).includes(t));
  }
}
```

### Step 2: Project-Specific Term Learning

Learn project-specific aliases from indexed entities:

```typescript
export class ProjectTermLearner {
  /**
   * Build project-specific synonyms from entity names and relationships.
   *
   * Example: If "EntityStore" and "entity-store" both exist,
   * learn that "entitystore" ↔ "entity-store" ↔ "EntityStore"
   */
  async learnFromEntities(entityStore: EntityStore): Promise<Record<string, string[]>> {
    const entities = await entityStore.list({ limit: 1000 });
    const aliases: Record<string, string[]> = {};

    // Group entities with similar normalized names
    const normalized = new Map<string, string[]>();
    for (const entity of entities) {
      const key = entity.name.toLowerCase().replace(/[-_]/g, '');
      const list = normalized.get(key) || [];
      list.push(entity.name);
      normalized.set(key, list);
    }

    // Create alias entries for groups > 1
    for (const [, names] of normalized) {
      if (names.length > 1) {
        for (const name of names) {
          aliases[name] = names.filter(n => n !== name);
        }
      }
    }

    return aliases;
  }
}
```

### Step 3: Integrate with QueryParser

**File**: `src/retrieval/query-parser.ts`

```typescript
export class QueryParser {
  private expander: QueryExpander;

  constructor(expander?: QueryExpander) {
    this.expander = expander ?? new QueryExpander();
  }

  parse(query: string): ParsedQuery {
    // ... existing parsing logic ...

    // Expand keywords with synonyms
    const expandedTerms = this.expander.expand(keywords);

    return {
      originalQuery: query,
      normalizedQuery: normalized,
      keywords,
      entityMentions,
      expandedTerms,  // Now populated!
      intent
    };
  }
}
```

### Step 4: Use Expanded Terms in Both Strategies

The `MultiStrategySearch` already uses `expandedTerms` for semantic search (lines 213-233). Also use them for keyword search:

```typescript
// In keywordSearch():
if (parsed.expandedTerms.length > 0) {
  const expandedQuery = parsed.expandedTerms.join(' ');
  const expandedResults = await this.entityStore.search(expandedQuery, {
    limit: Math.floor(options.limit / 2)
  });
  for (let i = 0; i < expandedResults.length; i++) {
    results.push({
      entityId: expandedResults[i].id,
      score: 0.5 / (i + 1),  // Lower weight for expanded matches
      source: 'keyword'
    });
  }
}
```

## Testing

```typescript
describe('Query expansion', () => {
  it('should expand database to related terms', () => {
    const expander = new QueryExpander();
    const expanded = expander.expand(['database']);
    expect(expanded).toContain('sqlite');
    expect(expanded).toContain('storage');
    expect(expanded).toContain('persistence');
  });

  it('should expand bidirectionally', () => {
    const expander = new QueryExpander();
    const expanded = expander.expand(['sqlite']);
    expect(expanded).toContain('database');
  });

  it('should not include original terms', () => {
    const expander = new QueryExpander();
    const expanded = expander.expand(['search']);
    expect(expanded).not.toContain('search');
  });

  it('should improve retrieval for conceptual queries', async () => {
    const withExpansion = await search.search('database storage');
    const withoutExpansion = await searchNoExpand.search('database storage');
    // Expansion should find more relevant results
    expect(withExpansion.length).toBeGreaterThanOrEqual(withoutExpansion.length);
  });
});
```

## Success Criteria

- "database" queries find SQLite/persistence-related entities
- "search" queries find find/query/lookup methods
- Expanded terms have lower weight than original query terms
- Project-specific aliases learned from entity names
- No false positive expansion (unrelated synonyms)
