# F10c.8 Code-Aware Context Assembly

**Phase**: 10c - Retrieval Quality Improvements
**Priority**: Medium
**Dependencies**: F10c.3

## Problem

The context assembler treats all entities equally — a 2-line type alias gets the same treatment as a 200-line class. It truncates content at `maxContentLength: 500` chars regardless of entity type or importance. Functions are presented without their call signatures, classes without their method lists, and imports are stripped by default.

### Observed Behavior

```
context_query({ query: "EntityStore" })
→ Returns EntityStore content truncated to 500 chars
→ Missing: method signatures, constructor params, key methods
→ Missing: related files that import EntityStore
→ No distinction between "show me the interface" vs "show me the implementation"
```

### Root Cause

In `src/retrieval/context-assembler.ts` (line 85), `maxContentLength: 500` blindly truncates everything. The assembler doesn't understand code structure — it can't prioritize signatures over implementation, or expand important classes while summarizing minor utilities.

## Implementation Plan

### Step 1: Entity-Type-Aware Content Budgets

**File**: `src/retrieval/context-assembler.ts`

Different entity types deserve different token budgets:

```typescript
interface TypeBudgets {
  /** Classes/interfaces: show full signatures, constructor, public methods */
  class: number;     // 800 chars
  interface: number; // 600 chars
  /** Functions: show signature + doc comment */
  function: number;  // 400 chars
  method: number;    // 300 chars
  /** Files: show structure overview */
  file: number;      // 200 chars
  /** Documents: show full content */
  document: number;  // 1000 chars
  section: number;   // 800 chars
  /** Default for unknown types */
  default: number;   // 500 chars
}

const DEFAULT_TYPE_BUDGETS: TypeBudgets = {
  class: 800,
  interface: 600,
  function: 400,
  method: 300,
  file: 200,
  document: 1000,
  section: 800,
  default: 500
};
```

### Step 2: Smart Code Extraction

Extract the most meaningful parts of code entities:

```typescript
function extractCodeSummary(content: string, entityType: string, budget: number): string {
  const lines = content.split('\n');

  switch (entityType) {
    case 'class':
    case 'interface':
      return extractClassSummary(lines, budget);
    case 'function':
    case 'method':
      return extractFunctionSummary(lines, budget);
    default:
      return content.slice(0, budget);
  }
}

function extractClassSummary(lines: string[], budget: number): string {
  const parts: string[] = [];

  // 1. Doc comment (if present)
  let i = 0;
  if (lines[0]?.trim().startsWith('/**')) {
    while (i < lines.length && !lines[i].includes('*/')) {
      parts.push(lines[i]);
      i++;
    }
    parts.push(lines[i]); // closing */
    i++;
  }

  // 2. Class declaration line
  while (i < lines.length) {
    const line = lines[i].trim();
    if (line.match(/^(export\s+)?(abstract\s+)?class\s/)) {
      parts.push(lines[i]);
      break;
    }
    i++;
  }

  // 3. Constructor signature
  for (let j = i; j < lines.length; j++) {
    if (lines[j].trim().startsWith('constructor(')) {
      parts.push('  ' + lines[j].trim());
      // Include multi-line constructor params
      if (!lines[j].includes(')')) {
        while (j < lines.length - 1 && !lines[j].includes(')')) {
          j++;
          parts.push('  ' + lines[j].trim());
        }
      }
      break;
    }
  }

  // 4. Public method signatures (without bodies)
  for (let j = i; j < lines.length; j++) {
    const line = lines[j].trim();
    if (line.match(/^(async\s+)?(public\s+)?[\w]+\s*\(/) &&
        !line.startsWith('private') &&
        !line.startsWith('constructor')) {
      parts.push('  ' + line.replace(/\{.*$/, '').trim());
    }
  }

  const result = parts.join('\n');
  return result.length <= budget ? result : result.slice(0, budget) + '\n  // ...';
}

function extractFunctionSummary(lines: string[], budget: number): string {
  const parts: string[] = [];

  // Doc comment + signature (everything before the first {)
  let foundSignature = false;
  for (const line of lines) {
    parts.push(line);
    if (line.includes('{') && !line.trim().startsWith('*')) {
      foundSignature = true;
      break;
    }
    if (parts.join('\n').length > budget) break;
  }

  if (foundSignature) {
    // Replace body with placeholder
    parts[parts.length - 1] = parts[parts.length - 1].replace(/\{.*$/, '{ // ... }');
  }

  return parts.join('\n').slice(0, budget);
}
```

### Step 3: Relevance-Proportional Token Budget

Give more tokens to higher-relevance results:

```typescript
private allocateTokenBudgets(
  results: SearchResult[],
  totalBudget: number
): Map<string, number> {
  const budgets = new Map<string, number>();
  const totalScore = results.reduce((sum, r) => sum + r.score, 0);

  for (const result of results) {
    // Proportional to relevance score
    const proportion = totalScore > 0 ? result.score / totalScore : 1 / results.length;
    const typeBudget = DEFAULT_TYPE_BUDGETS[result.entity.type] || DEFAULT_TYPE_BUDGETS.default;

    // Budget is min of: proportional allocation, type maximum
    const allocated = Math.min(
      Math.round(proportion * totalBudget * 0.8), // 80% of total for content
      typeBudget * 4 // Allow up to 4x type budget for top results
    );

    budgets.set(result.entity.id, Math.max(allocated, 100)); // Minimum 100 chars
  }

  return budgets;
}
```

### Step 4: Include Related Context

When showing a class, include its key relationships:

```typescript
private async enrichWithRelated(
  result: SearchResult,
  graphTraversal?: GraphTraversal
): Promise<string> {
  if (!graphTraversal) return '';

  const neighborhood = await graphTraversal.getNeighborhood(result.entity.id, {
    maxDepth: 1,
    direction: 'outgoing'
  });

  if (neighborhood.relationships.length === 0) return '';

  const related = neighborhood.relationships
    .slice(0, 5)
    .map(r => {
      const target = neighborhood.entities.find(e => e.id === r.target);
      return target ? `  → ${r.type}: ${target.name}` : null;
    })
    .filter(Boolean);

  return related.length > 0 ? '\nRelationships:\n' + related.join('\n') : '';
}
```

## Testing

```typescript
describe('Code-aware context assembly', () => {
  it('should extract class signatures without bodies', async () => {
    const classContent = `
      export class EntityStore {
        constructor(private db: Database) {}
        async create(input: CreateInput): Promise<Entity> {
          // implementation...
        }
        async search(query: string): Promise<Entity[]> {
          // implementation...
        }
      }`;
    const summary = extractCodeSummary(classContent, 'class', 400);
    expect(summary).toContain('class EntityStore');
    expect(summary).toContain('constructor');
    expect(summary).toContain('create(');
    expect(summary).toContain('search(');
    expect(summary).not.toContain('implementation');
  });

  it('should give more tokens to higher-relevance results', () => {
    const budgets = allocateTokenBudgets([
      { score: 0.9, entity: { type: 'class' } },
      { score: 0.1, entity: { type: 'function' } }
    ], 2000);
    expect(budgets[0]).toBeGreaterThan(budgets[1] * 2);
  });

  it('should respect entity type budgets', () => {
    const docBudget = DEFAULT_TYPE_BUDGETS.document;
    const fileBudget = DEFAULT_TYPE_BUDGETS.file;
    expect(docBudget).toBeGreaterThan(fileBudget);
  });
});
```

## Success Criteria

- Class entities show signatures + public method list (not raw truncated code)
- Function entities show signature + doc comment
- Document entities get more space than code entities
- Higher-relevance results get proportionally more tokens
- Related entities shown when graph data available
- Total token budget still respected
