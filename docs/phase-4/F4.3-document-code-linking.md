# F4.3 Document-Code Linking

**Phase**: 4 - Document Intelligence
**Priority**: Medium
**Dependencies**: F4.1 Markdown Parsing, F1.3 Entity Storage, F2.4 Relationship Extraction

## Goal

Connect documentation references to actual code entities.

## Overview

Documentation often mentions code elements:
- "The `AuthService` class handles authentication"
- "See `src/utils/helpers.ts` for utility functions"
- "The `validateUser()` function checks credentials"

We want to create MENTIONS relationships between docs and code.

## Implementation

### File: `src/documents/linker.ts`

```typescript
import { MarkdownDocument, MarkdownSection } from './markdown-parser';
import { EntityStore, Entity } from '../entities/store';
import { RelationshipStore } from '../relationships/store';

export class DocumentCodeLinker {
  // Patterns to find code references
  private patterns = {
    backtickCode: /`([^`]+)`/g,
    filePath: /\b([\w/-]+\.(ts|js|py|go|rs|java|cpp|c|h))\b/g,
    className: /\b([A-Z][a-zA-Z0-9]+(?:Service|Controller|Manager|Handler|Provider|Factory|Store|Repository))\b/g,
    functionCall: /\b([a-z][a-zA-Z0-9]*)\(\)/g
  };

  constructor(
    private entityStore: EntityStore,
    private relationshipStore: RelationshipStore
  ) {}

  async linkDocument(
    document: MarkdownDocument,
    documentEntityId: string
  ): Promise<number> {
    let linksCreated = 0;

    for (const section of document.sections) {
      const links = await this.linkSection(section, documentEntityId);
      linksCreated += links;
    }

    return linksCreated;
  }

  async linkSection(
    section: MarkdownSection,
    documentEntityId: string
  ): Promise<number> {
    let linksCreated = 0;
    const mentionedRefs = this.findCodeReferences(section.content);

    for (const ref of mentionedRefs) {
      const entity = await this.resolveCodeReference(ref);
      if (entity) {
        await this.relationshipStore.create({
          sourceId: documentEntityId,
          targetId: entity.id,
          relationship: 'MENTIONS',
          weight: 1.0,
          metadata: {
            section: section.title,
            reference: ref
          }
        });
        linksCreated++;
      }
    }

    // Also link code blocks
    for (const codeBlock of section.codeBlocks) {
      const codeRefs = this.findCodeReferences(codeBlock.code);
      for (const ref of codeRefs) {
        const entity = await this.resolveCodeReference(ref);
        if (entity) {
          await this.relationshipStore.create({
            sourceId: documentEntityId,
            targetId: entity.id,
            relationship: 'MENTIONS',
            weight: 0.8,
            metadata: {
              section: section.title,
              inCodeBlock: true,
              language: codeBlock.language
            }
          });
          linksCreated++;
        }
      }
    }

    return linksCreated;
  }

  private findCodeReferences(content: string): string[] {
    const refs = new Set<string>();

    // Find backtick code
    for (const match of content.matchAll(this.patterns.backtickCode)) {
      refs.add(match[1]);
    }

    // Find file paths
    for (const match of content.matchAll(this.patterns.filePath)) {
      refs.add(match[1]);
    }

    // Find class-like names
    for (const match of content.matchAll(this.patterns.className)) {
      refs.add(match[1]);
    }

    // Find function calls
    for (const match of content.matchAll(this.patterns.functionCall)) {
      refs.add(match[1]);
    }

    return Array.from(refs);
  }

  private async resolveCodeReference(ref: string): Promise<Entity | null> {
    // Try exact qualified name match
    let entity = await this.entityStore.getByQualifiedName(ref);
    if (entity) return entity;

    // Try as file path
    entity = await this.entityStore.getByName(ref, 'file');
    if (entity) return entity;

    // Try as class/function name
    for (const type of ['class', 'function', 'interface', 'type'] as const) {
      entity = await this.entityStore.getByName(ref, type);
      if (entity) return entity;
    }

    // Try fuzzy match (lowercase, partial)
    const allEntities = await this.entityStore.search(ref, { limit: 1 });
    if (allEntities.length > 0) {
      return allEntities[0];
    }

    return null;
  }
}
```

### File: `src/mcp/tools/index-document.ts`

```typescript
export const indexDocumentTool: Tool = {
  name: 'index_document',
  description: 'Index a markdown document and link it to code.',
  inputSchema: {
    type: 'object',
    properties: {
      path: {
        type: 'string',
        description: 'Path to the markdown file'
      },
      project: {
        type: 'string',
        description: 'Target project'
      },
      extract_requirements: {
        type: 'boolean',
        description: 'Extract requirements from document'
      }
    },
    required: ['path']
  }
};
```

## Tasks

- [ ] Implement DocumentCodeLinker
- [ ] Implement code reference detection
- [ ] Implement fuzzy entity matching
- [ ] Create bidirectional MENTIONS relationships
- [ ] Add MCP tool handler
- [ ] Write unit tests

## Testing

```typescript
describe('DocumentCodeLinker', () => {
  it('should find backtick code references');
  it('should find file path references');
  it('should resolve references to entities');
  it('should create MENTIONS relationships');
});
```
