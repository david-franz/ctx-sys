# F4.2 Requirement Extraction

**Phase**: 4 - Document Intelligence
**Priority**: Medium
**Dependencies**: F4.1 Markdown Parsing

## Goal

Identify requirements, features, and user stories from documentation.

## Overview

Extract structured requirements from markdown documents:
- Explicit requirements sections
- User story patterns ("As a... I want... So that...")
- MoSCoW prioritization (Must/Should/Could/Won't)
- Acceptance criteria

## Data Model

```typescript
interface Requirement {
  id: string;
  type: 'requirement' | 'feature' | 'user-story' | 'constraint';
  title: string;
  description: string;
  priority?: 'must' | 'should' | 'could' | 'wont';
  status?: 'proposed' | 'accepted' | 'implemented' | 'deprecated';
  acceptanceCriteria?: string[];
  source: {
    file: string;
    section?: string;
    line?: number;
  };
}
```

## Implementation

### File: `src/documents/requirement-extractor.ts`

```typescript
import { MarkdownSection, MarkdownDocument } from './markdown-parser';
import { EntityStore } from '../entities/store';
import { generateId } from '../utils/id';

export class RequirementExtractor {
  // Patterns to detect requirements
  private patterns = {
    userStory: /as a[n]?\s+(.+?),?\s+i want\s+(.+?),?\s+so that\s+(.+)/i,
    must: /\b(must|shall|required)\b/i,
    should: /\b(should|recommended)\b/i,
    could: /\b(could|may|optional)\b/i,
    wont: /\b(won't|will not|out of scope)\b/i,
    acceptance: /acceptance criteria|given.+when.+then/i
  };

  private requirementHeadings = [
    'requirements',
    'features',
    'user stories',
    'functional requirements',
    'non-functional requirements',
    'specifications'
  ];

  constructor(private entityStore: EntityStore) {}

  async extractFromDocument(
    document: MarkdownDocument
  ): Promise<Requirement[]> {
    const requirements: Requirement[] = [];

    for (const section of document.sections) {
      // Check if this is a requirements section
      if (this.isRequirementSection(section)) {
        const sectionReqs = this.extractFromSection(section, document.filePath);
        requirements.push(...sectionReqs);
      }

      // Also check for inline user stories
      const userStories = this.extractUserStories(section, document.filePath);
      requirements.push(...userStories);
    }

    // Store as entities
    for (const req of requirements) {
      await this.storeRequirement(req);
    }

    return requirements;
  }

  private isRequirementSection(section: MarkdownSection): boolean {
    const titleLower = section.title.toLowerCase();
    return this.requirementHeadings.some(h => titleLower.includes(h));
  }

  private extractFromSection(
    section: MarkdownSection,
    filePath: string
  ): Requirement[] {
    const requirements: Requirement[] = [];
    const lines = section.content.split('\n');

    let currentReq: Partial<Requirement> | null = null;

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();

      // Check for list items (potential requirements)
      if (line.startsWith('-') || line.startsWith('*') || /^\d+\./.test(line)) {
        // Save previous requirement
        if (currentReq?.description) {
          requirements.push(this.finalizeRequirement(currentReq, filePath, section));
        }

        const content = line.replace(/^[-*\d.]+\s*/, '');
        currentReq = {
          id: generateId(),
          type: this.detectType(content),
          title: content.slice(0, 80),
          description: content,
          priority: this.detectPriority(content),
          acceptanceCriteria: []
        };
      } else if (currentReq && line) {
        // Continuation or acceptance criteria
        if (this.patterns.acceptance.test(line)) {
          currentReq.acceptanceCriteria?.push(line);
        } else {
          currentReq.description += ' ' + line;
        }
      }
    }

    // Don't forget last requirement
    if (currentReq?.description) {
      requirements.push(this.finalizeRequirement(currentReq, filePath, section));
    }

    return requirements;
  }

  private extractUserStories(
    section: MarkdownSection,
    filePath: string
  ): Requirement[] {
    const requirements: Requirement[] = [];
    const matches = section.content.matchAll(new RegExp(this.patterns.userStory, 'gi'));

    for (const match of matches) {
      const [full, role, want, benefit] = match;
      requirements.push({
        id: generateId(),
        type: 'user-story',
        title: `As a ${role}, I want ${want.slice(0, 50)}`,
        description: full,
        source: {
          file: filePath,
          section: section.title,
          line: section.startLine
        }
      });
    }

    return requirements;
  }

  private detectType(content: string): Requirement['type'] {
    if (this.patterns.userStory.test(content)) return 'user-story';
    if (/constraint|limitation|restriction/i.test(content)) return 'constraint';
    if (/feature|capability/i.test(content)) return 'feature';
    return 'requirement';
  }

  private detectPriority(content: string): Requirement['priority'] | undefined {
    if (this.patterns.must.test(content)) return 'must';
    if (this.patterns.should.test(content)) return 'should';
    if (this.patterns.could.test(content)) return 'could';
    if (this.patterns.wont.test(content)) return 'wont';
    return undefined;
  }

  private finalizeRequirement(
    partial: Partial<Requirement>,
    filePath: string,
    section: MarkdownSection
  ): Requirement {
    return {
      id: partial.id || generateId(),
      type: partial.type || 'requirement',
      title: partial.title || 'Untitled Requirement',
      description: partial.description || '',
      priority: partial.priority,
      acceptanceCriteria: partial.acceptanceCriteria?.length
        ? partial.acceptanceCriteria
        : undefined,
      source: {
        file: filePath,
        section: section.title,
        line: section.startLine
      }
    };
  }

  private async storeRequirement(req: Requirement): Promise<void> {
    await this.entityStore.create({
      type: req.type,
      name: req.title,
      qualifiedName: `${req.source.file}::${req.title}`,
      content: req.description,
      summary: req.description.slice(0, 200),
      filePath: req.source.file,
      startLine: req.source.line,
      metadata: {
        priority: req.priority,
        acceptanceCriteria: req.acceptanceCriteria,
        section: req.source.section
      }
    });
  }
}
```

## Tasks

- [ ] Implement RequirementExtractor
- [ ] Implement pattern-based detection
- [ ] Extract user stories
- [ ] Detect MoSCoW priority
- [ ] Store as searchable entities
- [ ] Write unit tests

## Testing

```typescript
describe('RequirementExtractor', () => {
  it('should identify requirements sections');
  it('should extract user stories');
  it('should detect priority levels');
  it('should extract acceptance criteria');
});
```
