# F4.1 Markdown Parsing

**Phase**: 4 - Document Intelligence
**Priority**: Medium
**Dependencies**: F1.3 Entity Storage

## Goal

Extract structure from markdown documents (headings, sections, code blocks, links).

## Overview

Markdown documents contain valuable context:
- Requirements specifications
- Design documents
- API documentation
- README files

## Data Model

```typescript
interface MarkdownSection {
  id: string;
  title: string;
  level: number;                 // Heading level (1-6)
  content: string;               // Section text content
  codeBlocks: CodeBlock[];
  links: Link[];
  parent?: string;               // Parent section ID
  children: string[];            // Child section IDs
  startLine: number;
  endLine: number;
}

interface CodeBlock {
  language?: string;
  code: string;
  startLine: number;
}

interface Link {
  text: string;
  url: string;
  isInternal: boolean;
}

interface MarkdownDocument {
  filePath: string;
  title?: string;
  sections: MarkdownSection[];
  frontmatter?: Record<string, unknown>;
}
```

## Implementation

### File: `src/documents/markdown-parser.ts`

```typescript
import { unified } from 'unified';
import remarkParse from 'remark-parse';
import remarkFrontmatter from 'remark-frontmatter';
import { visit } from 'unist-util-visit';
import { readFile } from 'fs/promises';
import yaml from 'yaml';

export class MarkdownParser {
  private processor = unified()
    .use(remarkParse)
    .use(remarkFrontmatter, ['yaml']);

  async parseFile(filePath: string): Promise<MarkdownDocument> {
    const content = await readFile(filePath, 'utf-8');
    return this.parseContent(content, filePath);
  }

  async parseContent(content: string, filePath?: string): Promise<MarkdownDocument> {
    const tree = this.processor.parse(content);
    const lines = content.split('\n');

    const document: MarkdownDocument = {
      filePath: filePath || '<inline>',
      sections: [],
      frontmatter: undefined
    };

    // Extract frontmatter
    visit(tree, 'yaml', (node: any) => {
      try {
        document.frontmatter = yaml.parse(node.value);
        document.title = document.frontmatter?.title;
      } catch {
        // Invalid YAML
      }
    });

    // Extract sections based on headings
    const sectionStack: MarkdownSection[] = [];
    let currentSection: MarkdownSection | null = null;

    visit(tree, (node: any) => {
      if (node.type === 'heading') {
        // Save previous section
        if (currentSection) {
          currentSection.endLine = node.position.start.line - 1;
          document.sections.push(currentSection);
        }

        // Determine parent
        while (sectionStack.length > 0 &&
               sectionStack[sectionStack.length - 1].level >= node.depth) {
          sectionStack.pop();
        }
        const parent = sectionStack[sectionStack.length - 1];

        // Create new section
        currentSection = {
          id: this.generateSectionId(node),
          title: this.extractText(node),
          level: node.depth,
          content: '',
          codeBlocks: [],
          links: [],
          parent: parent?.id,
          children: [],
          startLine: node.position.start.line,
          endLine: 0
        };

        // Add as child to parent
        if (parent) {
          parent.children.push(currentSection.id);
        }

        sectionStack.push(currentSection);
      } else if (currentSection) {
        // Add content to current section
        if (node.type === 'paragraph' || node.type === 'list') {
          currentSection.content += this.extractText(node) + '\n\n';
        } else if (node.type === 'code') {
          currentSection.codeBlocks.push({
            language: node.lang,
            code: node.value,
            startLine: node.position.start.line
          });
        } else if (node.type === 'link') {
          currentSection.links.push({
            text: this.extractText(node),
            url: node.url,
            isInternal: !node.url.startsWith('http')
          });
        }
      }
    });

    // Close last section
    if (currentSection) {
      currentSection.endLine = lines.length;
      document.sections.push(currentSection);
    }

    // Set document title from first h1 if not in frontmatter
    if (!document.title) {
      const h1 = document.sections.find(s => s.level === 1);
      document.title = h1?.title;
    }

    return document;
  }

  private extractText(node: any): string {
    if (node.value) return node.value;
    if (node.children) {
      return node.children.map((c: any) => this.extractText(c)).join('');
    }
    return '';
  }

  private generateSectionId(node: any): string {
    const text = this.extractText(node);
    return text
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-|-$/g, '');
  }
}
```

## Dependencies

```json
{
  "unified": "^11.0.0",
  "remark-parse": "^11.0.0",
  "remark-frontmatter": "^5.0.0",
  "unist-util-visit": "^5.0.0",
  "yaml": "^2.3.0"
}
```

## Tasks

- [ ] Implement MarkdownParser
- [ ] Extract hierarchical sections
- [ ] Extract code blocks with language
- [ ] Extract internal/external links
- [ ] Handle frontmatter (YAML)
- [ ] Write unit tests

## Testing

```typescript
describe('MarkdownParser', () => {
  it('should extract sections from headings');
  it('should build section hierarchy');
  it('should extract code blocks');
  it('should extract links');
  it('should parse frontmatter');
});
```
