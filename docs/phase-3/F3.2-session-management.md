# F3.2 Session Management

**Phase**: 3 - Conversation Memory
**Priority**: High
**Dependencies**: F3.1 Message Storage

## Goal

Manage conversation sessions with lifecycle states (active, archived, summarized).

## Overview

Sessions group related messages together. They have states:
- **active**: Current conversation, messages stored verbatim
- **archived**: Completed conversation, kept for history
- **summarized**: Archived + compressed into a summary

## Data Model

```typescript
interface Session {
  id: string;
  name?: string;
  status: 'active' | 'archived' | 'summarized';
  summary?: string;
  messageCount: number;
  createdAt: Date;
  updatedAt: Date;
  archivedAt?: Date;
}

interface SessionConfig {
  retention: number;          // Days to keep active sessions
  autoSummarize: boolean;     // Summarize on archive
  maxActiveMessages: number;  // Trigger summarization
}
```

## Implementation

### File: `src/conversation/session-manager.ts`

```typescript
import { DatabaseConnection } from '../db/connection';
import { generateId } from '../utils/id';

const DEFAULT_CONFIG: SessionConfig = {
  retention: 30,
  autoSummarize: true,
  maxActiveMessages: 100
};

export class SessionManager {
  private tableName: string;
  private currentSessionId: string | null = null;

  constructor(
    private db: DatabaseConnection,
    private projectId: string,
    private config: SessionConfig = DEFAULT_CONFIG
  ) {
    this.tableName = `${projectId}_sessions`;
  }

  async create(name?: string): Promise<Session> {
    const id = generateId();

    this.db.run(
      `INSERT INTO ${this.tableName} (id, name, status, message_count)
       VALUES (?, ?, 'active', 0)`,
      [id, name || null]
    );

    return this.get(id)!;
  }

  async get(id: string): Promise<Session | null> {
    const row = this.db.get<SessionRow>(
      `SELECT * FROM ${this.tableName} WHERE id = ?`,
      [id]
    );
    return row ? this.rowToSession(row) : null;
  }

  async getCurrent(): Promise<Session> {
    // Return existing current session
    if (this.currentSessionId) {
      const session = await this.get(this.currentSessionId);
      if (session && session.status === 'active') {
        return session;
      }
    }

    // Find most recent active session
    const row = this.db.get<SessionRow>(
      `SELECT * FROM ${this.tableName}
       WHERE status = 'active'
       ORDER BY updated_at DESC
       LIMIT 1`
    );

    if (row) {
      this.currentSessionId = row.id;
      return this.rowToSession(row);
    }

    // Create new session
    const session = await this.create();
    this.currentSessionId = session.id;
    return session;
  }

  async setCurrent(id: string): Promise<void> {
    const session = await this.get(id);
    if (!session) {
      throw new Error(`Session not found: ${id}`);
    }
    this.currentSessionId = id;
  }

  async list(status?: Session['status']): Promise<Session[]> {
    let sql = `SELECT * FROM ${this.tableName}`;
    const params: unknown[] = [];

    if (status) {
      sql += ' WHERE status = ?';
      params.push(status);
    }

    sql += ' ORDER BY updated_at DESC';

    const rows = this.db.all<SessionRow>(sql, params);
    return rows.map(this.rowToSession);
  }

  async update(
    id: string,
    updates: Partial<Pick<Session, 'name' | 'status' | 'summary'>>
  ): Promise<Session> {
    const session = await this.get(id);
    if (!session) {
      throw new Error(`Session not found: ${id}`);
    }

    const setClauses: string[] = ['updated_at = CURRENT_TIMESTAMP'];
    const params: unknown[] = [];

    if (updates.name !== undefined) {
      setClauses.push('name = ?');
      params.push(updates.name);
    }
    if (updates.status !== undefined) {
      setClauses.push('status = ?');
      params.push(updates.status);
      if (updates.status === 'archived' || updates.status === 'summarized') {
        setClauses.push('archived_at = CURRENT_TIMESTAMP');
      }
    }
    if (updates.summary !== undefined) {
      setClauses.push('summary = ?');
      params.push(updates.summary);
    }

    params.push(id);

    this.db.run(
      `UPDATE ${this.tableName} SET ${setClauses.join(', ')} WHERE id = ?`,
      params
    );

    return this.get(id)!;
  }

  async archive(id: string): Promise<Session> {
    return this.update(id, { status: 'archived' });
  }

  async delete(id: string): Promise<void> {
    // Delete messages first (cascade)
    this.db.run(
      `DELETE FROM ${this.projectId}_messages WHERE session_id = ?`,
      [id]
    );

    this.db.run(`DELETE FROM ${this.tableName} WHERE id = ?`, [id]);

    if (this.currentSessionId === id) {
      this.currentSessionId = null;
    }
  }

  async cleanup(): Promise<number> {
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - this.config.retention);

    // Get sessions to delete
    const toDelete = this.db.all<{ id: string }>(
      `SELECT id FROM ${this.tableName}
       WHERE status IN ('archived', 'summarized')
       AND archived_at < ?`,
      [cutoffDate.toISOString()]
    );

    // Delete each session and its messages
    for (const { id } of toDelete) {
      await this.delete(id);
    }

    return toDelete.length;
  }

  async getStats(): Promise<{
    active: number;
    archived: number;
    summarized: number;
    totalMessages: number;
  }> {
    const stats = this.db.get<{
      active: number;
      archived: number;
      summarized: number;
      total_messages: number;
    }>(`
      SELECT
        SUM(CASE WHEN status = 'active' THEN 1 ELSE 0 END) as active,
        SUM(CASE WHEN status = 'archived' THEN 1 ELSE 0 END) as archived,
        SUM(CASE WHEN status = 'summarized' THEN 1 ELSE 0 END) as summarized,
        SUM(message_count) as total_messages
      FROM ${this.tableName}
    `);

    return {
      active: stats?.active || 0,
      archived: stats?.archived || 0,
      summarized: stats?.summarized || 0,
      totalMessages: stats?.total_messages || 0
    };
  }

  private rowToSession(row: SessionRow): Session {
    return {
      id: row.id,
      name: row.name || undefined,
      status: row.status as Session['status'],
      summary: row.summary || undefined,
      messageCount: row.message_count,
      createdAt: new Date(row.created_at),
      updatedAt: new Date(row.updated_at),
      archivedAt: row.archived_at ? new Date(row.archived_at) : undefined
    };
  }
}

interface SessionRow {
  id: string;
  name: string | null;
  status: string;
  summary: string | null;
  message_count: number;
  created_at: string;
  updated_at: string;
  archived_at: string | null;
}
```

## Tasks

- [ ] Implement SessionManager class
- [ ] Add current session tracking
- [ ] Implement retention-based cleanup
- [ ] Add session statistics
- [ ] Write unit tests

## Testing

```typescript
describe('SessionManager', () => {
  it('should create session');
  it('should get or create current session');
  it('should list sessions by status');
  it('should archive session');
  it('should cleanup old sessions');
});
```
