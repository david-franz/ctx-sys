# F3.4 Decision Extraction

**Phase**: 3 - Conversation Memory
**Priority**: Low
**Dependencies**: F3.1 Message Storage, F3.3 Conversation Summarization

## Goal

Automatically identify and store decisions made in conversations for future reference.

## Overview

Decisions are important artifacts that should be easily retrievable:
- "We decided to use PostgreSQL instead of MongoDB"
- "The API will use JWT tokens for authentication"
- "We'll implement the feature in Phase 2"

## Data Model

```typescript
interface Decision {
  id: string;
  sessionId: string;
  messageId: string;           // Message where decision was stated
  description: string;         // The decision itself
  context?: string;            // Why/how it was decided
  alternatives?: string[];     // Other options considered
  relatedEntities: string[];   // Related code/docs
  createdAt: Date;
}
```

## Implementation

### File: `src/conversation/decision-extractor.ts`

```typescript
import { SummarizationProvider } from '../summarization/provider';
import { MessageStore, Message } from './message-store';
import { EntityStore } from '../entities/store';
import { RelationshipStore } from '../relationships/store';

export class DecisionExtractor {
  constructor(
    private provider: SummarizationProvider,
    private messageStore: MessageStore,
    private entityStore: EntityStore,
    private relationshipStore: RelationshipStore
  ) {}

  async extractFromMessage(message: Message): Promise<Decision[]> {
    // Check if message likely contains decisions
    if (!this.mightContainDecision(message.content)) {
      return [];
    }

    const prompt = this.buildExtractionPrompt(message.content);
    const response = await this.provider.summarize(prompt);
    const decisions = this.parseDecisions(response, message);

    // Store decisions as entities
    for (const decision of decisions) {
      await this.storeDecision(decision);
    }

    return decisions;
  }

  async extractFromSession(sessionId: string): Promise<Decision[]> {
    const messages = await this.messageStore.getBySession(sessionId);
    const decisions: Decision[] = [];

    for (const message of messages) {
      const messageDecisions = await this.extractFromMessage(message);
      decisions.push(...messageDecisions);
    }

    return decisions;
  }

  private mightContainDecision(content: string): boolean {
    const decisionPatterns = [
      /we('ll| will| should| decided| agreed)/i,
      /let's (go with|use|implement)/i,
      /the (decision|plan|approach) is/i,
      /i('ll| will) (use|implement|go with)/i
    ];
    return decisionPatterns.some(p => p.test(content));
  }

  private buildExtractionPrompt(content: string): string {
    return `Extract any decisions or agreements from this message.
For each decision, provide:
- DECISION: (the decision itself)
- CONTEXT: (why it was made, if mentioned)
- ALTERNATIVES: (other options considered, if any)

If no decisions are present, respond with "NO_DECISIONS".

MESSAGE:
${content}`;
  }

  private parseDecisions(response: string, message: Message): Decision[] {
    if (response.includes('NO_DECISIONS')) {
      return [];
    }

    const decisions: Decision[] = [];
    const blocks = response.split(/DECISION:/i).slice(1);

    for (const block of blocks) {
      const lines = block.trim().split('\n');
      const decision: Partial<Decision> = {
        sessionId: message.sessionId,
        messageId: message.id,
        createdAt: new Date()
      };

      for (const line of lines) {
        if (line.startsWith('CONTEXT:')) {
          decision.context = line.replace('CONTEXT:', '').trim();
        } else if (line.startsWith('ALTERNATIVES:')) {
          decision.alternatives = line
            .replace('ALTERNATIVES:', '')
            .split(',')
            .map(a => a.trim())
            .filter(Boolean);
        } else if (!decision.description) {
          decision.description = line.trim();
        }
      }

      if (decision.description) {
        decisions.push(decision as Decision);
      }
    }

    return decisions;
  }

  private async storeDecision(decision: Decision): Promise<void> {
    const entity = await this.entityStore.create({
      type: 'decision',
      name: decision.description.slice(0, 50),
      qualifiedName: `decision::${decision.id}`,
      content: decision.description,
      summary: decision.description,
      metadata: {
        sessionId: decision.sessionId,
        messageId: decision.messageId,
        context: decision.context,
        alternatives: decision.alternatives
      }
    });

    // Link to related entities if mentioned
    // This would require entity mention detection
  }
}
```

## Tasks

- [ ] Implement DecisionExtractor
- [ ] Design extraction prompt
- [ ] Implement decision patterns
- [ ] Link decisions to entities
- [ ] Store as searchable entities
- [ ] Write unit tests

## Testing

```typescript
describe('DecisionExtractor', () => {
  it('should detect messages with decisions');
  it('should extract decision details');
  it('should store decisions as entities');
});
```
