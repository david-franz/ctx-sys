# F3.1 Message Storage

**Phase**: 3 - Conversation Memory
**Priority**: High
**Dependencies**: F1.1 Database Schema

## Goal

Store conversation messages verbatim with metadata for context retrieval and history.

## Overview

Message storage captures the raw conversation between user and AI assistant. Each message includes:
- Full content (verbatim)
- Role (user/assistant/system)
- Session association
- Metadata (tool calls, model info, etc.)

## Data Model

```typescript
interface Message {
  id: string;
  sessionId: string;
  role: 'user' | 'assistant' | 'system';
  content: string;
  metadata?: {
    toolCalls?: ToolCall[];
    model?: string;
    tokens?: {
      input?: number;
      output?: number;
    };
    latency?: number;
  };
  createdAt: Date;
}

interface ToolCall {
  name: string;
  arguments: Record<string, unknown>;
  result?: unknown;
}

interface MessageQuery {
  sessionId?: string;
  role?: Message['role'];
  before?: Date;
  after?: Date;
  limit?: number;
  offset?: number;
}
```

## Implementation

### File: `src/conversation/message-store.ts`

```typescript
import { DatabaseConnection } from '../db/connection';
import { generateId } from '../utils/id';

export class MessageStore {
  private tableName: string;

  constructor(
    private db: DatabaseConnection,
    private projectId: string
  ) {
    this.tableName = `${projectId}_messages`;
  }

  async create(
    input: Omit<Message, 'id' | 'createdAt'>
  ): Promise<Message> {
    const id = generateId();

    this.db.run(
      `INSERT INTO ${this.tableName}
       (id, session_id, role, content, metadata)
       VALUES (?, ?, ?, ?, ?)`,
      [
        id,
        input.sessionId,
        input.role,
        input.content,
        JSON.stringify(input.metadata || {})
      ]
    );

    // Update session message count and timestamp
    this.db.run(
      `UPDATE ${this.projectId}_sessions
       SET message_count = message_count + 1,
           updated_at = CURRENT_TIMESTAMP
       WHERE id = ?`,
      [input.sessionId]
    );

    return this.get(id)!;
  }

  async get(id: string): Promise<Message | null> {
    const row = this.db.get<MessageRow>(
      `SELECT * FROM ${this.tableName} WHERE id = ?`,
      [id]
    );
    return row ? this.rowToMessage(row) : null;
  }

  async getBySession(
    sessionId: string,
    options?: { limit?: number; before?: string; after?: string }
  ): Promise<Message[]> {
    let sql = `SELECT * FROM ${this.tableName} WHERE session_id = ?`;
    const params: unknown[] = [sessionId];

    if (options?.before) {
      sql += ' AND created_at < ?';
      params.push(options.before);
    }

    if (options?.after) {
      sql += ' AND created_at > ?';
      params.push(options.after);
    }

    sql += ' ORDER BY created_at ASC';

    if (options?.limit) {
      sql += ' LIMIT ?';
      params.push(options.limit);
    }

    const rows = this.db.all<MessageRow>(sql, params);
    return rows.map(this.rowToMessage);
  }

  async getRecent(limit: number = 10): Promise<Message[]> {
    const rows = this.db.all<MessageRow>(
      `SELECT * FROM ${this.tableName}
       ORDER BY created_at DESC
       LIMIT ?`,
      [limit]
    );
    return rows.map(this.rowToMessage).reverse();
  }

  async getRecentBySession(
    sessionId: string,
    limit: number = 10
  ): Promise<Message[]> {
    const rows = this.db.all<MessageRow>(
      `SELECT * FROM ${this.tableName}
       WHERE session_id = ?
       ORDER BY created_at DESC
       LIMIT ?`,
      [sessionId, limit]
    );
    return rows.map(this.rowToMessage).reverse();
  }

  async search(query: string, options?: { sessionId?: string; limit?: number }): Promise<Message[]> {
    // Use FTS if available, otherwise LIKE
    let sql = `
      SELECT m.* FROM ${this.tableName} m
      WHERE m.content LIKE ?
    `;
    const params: unknown[] = [`%${query}%`];

    if (options?.sessionId) {
      sql += ' AND m.session_id = ?';
      params.push(options.sessionId);
    }

    sql += ' ORDER BY m.created_at DESC';

    if (options?.limit) {
      sql += ' LIMIT ?';
      params.push(options.limit);
    }

    const rows = this.db.all<MessageRow>(sql, params);
    return rows.map(this.rowToMessage);
  }

  async count(sessionId?: string): Promise<number> {
    let sql = `SELECT COUNT(*) as count FROM ${this.tableName}`;
    const params: unknown[] = [];

    if (sessionId) {
      sql += ' WHERE session_id = ?';
      params.push(sessionId);
    }

    const row = this.db.get<{ count: number }>(sql, params);
    return row?.count || 0;
  }

  async delete(id: string): Promise<void> {
    const message = await this.get(id);
    if (message) {
      this.db.run(`DELETE FROM ${this.tableName} WHERE id = ?`, [id]);

      // Update session message count
      this.db.run(
        `UPDATE ${this.projectId}_sessions
         SET message_count = message_count - 1
         WHERE id = ?`,
        [message.sessionId]
      );
    }
  }

  async deleteBySession(sessionId: string): Promise<number> {
    const result = this.db.run(
      `DELETE FROM ${this.tableName} WHERE session_id = ?`,
      [sessionId]
    );
    return result.changes;
  }

  async getConversationPairs(
    sessionId: string,
    limit?: number
  ): Promise<Array<{ user: Message; assistant: Message }>> {
    const messages = await this.getBySession(sessionId, { limit: limit ? limit * 2 : undefined });
    const pairs: Array<{ user: Message; assistant: Message }> = [];

    for (let i = 0; i < messages.length - 1; i++) {
      if (messages[i].role === 'user' && messages[i + 1].role === 'assistant') {
        pairs.push({
          user: messages[i],
          assistant: messages[i + 1]
        });
        i++; // Skip the assistant message
      }
    }

    return limit ? pairs.slice(-limit) : pairs;
  }

  private rowToMessage(row: MessageRow): Message {
    return {
      id: row.id,
      sessionId: row.session_id,
      role: row.role as Message['role'],
      content: row.content,
      metadata: JSON.parse(row.metadata || '{}'),
      createdAt: new Date(row.created_at)
    };
  }
}

interface MessageRow {
  id: string;
  session_id: string;
  role: string;
  content: string;
  metadata: string;
  created_at: string;
}
```

### File: `src/mcp/tools/store-message.ts`

```typescript
import { Tool } from '@modelcontextprotocol/sdk/types.js';

export const storeMessageTool: Tool = {
  name: 'store_message',
  description: 'Store a conversation message for context retrieval.',
  inputSchema: {
    type: 'object',
    properties: {
      content: {
        type: 'string',
        description: 'The message content'
      },
      role: {
        type: 'string',
        enum: ['user', 'assistant', 'system'],
        description: 'The message role'
      },
      session: {
        type: 'string',
        description: 'Session ID (creates new if not exists)'
      },
      metadata: {
        type: 'object',
        description: 'Additional metadata'
      },
      project: {
        type: 'string',
        description: 'Target project'
      }
    },
    required: ['content', 'role']
  }
};

export async function handleStoreMessage(
  context: AppContext,
  args: Record<string, unknown>
): Promise<unknown> {
  const project = await context.resolveProject(args.project as string | undefined);
  const sessionManager = context.getSessionManager(project.id);
  const messageStore = context.getMessageStore(project.id);

  // Get or create session
  let sessionId = args.session as string | undefined;
  if (!sessionId) {
    const currentSession = await sessionManager.getCurrent();
    sessionId = currentSession.id;
  }

  const message = await messageStore.create({
    sessionId,
    role: args.role as 'user' | 'assistant' | 'system',
    content: args.content as string,
    metadata: args.metadata as Record<string, unknown>
  });

  // Generate embedding for the message
  const embeddingManager = context.getEmbeddingManager(project.id);
  await embeddingManager.embed(message.id, message.content);

  return {
    success: true,
    message: {
      id: message.id,
      sessionId: message.sessionId,
      role: message.role,
      createdAt: message.createdAt.toISOString()
    }
  };
}
```

## Tasks

- [ ] Implement MessageStore class
- [ ] Add FTS indexing for message search
- [ ] Implement MCP tool handlers
- [ ] Add conversation pair extraction
- [ ] Integrate with embedding pipeline
- [ ] Write unit tests

## Testing

```typescript
describe('MessageStore', () => {
  it('should create message');
  it('should get messages by session');
  it('should get recent messages');
  it('should search messages');
  it('should extract conversation pairs');
  it('should update session message count');
});
```
