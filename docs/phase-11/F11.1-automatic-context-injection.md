# F11.1: Automatic Context Injection

## Goal

Automatically inject relevant context into AI assistant conversations without requiring explicit `context_query` calls. When users edit files, ask questions, or mention code patterns, ctx-sys proactively provides relevant context to the AI assistant.

## Current Limitation

```typescript
// Current: AI assistant must explicitly request context
User: "How does authentication work?"

AI: [Must call context_query tool manually]
→ context_query({ query: "authentication" })
→ [Receives results]
→ [Formulates response]

// Problem:
// 1. Adds latency (extra tool call round-trip)
// 2. AI might forget to query context
// 3. AI might query with wrong terms
// 4. Context not available for initial response planning
```

## Solution Overview

Implement automatic context injection through multiple trigger mechanisms:

1. **File Context** - When user opens/edits a file, inject related entities
2. **Conversation Context** - Analyze user messages and inject relevant context
3. **Symbol Mentions** - Detect code symbols mentioned and inject their context
4. **Session Continuity** - Inject relevant context from previous sessions
5. **IDE Integration** - Use VS Code extension to detect user activity

## Architecture

### Context Injection Flow

```
┌─────────────────────────────────────────────────────────────┐
│                    Trigger Sources                           │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────┐  ┌─────────────┐  ┌────────────────────┐   │
│  │  VS Code    │  │  User       │  │  Session           │   │
│  │  Activity   │  │  Message    │  │  History           │   │
│  └──────┬──────┘  └──────┬──────┘  └─────────┬──────────┘   │
└─────────┼────────────────┼───────────────────┼──────────────┘
          │                │                   │
          └────────────────┼───────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│                  Context Injection Engine                    │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────────┐  ┌─────────────────┐                   │
│  │  Trigger        │  │  Relevance      │                   │
│  │  Analyzer       │──│  Scorer         │                   │
│  └────────┬────────┘  └────────┬────────┘                   │
│           │                    │                            │
│           ▼                    ▼                            │
│  ┌─────────────────┐  ┌─────────────────┐                   │
│  │  Context        │  │  Token          │                   │
│  │  Retriever      │──│  Budget         │                   │
│  └────────┬────────┘  └────────┬────────┘                   │
│           │                    │                            │
│           └────────┬───────────┘                            │
│                    ▼                                        │
│           ┌─────────────────┐                               │
│           │  Context        │                               │
│           │  Formatter      │                               │
│           └────────┬────────┘                               │
└────────────────────┼────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│                  MCP System Prompt                           │
│  ┌──────────────────────────────────────────────────────┐   │
│  │  <auto-context>                                       │   │
│  │    ## Related Code                                    │   │
│  │    [Injected entities and relationships]              │   │
│  │                                                       │   │
│  │    ## Recent Decisions                                │   │
│  │    [From previous sessions]                           │   │
│  │                                                       │   │
│  │    ## File Context                                    │   │
│  │    [From currently open/edited files]                 │   │
│  │  </auto-context>                                      │   │
│  └──────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
```

### MCP Resources for Context Injection

```typescript
// The MCP protocol supports "resources" that can be dynamically provided
// We use this to inject context into the system prompt

resources: [
  {
    uri: "ctx-sys://context/auto",
    name: "Automatic Context",
    description: "Automatically injected context based on current activity",
    mimeType: "text/markdown"
  },
  {
    uri: "ctx-sys://context/file/{path}",
    name: "File Context",
    description: "Context related to a specific file"
  },
  {
    uri: "ctx-sys://context/session",
    name: "Session Context",
    description: "Context from current and recent sessions"
  }
]
```

## Implementation

### 1. Trigger Analyzer

```typescript
// src/context-injection/triggers.ts

export interface ContextTrigger {
  /** Trigger type */
  type: 'file_open' | 'file_edit' | 'message' | 'symbol_mention' | 'session_start';

  /** Relevance score (0-1) */
  relevance: number;

  /** Extracted entities/queries */
  queries: string[];

  /** Source information */
  source: {
    filePath?: string;
    message?: string;
    symbols?: string[];
    sessionId?: string;
  };
}

export class TriggerAnalyzer {
  /**
   * Analyze a user message for context triggers.
   */
  analyzeMessage(message: string): ContextTrigger[] {
    const triggers: ContextTrigger[] = [];

    // Extract code symbols (PascalCase, camelCase, snake_case)
    const symbols = this.extractSymbols(message);
    if (symbols.length > 0) {
      triggers.push({
        type: 'symbol_mention',
        relevance: 0.9,
        queries: symbols,
        source: { message, symbols }
      });
    }

    // Extract file paths
    const filePaths = this.extractFilePaths(message);
    for (const filePath of filePaths) {
      triggers.push({
        type: 'file_open',
        relevance: 0.95,
        queries: [filePath],
        source: { message, filePath }
      });
    }

    // Analyze intent for implicit queries
    const implicitQueries = this.extractImplicitQueries(message);
    if (implicitQueries.length > 0) {
      triggers.push({
        type: 'message',
        relevance: 0.7,
        queries: implicitQueries,
        source: { message }
      });
    }

    return triggers;
  }

  /**
   * Analyze IDE activity for context triggers.
   */
  analyzeActivity(activity: IDEActivity): ContextTrigger[] {
    const triggers: ContextTrigger[] = [];

    if (activity.type === 'file_open') {
      triggers.push({
        type: 'file_open',
        relevance: 0.8,
        queries: [activity.filePath],
        source: { filePath: activity.filePath }
      });
    }

    if (activity.type === 'file_edit') {
      triggers.push({
        type: 'file_edit',
        relevance: 0.95, // Edits are highly relevant
        queries: [activity.filePath, ...activity.changedSymbols || []],
        source: { filePath: activity.filePath }
      });
    }

    return triggers;
  }

  private extractSymbols(text: string): string[] {
    // Match PascalCase, camelCase, snake_case identifiers
    const patterns = [
      /\b[A-Z][a-zA-Z0-9]*\b/g,          // PascalCase
      /\b[a-z][a-zA-Z0-9]*[A-Z][a-zA-Z0-9]*\b/g,  // camelCase
      /\b[a-z][a-z0-9]*(?:_[a-z0-9]+)+\b/g  // snake_case
    ];

    const symbols = new Set<string>();
    for (const pattern of patterns) {
      const matches = text.match(pattern) || [];
      matches.forEach(m => symbols.add(m));
    }

    // Filter out common words
    const commonWords = new Set(['The', 'This', 'That', 'What', 'When', 'Where', 'How']);
    return [...symbols].filter(s => !commonWords.has(s));
  }

  private extractFilePaths(text: string): string[] {
    // Match file paths (with extensions)
    const pattern = /(?:^|[\s"'`])([./]?[\w-]+(?:\/[\w-]+)*\.\w{1,10})(?:[\s"'`]|$)/g;
    const matches = text.matchAll(pattern);
    return [...matches].map(m => m[1]);
  }

  private extractImplicitQueries(text: string): string[] {
    // Extract likely search terms from questions
    const queries: string[] = [];

    // "How does X work?" → query for X
    const howPattern = /how (?:does|do|is|are|can|could) (\w+(?:\s+\w+){0,3})/gi;
    for (const match of text.matchAll(howPattern)) {
      queries.push(match[1]);
    }

    // "What is X?" → query for X
    const whatPattern = /what (?:is|are) (?:the )?(\w+(?:\s+\w+){0,3})/gi;
    for (const match of text.matchAll(whatPattern)) {
      queries.push(match[1]);
    }

    return queries;
  }
}

interface IDEActivity {
  type: 'file_open' | 'file_edit' | 'file_close' | 'symbol_hover';
  filePath: string;
  changedSymbols?: string[];
  timestamp: Date;
}
```

### 2. Context Retriever

```typescript
// src/context-injection/retriever.ts

import { CoreService } from '../core/service';
import { ContextTrigger } from './triggers';

export interface InjectedContext {
  /** Context sections */
  sections: ContextSection[];

  /** Total token count */
  tokenCount: number;

  /** Sources for attribution */
  sources: ContextSource[];
}

export interface ContextSection {
  title: string;
  content: string;
  relevance: number;
}

export interface ContextSource {
  type: 'entity' | 'decision' | 'session';
  id: string;
  name: string;
  filePath?: string;
}

export class ContextRetriever {
  constructor(
    private coreService: CoreService,
    private options: {
      maxTokens?: number;
      maxSections?: number;
    } = {}
  ) {}

  /**
   * Retrieve context based on triggers.
   */
  async retrieveContext(triggers: ContextTrigger[]): Promise<InjectedContext> {
    const maxTokens = this.options.maxTokens || 4000;
    const maxSections = this.options.maxSections || 10;

    const sections: ContextSection[] = [];
    const sources: ContextSource[] = [];
    let tokenCount = 0;

    // Sort triggers by relevance
    const sortedTriggers = [...triggers].sort((a, b) => b.relevance - a.relevance);

    for (const trigger of sortedTriggers) {
      if (sections.length >= maxSections) break;

      const contextSections = await this.retrieveForTrigger(trigger);

      for (const section of contextSections) {
        const sectionTokens = this.estimateTokens(section.content);

        if (tokenCount + sectionTokens <= maxTokens) {
          sections.push(section);
          tokenCount += sectionTokens;
        }
      }
    }

    return { sections, tokenCount, sources };
  }

  private async retrieveForTrigger(trigger: ContextTrigger): Promise<ContextSection[]> {
    const sections: ContextSection[] = [];

    switch (trigger.type) {
      case 'file_open':
      case 'file_edit':
        // Get file context
        const fileContext = await this.getFileContext(trigger.source.filePath!);
        if (fileContext) {
          sections.push({
            title: `File: ${trigger.source.filePath}`,
            content: fileContext,
            relevance: trigger.relevance
          });
        }
        break;

      case 'symbol_mention':
        // Search for mentioned symbols
        for (const symbol of trigger.source.symbols || []) {
          const entities = await this.coreService.searchEntities({
            query: symbol,
            limit: 3
          });

          if (entities.length > 0) {
            sections.push({
              title: `Symbol: ${symbol}`,
              content: this.formatEntities(entities),
              relevance: trigger.relevance * 0.9
            });
          }
        }
        break;

      case 'message':
        // General context query
        for (const query of trigger.queries) {
          const result = await this.coreService.contextQuery({
            query,
            maxTokens: 1000
          });

          if (result.context) {
            sections.push({
              title: `Context: ${query}`,
              content: result.context,
              relevance: trigger.relevance
            });
          }
        }
        break;
    }

    return sections;
  }

  private async getFileContext(filePath: string): Promise<string | null> {
    // Get entities in this file
    const entities = await this.coreService.getEntitiesInFile(filePath);

    if (entities.length === 0) return null;

    const parts: string[] = [];

    for (const entity of entities) {
      parts.push(`### ${entity.type}: ${entity.name}`);
      if (entity.summary) {
        parts.push(entity.summary);
      }

      // Get related entities
      const related = await this.coreService.queryGraph({
        entity: entity.id,
        depth: 1,
        limit: 5
      });

      if (related.length > 0) {
        parts.push(`**Related:** ${related.map(r => r.name).join(', ')}`);
      }

      parts.push('');
    }

    return parts.join('\n');
  }

  private formatEntities(entities: any[]): string {
    return entities.map(e => {
      const lines = [`### ${e.type}: ${e.name}`];
      if (e.summary) lines.push(e.summary);
      if (e.filePath) lines.push(`*File: ${e.filePath}*`);
      return lines.join('\n');
    }).join('\n\n');
  }

  private estimateTokens(text: string): number {
    // Rough estimate: ~4 chars per token
    return Math.ceil(text.length / 4);
  }
}
```

### 3. Context Injection Engine

```typescript
// src/context-injection/engine.ts

import { TriggerAnalyzer, ContextTrigger } from './triggers';
import { ContextRetriever, InjectedContext } from './retriever';
import { CoreService } from '../core/service';

export interface ContextInjectionConfig {
  /** Enable automatic context injection */
  enabled: boolean;

  /** Maximum tokens for injected context */
  maxTokens?: number;

  /** Minimum relevance score to include */
  minRelevance?: number;

  /** Include session history */
  includeSessionHistory?: boolean;

  /** Include recent decisions */
  includeDecisions?: boolean;
}

export class ContextInjectionEngine {
  private triggerAnalyzer: TriggerAnalyzer;
  private contextRetriever: ContextRetriever;
  private recentTriggers: ContextTrigger[] = [];

  constructor(
    private coreService: CoreService,
    private config: ContextInjectionConfig
  ) {
    this.triggerAnalyzer = new TriggerAnalyzer();
    this.contextRetriever = new ContextRetriever(coreService, {
      maxTokens: config.maxTokens || 4000
    });
  }

  /**
   * Process a user message and generate injected context.
   */
  async processMessage(message: string): Promise<InjectedContext | null> {
    if (!this.config.enabled) return null;

    const triggers = this.triggerAnalyzer.analyzeMessage(message);

    // Filter by minimum relevance
    const relevantTriggers = triggers.filter(
      t => t.relevance >= (this.config.minRelevance || 0.5)
    );

    if (relevantTriggers.length === 0) return null;

    // Add recent triggers for context continuity
    const allTriggers = [...relevantTriggers, ...this.recentTriggers.slice(0, 3)];

    // Store current triggers for next message
    this.recentTriggers = relevantTriggers.slice(0, 5);

    return this.contextRetriever.retrieveContext(allTriggers);
  }

  /**
   * Process IDE activity and update context.
   */
  async processActivity(activity: any): Promise<void> {
    const triggers = this.triggerAnalyzer.analyzeActivity(activity);

    // Store for future messages
    this.recentTriggers = [
      ...triggers,
      ...this.recentTriggers.slice(0, 5 - triggers.length)
    ];
  }

  /**
   * Format injected context for MCP system prompt.
   */
  formatForSystemPrompt(context: InjectedContext): string {
    const lines: string[] = [
      '<auto-context>',
      '<!-- Automatically injected context from ctx-sys -->'
    ];

    // Group sections by type
    const grouped = this.groupSections(context.sections);

    for (const [title, sections] of Object.entries(grouped)) {
      lines.push(`\n## ${title}\n`);
      for (const section of sections) {
        lines.push(section.content);
        lines.push('');
      }
    }

    lines.push('</auto-context>');

    return lines.join('\n');
  }

  private groupSections(sections: any[]): Record<string, any[]> {
    const groups: Record<string, any[]> = {};

    for (const section of sections) {
      const groupTitle = section.title.split(':')[0];
      if (!groups[groupTitle]) groups[groupTitle] = [];
      groups[groupTitle].push(section);
    }

    return groups;
  }

  /**
   * Get current context for MCP resource.
   */
  async getCurrentContext(): Promise<string> {
    if (this.recentTriggers.length === 0) {
      return 'No context currently available. Start working with files or ask questions to build context.';
    }

    const context = await this.contextRetriever.retrieveContext(this.recentTriggers);
    return this.formatForSystemPrompt(context);
  }
}
```

### 4. MCP Integration

```typescript
// src/mcp/resources.ts

import { ContextInjectionEngine } from '../context-injection/engine';

export function registerContextResources(
  server: Server,
  engine: ContextInjectionEngine
): void {
  // Register automatic context resource
  server.setRequestHandler(ListResourcesRequestSchema, async () => ({
    resources: [
      {
        uri: 'ctx-sys://context/auto',
        name: 'Automatic Context',
        description: 'Automatically injected context based on current activity',
        mimeType: 'text/markdown'
      },
      {
        uri: 'ctx-sys://context/session',
        name: 'Session Context',
        description: 'Context from current and recent sessions'
      }
    ]
  }));

  // Handle resource reads
  server.setRequestHandler(ReadResourceRequestSchema, async (request) => {
    const uri = request.params.uri;

    if (uri === 'ctx-sys://context/auto') {
      const context = await engine.getCurrentContext();
      return {
        contents: [{
          uri,
          mimeType: 'text/markdown',
          text: context
        }]
      };
    }

    throw new Error(`Unknown resource: ${uri}`);
  });
}

// Register notification handler for IDE activity
server.setNotificationHandler('ctx-sys/activity', async (notification) => {
  await engine.processActivity(notification.params);
});
```

### 5. VS Code Extension Integration

```typescript
// vscode-extension/src/context-provider.ts

import * as vscode from 'vscode';

export class ContextProvider {
  private mcpClient: MCPClient;

  constructor(mcpClient: MCPClient) {
    this.mcpClient = mcpClient;

    // Watch for file opens
    vscode.window.onDidChangeActiveTextEditor(editor => {
      if (editor) {
        this.sendActivity({
          type: 'file_open',
          filePath: editor.document.uri.fsPath,
          timestamp: new Date()
        });
      }
    });

    // Watch for file edits
    vscode.workspace.onDidChangeTextDocument(event => {
      this.sendActivity({
        type: 'file_edit',
        filePath: event.document.uri.fsPath,
        changedSymbols: this.extractChangedSymbols(event),
        timestamp: new Date()
      });
    });
  }

  private async sendActivity(activity: any): Promise<void> {
    await this.mcpClient.sendNotification('ctx-sys/activity', activity);
  }

  private extractChangedSymbols(event: vscode.TextDocumentChangeEvent): string[] {
    // Parse changes to identify modified symbols
    const symbols: string[] = [];
    // Implementation details...
    return symbols;
  }
}
```

## Configuration

```yaml
# .ctx-sys/config.yaml
context_injection:
  enabled: true

  # Token budget for auto-injected context
  max_tokens: 4000

  # Minimum relevance score (0-1)
  min_relevance: 0.5

  # Include decisions from previous sessions
  include_decisions: true

  # Include session history context
  include_session_history: true

  # Trigger settings
  triggers:
    file_open: true
    file_edit: true
    symbol_mention: true
    implicit_queries: true
```

## MCP Protocol Extensions

```typescript
// New notification type for IDE activity
interface ActivityNotification {
  method: 'ctx-sys/activity';
  params: {
    type: 'file_open' | 'file_edit' | 'file_close' | 'symbol_hover';
    filePath: string;
    changedSymbols?: string[];
    timestamp: string;
  };
}

// New resource types
interface AutoContextResource {
  uri: 'ctx-sys://context/auto';
  name: 'Automatic Context';
  mimeType: 'text/markdown';
}
```

## Testing

```typescript
describe('Automatic Context Injection', () => {
  describe('TriggerAnalyzer', () => {
    it('extracts symbol mentions', () => {
      const triggers = analyzer.analyzeMessage(
        'How does the AuthService handle login?'
      );

      expect(triggers).toContainEqual(
        expect.objectContaining({
          type: 'symbol_mention',
          queries: expect.arrayContaining(['AuthService'])
        })
      );
    });

    it('extracts file paths', () => {
      const triggers = analyzer.analyzeMessage(
        'Look at src/auth/service.ts for the implementation'
      );

      expect(triggers).toContainEqual(
        expect.objectContaining({
          type: 'file_open',
          queries: ['src/auth/service.ts']
        })
      );
    });

    it('extracts implicit queries', () => {
      const triggers = analyzer.analyzeMessage(
        'How does authentication work in this app?'
      );

      expect(triggers).toContainEqual(
        expect.objectContaining({
          type: 'message',
          queries: expect.arrayContaining(['authentication'])
        })
      );
    });
  });

  describe('ContextRetriever', () => {
    it('retrieves file context', async () => {
      const context = await retriever.retrieveContext([{
        type: 'file_open',
        relevance: 0.9,
        queries: ['src/auth/service.ts'],
        source: { filePath: 'src/auth/service.ts' }
      }]);

      expect(context.sections).toHaveLength(1);
      expect(context.sections[0].title).toContain('src/auth/service.ts');
    });

    it('respects token budget', async () => {
      retriever = new ContextRetriever(coreService, { maxTokens: 500 });

      const context = await retriever.retrieveContext(manyTriggers);

      expect(context.tokenCount).toBeLessThanOrEqual(500);
    });
  });

  describe('ContextInjectionEngine', () => {
    it('maintains context continuity across messages', async () => {
      await engine.processMessage('Working on AuthService');
      const context = await engine.processMessage('Now I need to add validation');

      // Should include AuthService context even though not mentioned
      expect(context?.sections.some(s =>
        s.title.includes('AuthService')
      )).toBe(true);
    });
  });
});
```

## Success Metrics

| Metric | Target |
|--------|--------|
| Context injection latency | <200ms |
| Relevance of injected context | >70% rated helpful |
| Token efficiency | <30% wasted tokens |
| IDE activity detection | <50ms latency |
| False positive rate | <20% irrelevant injections |

## Dependencies

- F10.0: Core Service Layer (for context queries)
- F10.3: Smart Context Assembly (for formatting)
- F10.6: LLM Summaries (for entity summaries)
- F11.1: VS Code Extension (for IDE integration)

## Risks & Mitigations

| Risk | Mitigation |
|------|------------|
| Injecting irrelevant context | Minimum relevance threshold, user feedback |
| Token budget exceeded | Strict budget enforcement, prioritization |
| Stale context | Short TTL on triggers, refresh on activity |
| Performance impact | Async processing, caching |
| Privacy concerns | Local-only processing, no cloud required |

## Next Steps

1. Implement TriggerAnalyzer with symbol extraction
2. Build ContextRetriever with token budgeting
3. Create ContextInjectionEngine
4. Add MCP resource handlers
5. Integrate with VS Code extension
6. Add user feedback mechanism for relevance tuning
