# F1.5 MCP Server Scaffold

**Phase**: 1 - Foundation
**Priority**: Critical
**Dependencies**: F1.1-F1.4 (all foundation components)

## Goal

Create the MCP server that exposes ctx-sys functionality to AI assistants like Claude Code and VS Copilot.

## Overview

The MCP (Model Context Protocol) server is the primary interface for AI assistants. It exposes tools that can be called to:
- Query context
- Index codebases
- Store conversation history
- Manage projects

## MCP Protocol Basics

MCP uses JSON-RPC 2.0 over stdio or HTTP. Key concepts:
- **Tools**: Functions the AI can call
- **Resources**: Data the AI can read
- **Prompts**: Templates for common operations

For ctx-sys, we primarily use **Tools**.

## Tool Definitions

### Core Tools

| Tool | Description | Phase |
|------|-------------|-------|
| `context_query` | Smart context retrieval | 6 |
| `index_codebase` | Full codebase indexing | 2 |
| `index_document` | Index single document | 4 |
| `sync_from_git` | Incremental git sync | 2 |
| `store_message` | Save conversation turn | 3 |
| `get_history` | Get conversation history | 3 |
| `summarize_session` | Summarize conversation | 3 |
| `add_entity` | Add custom entity | 1 |
| `link_entities` | Create relationship | 5 |
| `query_graph` | Graph traversal | 5 |
| `create_project` | Create new project | 1 |
| `list_projects` | List all projects | 1 |
| `set_active_project` | Set active project | 1 |

## Implementation

### File: `src/mcp/server.ts`

```typescript
import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
  ErrorCode,
  McpError
} from '@modelcontextprotocol/sdk/types.js';
import { ToolRegistry } from './tool-registry';
import { AppContext } from '../context';

export class McpServer {
  private server: Server;
  private toolRegistry: ToolRegistry;

  constructor(private context: AppContext) {
    this.server = new Server(
      {
        name: 'ctx-sys',
        version: '0.1.0'
      },
      {
        capabilities: {
          tools: {}
        }
      }
    );

    this.toolRegistry = new ToolRegistry(context);
    this.setupHandlers();
  }

  private setupHandlers(): void {
    // List available tools
    this.server.setRequestHandler(ListToolsRequestSchema, async () => ({
      tools: this.toolRegistry.getToolDefinitions()
    }));

    // Handle tool calls
    this.server.setRequestHandler(CallToolRequestSchema, async (request) => {
      const { name, arguments: args } = request.params;

      try {
        const result = await this.toolRegistry.execute(name, args);
        return {
          content: [
            {
              type: 'text',
              text: typeof result === 'string' ? result : JSON.stringify(result, null, 2)
            }
          ]
        };
      } catch (error) {
        if (error instanceof McpError) {
          throw error;
        }
        throw new McpError(
          ErrorCode.InternalError,
          error instanceof Error ? error.message : 'Unknown error'
        );
      }
    });
  }

  async start(): Promise<void> {
    const transport = new StdioServerTransport();
    await this.server.connect(transport);
    console.error('ctx-sys MCP server started');
  }

  async stop(): Promise<void> {
    await this.server.close();
  }
}
```

### File: `src/mcp/tool-registry.ts`

```typescript
import { Tool } from '@modelcontextprotocol/sdk/types.js';
import { AppContext } from '../context';

type ToolHandler = (args: Record<string, unknown>) => Promise<unknown>;

interface RegisteredTool {
  definition: Tool;
  handler: ToolHandler;
}

export class ToolRegistry {
  private tools: Map<string, RegisteredTool> = new Map();

  constructor(private context: AppContext) {
    this.registerCoreTools();
  }

  register(definition: Tool, handler: ToolHandler): void {
    this.tools.set(definition.name, { definition, handler });
  }

  getToolDefinitions(): Tool[] {
    return Array.from(this.tools.values()).map(t => t.definition);
  }

  async execute(name: string, args: Record<string, unknown>): Promise<unknown> {
    const tool = this.tools.get(name);
    if (!tool) {
      throw new Error(`Unknown tool: ${name}`);
    }
    return tool.handler(args);
  }

  private registerCoreTools(): void {
    // Project management tools
    this.register(
      {
        name: 'create_project',
        description: 'Create a new project for context management',
        inputSchema: {
          type: 'object',
          properties: {
            name: {
              type: 'string',
              description: 'Unique project name (slug format)'
            },
            path: {
              type: 'string',
              description: 'Absolute path to project root directory'
            },
            config: {
              type: 'object',
              description: 'Optional configuration overrides'
            }
          },
          required: ['name', 'path']
        }
      },
      async (args) => {
        const { name, path, config } = args as {
          name: string;
          path: string;
          config?: Record<string, unknown>;
        };
        const project = await this.context.projectManager.create(name, path, config);
        return { success: true, project };
      }
    );

    this.register(
      {
        name: 'list_projects',
        description: 'List all registered projects',
        inputSchema: {
          type: 'object',
          properties: {}
        }
      },
      async () => {
        const projects = await this.context.projectManager.list();
        const active = await this.context.projectManager.getActive();
        return {
          projects: projects.map(p => ({
            name: p.name,
            path: p.path,
            lastIndexed: p.lastIndexedAt?.toISOString(),
            isActive: p.id === active?.id
          })),
          activeProject: active?.name
        };
      }
    );

    this.register(
      {
        name: 'set_active_project',
        description: 'Set the active project for subsequent operations',
        inputSchema: {
          type: 'object',
          properties: {
            name: {
              type: 'string',
              description: 'Project name or ID'
            }
          },
          required: ['name']
        }
      },
      async (args) => {
        const { name } = args as { name: string };
        await this.context.projectManager.setActive(name);
        return { success: true, activeProject: name };
      }
    );

    // Entity management tools
    this.register(
      {
        name: 'add_entity',
        description: 'Add a custom entity (concept, technology, pattern, etc.)',
        inputSchema: {
          type: 'object',
          properties: {
            type: {
              type: 'string',
              description: 'Entity type (concept, technology, pattern, person, etc.)'
            },
            name: {
              type: 'string',
              description: 'Entity name'
            },
            content: {
              type: 'string',
              description: 'Entity description or content'
            },
            metadata: {
              type: 'object',
              description: 'Additional metadata'
            },
            project: {
              type: 'string',
              description: 'Target project (default: active project)'
            }
          },
          required: ['type', 'name']
        }
      },
      async (args) => {
        const { type, name, content, metadata, project } = args as {
          type: string;
          name: string;
          content?: string;
          metadata?: Record<string, unknown>;
          project?: string;
        };

        const projectId = await this.resolveProjectId(project);
        const entityStore = this.context.getEntityStore(projectId);

        const entity = await entityStore.create({
          type: type as any,
          name,
          content,
          metadata
        });

        // Generate embedding if content provided
        if (content) {
          const embeddingManager = this.context.getEmbeddingManager(projectId);
          await embeddingManager.embed(entity.id, content);
        }

        return { success: true, entity };
      }
    );

    // Placeholder tools for later phases
    this.registerPlaceholder('context_query', 'Query context (Phase 6)');
    this.registerPlaceholder('index_codebase', 'Index codebase (Phase 2)');
    this.registerPlaceholder('index_document', 'Index document (Phase 4)');
    this.registerPlaceholder('sync_from_git', 'Sync from git (Phase 2)');
    this.registerPlaceholder('store_message', 'Store message (Phase 3)');
    this.registerPlaceholder('get_history', 'Get history (Phase 3)');
    this.registerPlaceholder('summarize_session', 'Summarize session (Phase 3)');
    this.registerPlaceholder('link_entities', 'Link entities (Phase 5)');
    this.registerPlaceholder('query_graph', 'Query graph (Phase 5)');
  }

  private registerPlaceholder(name: string, description: string): void {
    this.register(
      {
        name,
        description: `[Not yet implemented] ${description}`,
        inputSchema: { type: 'object', properties: {} }
      },
      async () => {
        throw new Error(`Tool "${name}" is not yet implemented`);
      }
    );
  }

  private async resolveProjectId(projectName?: string): Promise<string> {
    if (projectName) {
      const project = await this.context.projectManager.get(projectName);
      if (!project) throw new Error(`Project not found: ${projectName}`);
      return project.id;
    }

    const active = await this.context.projectManager.getActive();
    if (!active) throw new Error('No active project. Use set_active_project first.');
    return active.id;
  }
}
```

### File: `src/context.ts`

```typescript
import { DatabaseConnection } from './db/connection';
import { ProjectManager } from './project/manager';
import { EntityStore } from './entities/store';
import { EmbeddingManager } from './embeddings/manager';
import { EmbeddingProviderFactory } from './embeddings/factory';

export class AppContext {
  public readonly db: DatabaseConnection;
  public readonly projectManager: ProjectManager;

  private entityStores: Map<string, EntityStore> = new Map();
  private embeddingManagers: Map<string, EmbeddingManager> = new Map();

  constructor(dbPath: string) {
    this.db = new DatabaseConnection(dbPath);
    this.projectManager = new ProjectManager(this.db);
  }

  async initialize(): Promise<void> {
    await this.db.initialize();
  }

  getEntityStore(projectId: string): EntityStore {
    if (!this.entityStores.has(projectId)) {
      this.entityStores.set(projectId, new EntityStore(this.db, projectId));
    }
    return this.entityStores.get(projectId)!;
  }

  getEmbeddingManager(projectId: string): EmbeddingManager {
    if (!this.embeddingManagers.has(projectId)) {
      // Get project config for provider settings
      const provider = EmbeddingProviderFactory.create({
        provider: 'ollama',
        model: 'nomic-embed-text'
      });
      this.embeddingManagers.set(
        projectId,
        new EmbeddingManager(this.db, projectId, provider)
      );
    }
    return this.embeddingManagers.get(projectId)!;
  }
}
```

### File: `src/cli/serve.ts`

```typescript
import { Command } from 'commander';
import { McpServer } from '../mcp/server';
import { AppContext } from '../context';
import { getDbPath } from '../config';

export const serveCommand = new Command('serve')
  .description('Start the MCP server')
  .option('--stdio', 'Use stdio transport (default)')
  .option('--db <path>', 'Database path')
  .action(async (options) => {
    const dbPath = options.db || getDbPath();
    const context = new AppContext(dbPath);
    await context.initialize();

    const server = new McpServer(context);
    await server.start();

    // Handle shutdown
    process.on('SIGINT', async () => {
      await server.stop();
      process.exit(0);
    });
  });
```

## Claude Code Configuration

To use ctx-sys with Claude Code, add to `~/.claude/mcp.json`:

```json
{
  "mcpServers": {
    "ctx-sys": {
      "command": "ctx-sys",
      "args": ["serve", "--stdio"],
      "env": {}
    }
  }
}
```

Or for development:

```json
{
  "mcpServers": {
    "ctx-sys": {
      "command": "npx",
      "args": ["ts-node", "/path/to/ctx-sys/src/cli/index.ts", "serve", "--stdio"],
      "env": {}
    }
  }
}
```

## Dependencies

```json
{
  "@modelcontextprotocol/sdk": "^0.5.0"
}
```

## Tasks

- [ ] Install MCP SDK
- [ ] Implement McpServer class
- [ ] Implement ToolRegistry
- [ ] Implement AppContext
- [ ] Register Phase 1 tools
- [ ] Add placeholder tools for future phases
- [ ] Implement serve CLI command
- [ ] Add error handling and logging
- [ ] Write integration tests
- [ ] Test with Claude Code

## Testing

```typescript
describe('McpServer', () => {
  it('should list all registered tools');
  it('should handle tool calls');
  it('should return errors for unknown tools');
  it('should handle tool execution errors');
});

describe('ToolRegistry', () => {
  it('should register and execute tools');
  it('should resolve project ID from name');
  it('should use active project when not specified');
});

describe('Integration', () => {
  it('should create project via MCP');
  it('should list projects via MCP');
  it('should add entity via MCP');
});
```

## Notes

- MCP uses stdio by default for process-based servers
- All tool responses are wrapped in content blocks
- Errors should be thrown as McpError for proper error codes
- Tools should be idempotent where possible
- Consider adding request logging for debugging
