# F1.3 Basic Entity Storage

**Phase**: 1 - Foundation
**Priority**: Critical
**Dependencies**: F1.1 Database Schema

## Goal

Provide CRUD operations for entities with type-specific handling and content hashing for change detection.

## Overview

Entities are the core data unit in ctx-sys. Everything stored - code symbols, documents, concepts, messages - is an entity. This module provides the foundational storage layer that other modules build upon.

## Data Model

```typescript
type EntityType =
  // Code entities
  | 'file'
  | 'module'
  | 'class'
  | 'function'
  | 'method'
  | 'interface'
  | 'type'
  | 'variable'
  // Document entities
  | 'document'
  | 'section'
  | 'requirement'
  | 'feature'
  | 'user-story'
  // Conversation entities
  | 'session'
  | 'message'
  | 'decision'
  | 'question'
  // Domain entities
  | 'person'
  | 'concept'
  | 'technology'
  | 'pattern'
  | 'component'
  // Project entities
  | 'ticket'
  | 'bug'
  | 'task'
  | 'milestone';

interface Entity {
  id: string;
  type: EntityType;
  name: string;
  qualifiedName?: string;        // Full path identifier
  content?: string;              // Raw content
  summary?: string;              // AI-generated summary
  metadata: Record<string, unknown>;
  filePath?: string;             // For file-based entities
  startLine?: number;
  endLine?: number;
  hash?: string;                 // Content hash for change detection
  createdAt: Date;
  updatedAt: Date;
}

interface EntityCreateInput {
  type: EntityType;
  name: string;
  qualifiedName?: string;
  content?: string;
  summary?: string;
  metadata?: Record<string, unknown>;
  filePath?: string;
  startLine?: number;
  endLine?: number;
}

interface EntitySearchOptions {
  type?: EntityType | EntityType[];
  filePath?: string;
  limit?: number;
  offset?: number;
}
```

## Qualified Name Convention

Qualified names provide a unique, hierarchical identifier for entities:

```
// Code entities
src/auth/service.ts::AuthService::login
src/utils/helpers.ts::formatDate
src/types/user.ts::UserRole

// Document entities
docs/requirements.md::Authentication::OAuth

// Concept entities
concept::rate-limiting
technology::postgresql
```

## Implementation

### File: `src/entities/store.ts`

```typescript
import { DatabaseConnection } from '../db/connection';
import { generateId } from '../utils/id';
import { hashContent } from '../utils/hash';

export class EntityStore {
  private tableName: string;

  constructor(
    private db: DatabaseConnection,
    private projectId: string
  ) {
    this.tableName = `${projectId}_entities`;
  }

  async create(input: EntityCreateInput): Promise<Entity> {
    const id = generateId();
    const hash = input.content ? hashContent(input.content) : null;
    const qualifiedName = input.qualifiedName || this.generateQualifiedName(input);

    this.db.run(
      `INSERT INTO ${this.tableName}
       (id, type, name, qualified_name, content, summary, metadata, file_path, start_line, end_line, hash)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        id,
        input.type,
        input.name,
        qualifiedName,
        input.content || null,
        input.summary || null,
        JSON.stringify(input.metadata || {}),
        input.filePath || null,
        input.startLine || null,
        input.endLine || null,
        hash
      ]
    );

    return this.get(id)!;
  }

  async get(id: string): Promise<Entity | null> {
    const row = this.db.get<EntityRow>(
      `SELECT * FROM ${this.tableName} WHERE id = ?`,
      [id]
    );
    return row ? this.rowToEntity(row) : null;
  }

  async getByName(name: string, type?: EntityType): Promise<Entity | null> {
    let sql = `SELECT * FROM ${this.tableName} WHERE name = ?`;
    const params: unknown[] = [name];

    if (type) {
      sql += ' AND type = ?';
      params.push(type);
    }

    const row = this.db.get<EntityRow>(sql, params);
    return row ? this.rowToEntity(row) : null;
  }

  async getByQualifiedName(qualifiedName: string): Promise<Entity | null> {
    const row = this.db.get<EntityRow>(
      `SELECT * FROM ${this.tableName} WHERE qualified_name = ?`,
      [qualifiedName]
    );
    return row ? this.rowToEntity(row) : null;
  }

  async getByFile(filePath: string): Promise<Entity[]> {
    const rows = this.db.all<EntityRow>(
      `SELECT * FROM ${this.tableName} WHERE file_path = ? ORDER BY start_line`,
      [filePath]
    );
    return rows.map(this.rowToEntity);
  }

  async getByType(type: EntityType | EntityType[]): Promise<Entity[]> {
    const types = Array.isArray(type) ? type : [type];
    const placeholders = types.map(() => '?').join(', ');
    const rows = this.db.all<EntityRow>(
      `SELECT * FROM ${this.tableName} WHERE type IN (${placeholders})`,
      types
    );
    return rows.map(this.rowToEntity);
  }

  async update(
    id: string,
    updates: Partial<Pick<Entity, 'name' | 'content' | 'summary' | 'metadata' | 'startLine' | 'endLine'>>
  ): Promise<Entity> {
    const entity = await this.get(id);
    if (!entity) {
      throw new Error(`Entity not found: ${id}`);
    }

    const setClauses: string[] = ['updated_at = CURRENT_TIMESTAMP'];
    const params: unknown[] = [];

    if (updates.name !== undefined) {
      setClauses.push('name = ?');
      params.push(updates.name);
    }
    if (updates.content !== undefined) {
      setClauses.push('content = ?');
      setClauses.push('hash = ?');
      params.push(updates.content);
      params.push(hashContent(updates.content));
    }
    if (updates.summary !== undefined) {
      setClauses.push('summary = ?');
      params.push(updates.summary);
    }
    if (updates.metadata !== undefined) {
      setClauses.push('metadata = ?');
      params.push(JSON.stringify({ ...entity.metadata, ...updates.metadata }));
    }
    if (updates.startLine !== undefined) {
      setClauses.push('start_line = ?');
      params.push(updates.startLine);
    }
    if (updates.endLine !== undefined) {
      setClauses.push('end_line = ?');
      params.push(updates.endLine);
    }

    params.push(id);

    this.db.run(
      `UPDATE ${this.tableName} SET ${setClauses.join(', ')} WHERE id = ?`,
      params
    );

    return this.get(id)!;
  }

  async delete(id: string): Promise<void> {
    this.db.run(`DELETE FROM ${this.tableName} WHERE id = ?`, [id]);
  }

  async deleteByFile(filePath: string): Promise<number> {
    const result = this.db.run(
      `DELETE FROM ${this.tableName} WHERE file_path = ?`,
      [filePath]
    );
    return result.changes;
  }

  async deleteByType(type: EntityType): Promise<number> {
    const result = this.db.run(
      `DELETE FROM ${this.tableName} WHERE type = ?`,
      [type]
    );
    return result.changes;
  }

  async search(query: string, options?: EntitySearchOptions): Promise<Entity[]> {
    // Use FTS5 for full-text search
    let sql = `
      SELECT e.* FROM ${this.tableName} e
      JOIN ${this.projectId}_fts fts ON e.rowid = fts.rowid
      WHERE ${this.projectId}_fts MATCH ?
    `;
    const params: unknown[] = [query];

    if (options?.type) {
      const types = Array.isArray(options.type) ? options.type : [options.type];
      const placeholders = types.map(() => '?').join(', ');
      sql += ` AND e.type IN (${placeholders})`;
      params.push(...types);
    }

    if (options?.filePath) {
      sql += ' AND e.file_path = ?';
      params.push(options.filePath);
    }

    sql += ' ORDER BY rank';

    if (options?.limit) {
      sql += ' LIMIT ?';
      params.push(options.limit);
    }

    if (options?.offset) {
      sql += ' OFFSET ?';
      params.push(options.offset);
    }

    const rows = this.db.all<EntityRow>(sql, params);
    return rows.map(this.rowToEntity);
  }

  async exists(hash: string): Promise<boolean> {
    const row = this.db.get<{ count: number }>(
      `SELECT COUNT(*) as count FROM ${this.tableName} WHERE hash = ?`,
      [hash]
    );
    return (row?.count || 0) > 0;
  }

  async findByHash(hash: string): Promise<Entity | null> {
    const row = this.db.get<EntityRow>(
      `SELECT * FROM ${this.tableName} WHERE hash = ?`,
      [hash]
    );
    return row ? this.rowToEntity(row) : null;
  }

  async count(type?: EntityType): Promise<number> {
    let sql = `SELECT COUNT(*) as count FROM ${this.tableName}`;
    const params: unknown[] = [];

    if (type) {
      sql += ' WHERE type = ?';
      params.push(type);
    }

    const row = this.db.get<{ count: number }>(sql, params);
    return row?.count || 0;
  }

  private generateQualifiedName(input: EntityCreateInput): string {
    if (input.filePath) {
      // Code entity: file::class::method or file::function
      return `${input.filePath}::${input.name}`;
    }
    // Domain entity: type::name
    return `${input.type}::${input.name}`;
  }

  private rowToEntity(row: EntityRow): Entity {
    return {
      id: row.id,
      type: row.type as EntityType,
      name: row.name,
      qualifiedName: row.qualified_name || undefined,
      content: row.content || undefined,
      summary: row.summary || undefined,
      metadata: JSON.parse(row.metadata || '{}'),
      filePath: row.file_path || undefined,
      startLine: row.start_line || undefined,
      endLine: row.end_line || undefined,
      hash: row.hash || undefined,
      createdAt: new Date(row.created_at),
      updatedAt: new Date(row.updated_at)
    };
  }
}
```

### File: `src/utils/hash.ts`

```typescript
import { createHash } from 'crypto';

export function hashContent(content: string): string {
  return createHash('sha256').update(content).digest('hex').slice(0, 16);
}
```

## Tasks

- [ ] Implement EntityStore class
- [ ] Implement content hashing
- [ ] Implement qualified name generation
- [ ] Implement FTS search
- [ ] Add batch operations (createMany, deleteMany)
- [ ] Write unit tests
- [ ] Test FTS search quality

## Testing

```typescript
describe('EntityStore', () => {
  describe('create', () => {
    it('should create an entity with auto-generated ID');
    it('should compute content hash');
    it('should generate qualified name if not provided');
    it('should store metadata as JSON');
  });

  describe('get', () => {
    it('should retrieve entity by ID');
    it('should retrieve entity by name');
    it('should retrieve entity by qualified name');
    it('should return null for non-existent entity');
  });

  describe('getByFile', () => {
    it('should return all entities for a file');
    it('should order by start line');
  });

  describe('update', () => {
    it('should update specified fields');
    it('should recompute hash when content changes');
    it('should merge metadata');
    it('should update timestamp');
  });

  describe('delete', () => {
    it('should delete entity by ID');
    it('should delete all entities for a file');
  });

  describe('search', () => {
    it('should find entities matching query');
    it('should filter by type');
    it('should respect limit and offset');
  });

  describe('hash operations', () => {
    it('should detect existing content by hash');
    it('should find entity by hash');
  });
});
```

## Notes

- Content hashing uses truncated SHA-256 (16 chars) for reasonable uniqueness without excessive storage
- FTS5 uses Porter stemmer for English text matching
- Metadata is stored as JSON for flexibility with different entity types
- Qualified names should be unique within a project
