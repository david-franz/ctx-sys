# F1.2 Project Management

**Phase**: 1 - Foundation
**Priority**: Critical
**Dependencies**: F1.1 Database Schema

## Goal

Create, list, configure, and switch between projects with per-project configuration.

## Overview

Projects are the top-level organizational unit in ctx-sys. Each project:
- Maps to a codebase directory
- Has its own set of database tables
- Has configurable settings for indexing, summarization, etc.
- Can be switched as the "active" project

## Data Model

```typescript
interface Project {
  id: string;                    // UUID
  name: string;                  // Unique identifier (slug)
  path: string;                  // Absolute path to project root
  config: ProjectConfig;
  createdAt: Date;
  updatedAt: Date;
  lastIndexedAt?: Date;
  lastSyncCommit?: string;       // Last git commit that was synced
}

interface ProjectConfig {
  indexing: {
    mode: 'full' | 'incremental' | 'manual';
    watch: boolean;
    ignore: string[];            // Glob patterns to ignore
    languages?: string[];        // Limit to specific languages
  };
  summarization: {
    enabled: boolean;
    provider: 'ollama' | 'openai' | 'anthropic';
    model: string;
  };
  embeddings: {
    provider: 'ollama' | 'openai';
    model: string;
  };
  sessions: {
    retention: number;           // Days to keep active sessions
    autoSummarize: boolean;
  };
  retrieval: {
    defaultMaxTokens: number;
    strategies: ('vector' | 'graph' | 'fts')[];
  };
}
```

## Default Configuration

```typescript
const DEFAULT_CONFIG: ProjectConfig = {
  indexing: {
    mode: 'incremental',
    watch: false,
    ignore: [
      'node_modules',
      '.git',
      'dist',
      'build',
      '__pycache__',
      '*.min.js',
      '*.map'
    ]
  },
  summarization: {
    enabled: true,
    provider: 'ollama',
    model: 'qwen2.5-coder:7b'
  },
  embeddings: {
    provider: 'ollama',
    model: 'nomic-embed-text'
  },
  sessions: {
    retention: 30,
    autoSummarize: true
  },
  retrieval: {
    defaultMaxTokens: 4000,
    strategies: ['vector', 'graph', 'fts']
  }
};
```

## Implementation

### File: `src/project/manager.ts`

```typescript
import { DatabaseConnection } from '../db/connection';
import { createProjectTables, dropProjectTables } from '../db/schema';
import { generateId } from '../utils/id';

export class ProjectManager {
  private activeProjectId: string | null = null;

  constructor(private db: DatabaseConnection) {}

  async create(
    name: string,
    path: string,
    config?: Partial<ProjectConfig>
  ): Promise<Project> {
    // Validate name is unique
    const existing = await this.getByName(name);
    if (existing) {
      throw new Error(`Project "${name}" already exists`);
    }

    // Validate path exists
    if (!await this.validatePath(path)) {
      throw new Error(`Path does not exist: ${path}`);
    }

    const id = generateId();
    const mergedConfig = { ...DEFAULT_CONFIG, ...config };

    // Create project record
    this.db.run(
      `INSERT INTO projects (id, name, path, config) VALUES (?, ?, ?, ?)`,
      [id, name, path, JSON.stringify(mergedConfig)]
    );

    // Create project-specific tables
    await this.db.createProject(id);

    return this.get(id)!;
  }

  async get(idOrName: string): Promise<Project | null> {
    const row = this.db.get<ProjectRow>(
      `SELECT * FROM projects WHERE id = ? OR name = ?`,
      [idOrName, idOrName]
    );
    return row ? this.rowToProject(row) : null;
  }

  async getByName(name: string): Promise<Project | null> {
    const row = this.db.get<ProjectRow>(
      `SELECT * FROM projects WHERE name = ?`,
      [name]
    );
    return row ? this.rowToProject(row) : null;
  }

  async list(): Promise<Project[]> {
    const rows = this.db.all<ProjectRow>(`SELECT * FROM projects ORDER BY name`);
    return rows.map(this.rowToProject);
  }

  async update(
    idOrName: string,
    updates: Partial<Pick<Project, 'name' | 'path' | 'config' | 'lastIndexedAt' | 'lastSyncCommit'>>
  ): Promise<Project> {
    const project = await this.get(idOrName);
    if (!project) {
      throw new Error(`Project not found: ${idOrName}`);
    }

    const setClauses: string[] = ['updated_at = CURRENT_TIMESTAMP'];
    const params: unknown[] = [];

    if (updates.name !== undefined) {
      setClauses.push('name = ?');
      params.push(updates.name);
    }
    if (updates.path !== undefined) {
      setClauses.push('path = ?');
      params.push(updates.path);
    }
    if (updates.config !== undefined) {
      setClauses.push('config = ?');
      params.push(JSON.stringify({ ...project.config, ...updates.config }));
    }
    if (updates.lastIndexedAt !== undefined) {
      setClauses.push('last_indexed_at = ?');
      params.push(updates.lastIndexedAt.toISOString());
    }
    if (updates.lastSyncCommit !== undefined) {
      setClauses.push('last_sync_commit = ?');
      params.push(updates.lastSyncCommit);
    }

    params.push(project.id);

    this.db.run(
      `UPDATE projects SET ${setClauses.join(', ')} WHERE id = ?`,
      params
    );

    return this.get(project.id)!;
  }

  async delete(idOrName: string, keepData: boolean = false): Promise<void> {
    const project = await this.get(idOrName);
    if (!project) {
      throw new Error(`Project not found: ${idOrName}`);
    }

    // Drop project tables unless keepData is true
    if (!keepData) {
      this.db.exec(dropProjectTables(project.id));
    }

    // Delete project record
    this.db.run(`DELETE FROM projects WHERE id = ?`, [project.id]);

    // Clear active if this was active
    if (this.activeProjectId === project.id) {
      this.activeProjectId = null;
    }
  }

  async setActive(idOrName: string): Promise<void> {
    const project = await this.get(idOrName);
    if (!project) {
      throw new Error(`Project not found: ${idOrName}`);
    }
    this.activeProjectId = project.id;

    // Persist to config table
    this.db.run(
      `INSERT OR REPLACE INTO config (key, value) VALUES ('active_project', ?)`,
      [JSON.stringify(project.id)]
    );
  }

  async getActive(): Promise<Project | null> {
    if (this.activeProjectId) {
      return this.get(this.activeProjectId);
    }

    // Try to load from config
    const row = this.db.get<{ value: string }>(
      `SELECT value FROM config WHERE key = 'active_project'`
    );
    if (row) {
      this.activeProjectId = JSON.parse(row.value);
      return this.get(this.activeProjectId!);
    }

    return null;
  }

  private async validatePath(path: string): Promise<boolean> {
    // Check if path exists and is a directory
  }

  private rowToProject(row: ProjectRow): Project {
    return {
      id: row.id,
      name: row.name,
      path: row.path,
      config: JSON.parse(row.config),
      createdAt: new Date(row.created_at),
      updatedAt: new Date(row.updated_at),
      lastIndexedAt: row.last_indexed_at ? new Date(row.last_indexed_at) : undefined,
      lastSyncCommit: row.last_sync_commit || undefined
    };
  }
}
```

## CLI Commands

### `ctx-sys project create`

```bash
ctx-sys project create <name> --path <path> [options]

Options:
  --path <path>      Project root directory (required)
  --watch            Enable file watching
  --no-summarize     Disable AI summarization
  --provider <name>  Summarization provider (ollama|openai|anthropic)
```

### `ctx-sys project list`

```bash
ctx-sys project list [--json]

Output:
  NAME        PATH                    LAST INDEXED
  my-app      /home/user/my-app       2 hours ago
  api-server  /home/user/api-server   1 day ago
```

### `ctx-sys project switch`

```bash
ctx-sys project switch <name>
```

### `ctx-sys project delete`

```bash
ctx-sys project delete <name> [--keep-data]
```

### `ctx-sys project config`

```bash
ctx-sys project config <name> [--set key=value] [--get key]

Examples:
  ctx-sys project config my-app --get indexing.mode
  ctx-sys project config my-app --set indexing.watch=true
```

## MCP Tools

### `create_project`

```typescript
{
  name: 'create_project',
  description: 'Create a new project for context management',
  inputSchema: {
    type: 'object',
    properties: {
      name: { type: 'string', description: 'Unique project name' },
      path: { type: 'string', description: 'Absolute path to project root' },
      config: { type: 'object', description: 'Optional configuration overrides' }
    },
    required: ['name', 'path']
  }
}
```

### `list_projects`

```typescript
{
  name: 'list_projects',
  description: 'List all registered projects',
  inputSchema: {
    type: 'object',
    properties: {}
  }
}
```

### `set_active_project`

```typescript
{
  name: 'set_active_project',
  description: 'Set the active project for subsequent operations',
  inputSchema: {
    type: 'object',
    properties: {
      name: { type: 'string', description: 'Project name or ID' }
    },
    required: ['name']
  }
}
```

### `delete_project`

```typescript
{
  name: 'delete_project',
  description: 'Delete a project and optionally its data',
  inputSchema: {
    type: 'object',
    properties: {
      name: { type: 'string', description: 'Project name or ID' },
      keep_data: { type: 'boolean', description: 'Keep project data tables' }
    },
    required: ['name']
  }
}
```

## Tasks

- [ ] Implement ProjectManager class
- [ ] Implement default configuration merging
- [ ] Add path validation
- [ ] Implement CLI commands
- [ ] Implement MCP tool handlers
- [ ] Add project name validation (slug format)
- [ ] Write unit tests for ProjectManager
- [ ] Write integration tests for CLI commands

## Testing

```typescript
describe('ProjectManager', () => {
  it('should create a project with default config');
  it('should create a project with custom config');
  it('should reject duplicate project names');
  it('should reject invalid paths');
  it('should list all projects');
  it('should update project config');
  it('should delete project and tables');
  it('should keep data when delete with keepData=true');
  it('should set and get active project');
});
```

## Notes

- Project names should be slugified (lowercase, no spaces, alphanumeric + hyphens)
- Config updates should be deep-merged with existing config
- Active project is persisted so it survives process restarts
