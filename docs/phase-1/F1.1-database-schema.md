# F1.1 Database Schema

**Phase**: 1 - Foundation
**Priority**: Critical
**Dependencies**: None

## Goal

Establish the SQLite database structure with vector support using sqlite-vec.

## Overview

The database is the foundation of ctx-sys. It uses a single SQLite file with:
- Global tables for cross-project data
- Per-project tables (prefixed) for isolation
- sqlite-vec virtual tables for vector similarity search
- FTS5 virtual tables for full-text search

## Schema Design

### Global Tables

```sql
-- Projects registry
CREATE TABLE IF NOT EXISTS projects (
  id TEXT PRIMARY KEY,
  name TEXT UNIQUE NOT NULL,
  path TEXT NOT NULL,
  config JSON,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  last_indexed_at DATETIME,
  last_sync_commit TEXT
);

-- Embedding model registry (for model-agnostic vectors)
CREATE TABLE IF NOT EXISTS embedding_models (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL,
  provider TEXT NOT NULL,
  dimensions INTEGER NOT NULL,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Global config
CREATE TABLE IF NOT EXISTS config (
  key TEXT PRIMARY KEY,
  value JSON
);
```

### Per-Project Tables

These tables are created dynamically with a project ID prefix when a new project is initialized.

```sql
-- Entities (all types: code, docs, concepts, etc.)
CREATE TABLE IF NOT EXISTS {project}_entities (
  id TEXT PRIMARY KEY,
  type TEXT NOT NULL,           -- 'function', 'class', 'document', 'concept', etc.
  name TEXT NOT NULL,
  qualified_name TEXT,          -- Full path: 'src/auth/service.ts::AuthService::login'
  content TEXT,                 -- Raw content or summary
  summary TEXT,                 -- AI-generated summary
  metadata JSON,                -- Type-specific metadata
  file_path TEXT,               -- For code entities
  start_line INTEGER,
  end_line INTEGER,
  hash TEXT,                    -- Content hash for change detection
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Indexes for common queries
CREATE INDEX IF NOT EXISTS idx_{project}_entities_type ON {project}_entities(type);
CREATE INDEX IF NOT EXISTS idx_{project}_entities_file ON {project}_entities(file_path);
CREATE INDEX IF NOT EXISTS idx_{project}_entities_name ON {project}_entities(name);
CREATE INDEX IF NOT EXISTS idx_{project}_entities_qualified ON {project}_entities(qualified_name);

-- Vector embeddings (using sqlite-vec)
CREATE VIRTUAL TABLE IF NOT EXISTS {project}_vectors USING vec0(
  id TEXT PRIMARY KEY,
  entity_id TEXT,
  model_id TEXT,
  embedding FLOAT[1536]         -- Dimension configured per model
);

-- Graph relationships
CREATE TABLE IF NOT EXISTS {project}_relationships (
  id TEXT PRIMARY KEY,
  source_id TEXT NOT NULL,
  target_id TEXT NOT NULL,
  relationship TEXT NOT NULL,   -- 'CALLS', 'IMPORTS', 'MENTIONS', etc.
  weight REAL DEFAULT 1.0,
  metadata JSON,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (source_id) REFERENCES {project}_entities(id) ON DELETE CASCADE,
  FOREIGN KEY (target_id) REFERENCES {project}_entities(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_{project}_rel_source ON {project}_relationships(source_id);
CREATE INDEX IF NOT EXISTS idx_{project}_rel_target ON {project}_relationships(target_id);
CREATE INDEX IF NOT EXISTS idx_{project}_rel_type ON {project}_relationships(relationship);

-- Conversation sessions
CREATE TABLE IF NOT EXISTS {project}_sessions (
  id TEXT PRIMARY KEY,
  name TEXT,
  status TEXT DEFAULT 'active', -- 'active', 'archived', 'summarized'
  summary TEXT,                 -- Generated when archived
  message_count INTEGER DEFAULT 0,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  archived_at DATETIME
);

-- Conversation messages
CREATE TABLE IF NOT EXISTS {project}_messages (
  id TEXT PRIMARY KEY,
  session_id TEXT NOT NULL,
  role TEXT NOT NULL,           -- 'user', 'assistant', 'system'
  content TEXT NOT NULL,
  metadata JSON,                -- Tool calls, tokens, model, etc.
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (session_id) REFERENCES {project}_sessions(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_{project}_msg_session ON {project}_messages(session_id);
CREATE INDEX IF NOT EXISTS idx_{project}_msg_created ON {project}_messages(created_at);

-- AST cache (for incremental updates)
CREATE TABLE IF NOT EXISTS {project}_ast_cache (
  file_path TEXT PRIMARY KEY,
  file_hash TEXT NOT NULL,
  ast_json JSON,
  symbols JSON,                 -- Extracted symbol list
  parsed_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Full-text search on entities
CREATE VIRTUAL TABLE IF NOT EXISTS {project}_fts USING fts5(
  name,
  content,
  summary,
  content={project}_entities,
  content_rowid=rowid,
  tokenize='porter unicode61'
);

-- Triggers to keep FTS in sync
CREATE TRIGGER IF NOT EXISTS {project}_entities_ai AFTER INSERT ON {project}_entities BEGIN
  INSERT INTO {project}_fts(rowid, name, content, summary)
  VALUES (NEW.rowid, NEW.name, NEW.content, NEW.summary);
END;

CREATE TRIGGER IF NOT EXISTS {project}_entities_ad AFTER DELETE ON {project}_entities BEGIN
  INSERT INTO {project}_fts({project}_fts, rowid, name, content, summary)
  VALUES ('delete', OLD.rowid, OLD.name, OLD.content, OLD.summary);
END;

CREATE TRIGGER IF NOT EXISTS {project}_entities_au AFTER UPDATE ON {project}_entities BEGIN
  INSERT INTO {project}_fts({project}_fts, rowid, name, content, summary)
  VALUES ('delete', OLD.rowid, OLD.name, OLD.content, OLD.summary);
  INSERT INTO {project}_fts(rowid, name, content, summary)
  VALUES (NEW.rowid, NEW.name, NEW.content, NEW.summary);
END;
```

### Cross-Project Tables

```sql
-- Shared entities (common libraries, patterns)
CREATE TABLE IF NOT EXISTS shared_entities (
  id TEXT PRIMARY KEY,
  type TEXT NOT NULL,
  name TEXT NOT NULL,
  content TEXT,
  metadata JSON,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Cross-project links (explicit only)
CREATE TABLE IF NOT EXISTS cross_project_links (
  id TEXT PRIMARY KEY,
  source_project TEXT NOT NULL,
  source_entity_id TEXT NOT NULL,
  target_project TEXT NOT NULL,
  target_entity_id TEXT NOT NULL,
  relationship TEXT NOT NULL,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (source_project) REFERENCES projects(id),
  FOREIGN KEY (target_project) REFERENCES projects(id)
);
```

## Implementation

### File: `src/db/schema.ts`

```typescript
export const GLOBAL_SCHEMA = `...`; // Global tables SQL

export function createProjectTables(projectId: string): string {
  // Return SQL with projectId substituted
}

export function dropProjectTables(projectId: string): string {
  // Return DROP TABLE statements
}
```

### File: `src/db/connection.ts`

```typescript
import Database from 'better-sqlite3';

export class DatabaseConnection {
  private db: Database.Database;

  constructor(dbPath: string) {
    this.db = new Database(dbPath);
    this.db.pragma('journal_mode = WAL');
    this.db.pragma('foreign_keys = ON');
    this.loadExtensions();
  }

  private loadExtensions(): void {
    // Load sqlite-vec extension
    this.db.loadExtension('vec0');
  }

  async initialize(): Promise<void> {
    this.db.exec(GLOBAL_SCHEMA);
  }

  async createProject(projectId: string): Promise<void> {
    this.db.exec(createProjectTables(projectId));
  }

  // Transaction helpers
  transaction<T>(fn: () => T): T {
    return this.db.transaction(fn)();
  }

  // Query helpers
  run(sql: string, params?: unknown[]): Database.RunResult
  get<T>(sql: string, params?: unknown[]): T | undefined
  all<T>(sql: string, params?: unknown[]): T[]
}
```

### File: `src/db/migrations.ts`

```typescript
interface Migration {
  version: number;
  name: string;
  up: string;
  down: string;
}

export class MigrationManager {
  constructor(private db: DatabaseConnection) {}

  async getCurrentVersion(): Promise<number>
  async migrate(targetVersion?: number): Promise<void>
  async rollback(steps?: number): Promise<void>
}
```

## Dependencies

```json
{
  "better-sqlite3": "^9.0.0",
  "sqlite-vec": "^0.1.0"
}
```

## Tasks

- [ ] Install better-sqlite3 and sqlite-vec
- [ ] Implement DatabaseConnection class
- [ ] Implement schema creation functions
- [ ] Implement MigrationManager
- [ ] Write unit tests for schema creation
- [ ] Write unit tests for migrations
- [ ] Test sqlite-vec vector operations
- [ ] Test FTS5 search operations

## Testing

```typescript
describe('DatabaseConnection', () => {
  it('should create global tables on initialize');
  it('should create project tables with correct prefix');
  it('should enable foreign key constraints');
  it('should handle transactions correctly');
});

describe('MigrationManager', () => {
  it('should track migration versions');
  it('should apply migrations in order');
  it('should rollback migrations');
});
```

## Notes

- Using WAL mode for better concurrent read performance
- Foreign keys enabled for referential integrity
- sqlite-vec requires the extension to be compiled for the platform
- Consider bundling pre-compiled binaries or using a fallback
