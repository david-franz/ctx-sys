# F10g.3 Richer Relationship Extraction

**Phase**: 10g - Retrieval Foundations
**Priority**: High
**Dependencies**: None

## Problem

The AST relationship extractors already detect rich relationships (CALLS, IMPLEMENTS, EXTENDS, USES_TYPE), but the indexer only stores two types: CONTAINS (file → symbol) and IMPORTS (file → file). The extracted relationships from `TypeScriptRelationshipExtractor` and `PythonRelationshipExtractor` are computed then discarded.

This means graph search is nearly useless — traversing from an entity only finds its parent file and sibling imports, not the classes it extends, interfaces it implements, or functions it calls.

### What's Extracted But Not Stored

The AST extractors (`src/ast/relationships/`) detect:

| Relationship | Extractor Logic | Currently Stored? |
|-------------|----------------|-------------------|
| `imports` | File-level import statements | Yes (as IMPORTS) |
| `contains` | Class → methods/properties | Yes (as CONTAINS) |
| `calls` | Function/method call sites | **No** |
| `extends` | `class X extends Y` | **No** |
| `implements` | `class X implements Y` | **No** |
| `uses_type` | Parameter/return type references | **No** |
| `instantiates` | `new ClassName()` | **No** |
| `references` | Named import references | **No** |

### Why It Matters

Graph search starts from a mentioned entity and traverses relationships. With only CONTAINS and IMPORTS:
- "What calls this function?" → Can't answer
- "What implements this interface?" → Can't answer
- "What classes extend this base class?" → Can't answer
- Context expansion (`--expand`) can only add parent files, not related types

With richer relationships:
- Query "PaymentService" → graph finds `BaseService` (extends), `IPaymentProcessor` (implements), `OrderService` (calls)
- Context expansion adds the interface definition and base class automatically
- Graph search becomes a genuine knowledge graph, not just a file tree

## Implementation

### Step 1: Wire AST relationships into the indexer

**File**: `src/indexer/indexer.ts`

The indexer already calls `extractRelationships()` from the AST extractors but only processes `imports` and `contains` types. Wire the remaining types:

```typescript
// After existing CONTAINS and IMPORTS processing (~line 535):

// Store rich relationships from AST extraction
for (const rel of extractedRelationships) {
  if (['calls', 'extends', 'implements', 'uses_type', 'instantiates'].includes(rel.type)) {
    // Resolve target: the rel.target is a symbol name, need to find the entity
    const targetEntity = await this.resolveRelationshipTarget(rel.target, rel.sourceFile);
    if (targetEntity) {
      await this.relationshipStore.upsert({
        sourceId: rel.sourceEntityId,
        targetId: targetEntity.id,
        relationship: mapAstRelToGraph(rel.type),
        weight: rel.weight || 0.8,
        metadata: { line: rel.line, file: rel.sourceFile }
      });
    }
  }
}
```

### Step 2: Implement target resolution

**File**: `src/indexer/indexer.ts`

The tricky part — AST extractors give us symbol names (e.g., `extends BaseService`), but we need entity IDs. Resolution strategy:

```typescript
private async resolveRelationshipTarget(
  targetName: string,
  sourceFile: string
): Promise<Entity | null> {
  // 1. Try qualified name in same file
  const inFile = await this.entityStore.getByQualifiedName(`${sourceFile}::${targetName}`);
  if (inFile) return inFile;

  // 2. Try by name (any file)
  const byName = await this.entityStore.getByName(targetName);
  if (byName) return byName;

  // 3. Try search as fallback
  const results = await this.entityStore.search(targetName, { limit: 1 });
  return results[0] ?? null;
}
```

### Step 3: Map AST relationship types to graph types

```typescript
function mapAstRelToGraph(astType: string): GraphRelationshipType {
  const map: Record<string, GraphRelationshipType> = {
    'calls': 'CALLS',
    'extends': 'EXTENDS',
    'implements': 'IMPLEMENTS',
    'uses_type': 'USES',
    'instantiates': 'USES',
    'references': 'REFERENCES',
  };
  return map[astType] || 'RELATES_TO';
}
```

### Step 4: Natural language relationship extraction

**New file**: `src/indexer/nl-relationship-extractor.ts`

Extract entity mentions from document content and comments:

```typescript
export class NLRelationshipExtractor {
  /**
   * Find code entity references in natural language text.
   * Looks for backtick mentions, PascalCase names, and file paths.
   */
  extractMentions(text: string, knownEntities: Set<string>): EntityMention[] {
    const mentions: EntityMention[] = [];

    // Backtick references: `EntityStore`, `findSimilar()`
    for (const match of text.matchAll(/`([A-Za-z_][\w.]*(?:\(\))?)`/g)) {
      const name = match[1].replace('()', '');
      if (knownEntities.has(name)) {
        mentions.push({ name, confidence: 0.95, position: match.index! });
      }
    }

    // PascalCase names likely referencing classes/interfaces
    for (const match of text.matchAll(/\b([A-Z][a-z]+(?:[A-Z][a-z]+)+)\b/g)) {
      if (knownEntities.has(match[1])) {
        mentions.push({ name: match[1], confidence: 0.8, position: match.index! });
      }
    }

    // File path references: src/foo/bar.ts
    for (const match of text.matchAll(/\b(src\/[\w/.-]+\.\w+)\b/g)) {
      if (knownEntities.has(match[1])) {
        mentions.push({ name: match[1], confidence: 0.9, position: match.index! });
      }
    }

    return mentions;
  }
}
```

Wire this into the document indexer to create MENTIONS relationships between document sections and code entities they reference.

### Step 5: Update graph search to use new relationships

**File**: `src/retrieval/multi-strategy-search.ts`

The graph search already traverses all relationship types, so new relationships are automatically used. But we can improve relevance by weighting relationship types:

```typescript
// In graphSearch():
const typeWeights: Record<string, number> = {
  'IMPLEMENTS': 1.0,   // Strong signal
  'EXTENDS': 1.0,      // Strong signal
  'CALLS': 0.8,        // Good signal
  'CONTAINS': 0.6,     // Structural
  'IMPORTS': 0.5,      // Weak signal
  'USES': 0.7,         // Type usage
  'MENTIONS': 0.6,     // Doc reference
};
```

## Expected Result

```bash
# Before: graph search from GraphTraversal finds only parent file
ctx-sys context "GraphTraversal" --strategy graph
→ traversal.ts (file), types.ts (via IMPORTS)

# After: graph search finds related entities
ctx-sys context "GraphTraversal" --strategy graph
→ RelationshipStore (CALLS), Entity (USES type),
  TraversalOptions (USES type), getNeighborhood (CONTAINS)
```

## Success Criteria

- CALLS, EXTENDS, IMPLEMENTS, USES relationships stored during indexing
- Target resolution works for same-file and cross-file references
- Graph search returns meaningfully related entities
- Document sections linked to code entities they mention
- `ctx-sys graph <entity>` shows rich relationship graph
- Re-indexing updates relationships without duplicates (upsert)
