# F10g.4 Improve extractCodeSummary for Cleaner Context Display

**Phase**: 10g - Retrieval Foundations
**Priority**: Medium
**Dependencies**: None

## Problem

The `extractCodeSummary()` function in `src/retrieval/context-assembler.ts` compresses entity content for display when it exceeds the token budget. For classes and interfaces, it attempts to show the declaration, constructor, and public method signatures — but the extraction logic produces messy output in several cases:

### Current Issues

1. **Method signature regex is too loose** — The pattern `^(async\s+)?(public\s+)?[\w]+\s*\(` matches any line starting with a word followed by `(`, which can pick up function calls, conditionals, and other non-signature lines from the class body.

2. **No indentation normalization** — Extracted signatures have inconsistent indentation because some are raw lines and others get `'  ' + line.trim()` prepended.

3. **No clear structure** — The output mixes doc comments, declarations, constructor, and methods without separators, making it hard to scan.

4. **Function summary truncation** — `extractFunctionSummary` captures lines until it hits `{`, but multi-line parameter lists (common in TypeScript) produce broken output when parameters span many lines.

5. **No property extraction** — Class properties (especially TypeScript `readonly` and `public` declarations) are ignored, losing important structural information.

### Example: Current Output (messy)

```typescript
/**
 * Manages embedding generation and search.
 */
export class EmbeddingManager {
  constructor(
    private db: DatabaseConnection,
    private provider: EmbeddingProvider
  )
  async embed(text: string): Promise<number[]>
  async findSimilar(query: string, options?: SearchOptions): Promise<SimilarResult[]>
  async findSimilarByVector(vector: number[], options?: SearchOptions): Promise<SimilarResult[]>
  getProvider(): EmbeddingProvider
  if (this.cache.has(key)
  for (const chunk of chunks
  // ...
```

The last two lines are body code that leaked through the regex.

## Implementation

### Step 1: Fix method signature extraction regex

**File**: `src/retrieval/context-assembler.ts`

Replace the loose regex with proper TypeScript/JavaScript method signature detection:

```typescript
// Before (too loose):
if (line.match(/^(async\s+)?(public\s+)?[\w]+\s*\(/) && ...)

// After (specific to method declarations):
if (line.match(/^(async\s+)?(public\s+|protected\s+|static\s+|readonly\s+|get\s+|set\s+)*[\w]+\s*[<(]/) &&
    !line.startsWith('private') &&
    !line.startsWith('constructor') &&
    !line.startsWith('if') &&
    !line.startsWith('for') &&
    !line.startsWith('while') &&
    !line.startsWith('switch') &&
    !line.startsWith('return') &&
    !line.startsWith('const') &&
    !line.startsWith('let') &&
    !line.startsWith('var') &&
    !line.startsWith('this') &&
    !line.startsWith('//'))
```

### Step 2: Add property extraction for classes

After the declaration line and constructor, extract class properties:

```typescript
// 3. Public/readonly properties
for (let j = i + 1; j < lines.length; j++) {
  const line = lines[j].trim();
  // Stop at first method
  if (line.match(/^(async\s+)?(public\s+|protected\s+|static\s+)*[\w]+\s*[<(]/)) break;
  // Capture property declarations
  if (line.match(/^(public\s+|readonly\s+|static\s+|protected\s+)/) ||
      line.match(/^[\w]+\s*[?!]?\s*:\s*/)) {
    parts.push('  ' + line.replace(/=.*$/, '').trim() + ';');
  }
}
```

### Step 3: Improve function summary for multi-line signatures

Handle TypeScript multi-line parameter lists properly:

```typescript
function extractFunctionSummary(lines: string[], budget: number): string {
  const parts: string[] = [];
  let braceDepth = 0;
  let foundSignature = false;

  for (const line of lines) {
    parts.push(line);
    // Track parenthesis depth for multi-line params
    for (const ch of line) {
      if (ch === '(') braceDepth++;
      if (ch === ')') braceDepth--;
    }
    // Signature ends when we see { after balanced parens
    if (braceDepth <= 0 && line.includes('{') && !line.trim().startsWith('*')) {
      foundSignature = true;
      break;
    }
    if (parts.join('\n').length > budget) break;
  }

  if (foundSignature) {
    parts[parts.length - 1] = parts[parts.length - 1].replace(/\{.*$/, '{ // ... }');
  }

  return parts.join('\n').slice(0, budget);
}
```

### Step 4: Add visual separators between sections

```typescript
function extractClassSummary(lines: string[], budget: number): string {
  // ... doc comment + declaration ...

  // Properties section
  if (properties.length > 0) {
    parts.push('');
    parts.push(...properties);
  }

  // Constructor section
  if (constructorLines.length > 0) {
    parts.push('');
    parts.push(...constructorLines);
  }

  // Method signatures section
  if (methods.length > 0) {
    parts.push('');
    parts.push(...methods);
  }

  parts.push('}');
  // ...
}
```

## Expected Result

```typescript
// Before (messy, leaks body code):
export class EmbeddingManager {
  constructor(private db: DatabaseConnection, private provider: EmbeddingProvider)
  async embed(text: string): Promise<number[]>
  if (this.cache.has(key)

// After (clean signature view):
export class EmbeddingManager {

  private db: DatabaseConnection;
  private provider: EmbeddingProvider;

  constructor(db: DatabaseConnection, provider: EmbeddingProvider)

  async embed(text: string): Promise<number[]>
  async findSimilar(query: string, options?: SearchOptions): Promise<SimilarResult[]>
  async findSimilarByVector(vector: number[], options?: SearchOptions): Promise<SimilarResult[]>
  getProvider(): EmbeddingProvider
}
```

## Success Criteria

- No body code (if/for/while/return statements) leaks into class summaries
- Class properties are included in the summary
- Multi-line function signatures are handled correctly
- Visual separators between sections (properties, constructor, methods)
- Closing brace included for classes
- Output is valid, readable TypeScript that could serve as a type declaration
